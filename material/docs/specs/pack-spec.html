<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Pack200: A Packed Class Deployment Format For Java Applications</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <link rel="stylesheet" href="../resources/jdk-default.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Pack200: A Packed Class Deployment Format For Java Applications</h1>
</header>
<h2 id="contents">Contents</h2>
<div class="a1">
<p><a href="#introduction" class="skiplink">Skip Navigation Links</a></p>
</div>
<ul>
<li><a href="#introduction">1. Introduction</a></li>
<li><a href="#archive-inputs">2. Archive Inputs</a></li>
<li><a href="#archive-file-structure-summary">3. Archive File Structure Summary</a></li>
<li><a href="#introduction-to-integer-encodings">4. Introduction to Integer Encodings</a>
<ul>
<li><a href="#integer-encoding-schema">4.1. Integer Encoding Schema</a></li>
</ul></li>
<li><a href="#band-definitions">5. Band Definitions</a>
<ul>
<li><a href="#archive-segmentation">5.1. Archive Segmentation</a></li>
<li><a href="#archive-header">5.2. Archive Header</a>
<ul>
<li><a href="#archive-options-and-file-properties">5.2.1. Archive Options and File Properties</a></li>
<li><a href="#archive-entity-counts-and-class-format">5.2.2. Archive Entity Counts and Class Format</a></li>
</ul></li>
<li><a href="#constant-pools">5.3. Constant Pools</a>
<ul>
<li><a href="#scalar-constants">5.3.1. Scalar Constants</a></li>
<li><a href="#utf8-constants">5.3.2. Utf8 Constants</a></li>
<li><a href="#type-signatures">5.3.3. Type Signatures</a></li>
<li><a href="#tuple-constants">5.3.4. Tuple Constants</a></li>
<li><a href="#extra-constants">5.3.5. Extra Constants</a></li>
</ul></li>
<li><a href="#file-attributes">5.4. File Attributes</a></li>
<li><a href="#flags-and-attributes">5.5. Flags and Attributes</a>
<ul>
<li><a href="#assignment-of-flag-bits-to-attributes">5.5.1. Assignment of Flag Bits to Attributes</a></li>
<li><a href="#attribute-layout-definitions">5.5.2. Attribute Layout Definitions</a></li>
<li><a href="#recursive-layouts">5.5.3. Recursive Layouts</a></li>
<li><a href="#default-attribute-layouts">5.5.4. Default Attribute Layouts</a></li>
<li><a href="#stack-map-layouts">5.5.5. Stack Map Layouts</a></li>
<li><a href="#metadata-layouts">5.5.6. Metadata Layouts</a></li>
<li><a href="#unusual-layout-usages">5.5.7. Unusual Layout Usages</a></li>
</ul></li>
<li><a href="#source-file-abbreviation">5.6. Source File Abbreviation</a></li>
<li><a href="#nested-classes">5.7. Nested Classes</a></li>
<li><a href="#class-schema">5.8. Class Schema</a></li>
<li><a href="#attribute-bands">5.9. Attribute Bands</a>
<ul>
<li><a href="#metadata-transmission">5.9.1. Metadata Transmission</a></li>
</ul></li>
<li><a href="#bytecode-instructions">5.10. Bytecode Instructions</a></li>
</ul></li>
<li><a href="#specification-of-band-coding">6. Specification of Band Coding</a>
<ul>
<li><a href="#encoding-of-small-whole-numbers">6.1. Encoding of Small Whole Numbers</a>
<ul>
<li><a href="#scheme-of-multiple-codings">6.1.1. Scheme of Multiple Codings</a></li>
<li><a href="#definition-of-encoding-byte-sequences">6.1.2. Definition of Encoding Byte Sequences</a></li>
<li><a href="#definition-of-decoded-whole-number-values">6.1.3. Definition of Decoded Whole Number Values</a></li>
</ul></li>
<li><a href="#encoding-of-signed-integers">6.2. Encoding of Signed Integers</a>
<ul>
<li><a href="#further-discussion-of-sign-conversion">6.2.1. Further Discussion of Sign Conversion</a></li>
</ul></li>
<li><a href="#attributes-of-codings">6.3. Attributes of Codings</a></li>
<li><a href="#encoding-of-correlated-sequences">6.4. Encoding of Correlated Sequences</a></li>
<li><a href="#encodings-of-uncorrelated-values">6.5. Encodings of Uncorrelated Values</a>
<ul>
<li><a href="#table-of-favorites">6.5.1. Table of Favorites</a></li>
<li><a href="#sequence-of-tokens">6.5.2. Sequence of Tokens</a></li>
<li><a href="#sequence-of-unfavored-values">6.5.3. Sequence of Unfavored Values</a></li>
</ul></li>
<li><a href="#adaptive-encodings">6.6. Adaptive Encodings</a></li>
<li><a href="#meta-coding">6.7. Meta-Coding</a>
<ul>
<li><a href="#coding-specifier-structure">6.7.1. Coding Specifier Structure</a></li>
<li><a href="#coding-specifier-semantics">6.7.2. Coding Specifier Semantics</a></li>
<li><a href="#coding-specifier-meta-encoding">6.7.3. Coding Specifier Meta-Encoding</a></li>
<li><a href="#canonical-bhsd-codings">6.7.4. Canonical BHSD Codings</a></li>
</ul></li>
</ul></li>
<li><a href="#stability-of-decompressor-output">7. Stability of Decompressor Output</a>
<ul>
<li><a href="#ordering-of-attribute-lists">7.1. Ordering of Attribute Lists</a></li>
<li><a href="#ordering-of-constant-pools">7.2. Ordering of Constant Pools</a></li>
</ul></li>
<li><a href="#appendixes">8. Appendixes</a>
<ul>
<li><a href="#appendix-list-of-bands">8.1. Appendix: List of Bands</a></li>
<li><a href="#appendix-pseudo-code-illustrations">8.2. Appendix: Pseudo-Code Illustrations</a>
<ul>
<li><a href="#representation-of-cp_utf8-constant-pool">8.2.1. Representation of <code>cp_Utf8</code> Constant Pool</a></li>
<li><a href="#representation-of-cp_signature-constant-pool">8.2.2. Representation of <code>cp_Signature</code> Constant Pool</a></li>
<li><a href="#representation-of-byte-offsets">8.2.3. Representation of Byte Offsets</a></li>
<li><a href="#representation-of-predictable-nested-class-names">8.2.4. Representation of Predictable Nested Class Names</a></li>
</ul></li>
<li><a href="#appendix-design-faq">8.3. Appendix: Design FAQ</a>
<ul>
<li><a href="#general-questions">8.3.1. General Questions</a></li>
</ul></li>
</ul></li>
</ul>
<h2 id="revision-history">Revision History</h2>
<h3 id="deprecated-in-jdk-11-jun-2018">Deprecated in JDK 11 Jun-2018</h3>
<ul>
<li>This specification is deprecated along with Pack200 tools. Changes to classfile format will no longer be reflected in this spec. The tool behavior on encountering of new classfile elements is undefined. Design FAQ 3 below explains that as long as a compressor operates within the design spec, the decompressor should work without being updated. With the Pack200 distributed in OpenJDK, the default behavior when encountering unknown elements is to allow the classfile pass-through without compression. See <code>java.util.jar.Pack200.Packer.UNKNOWN_ATTRIBUTE</code>.</li>
</ul>
<h3 id="changes-made-to-support-jsr-308-mar-2013">Changes made to support JSR-308 Mar-2013</h3>
<ul>
<li>Added RuntimeVisibleTypeAnnotation and RuntimeInvisibleTypeAnnotation.</li>
</ul>
<h3 id="changes-made-to-support-jsr-335-feb-2013">Changes made to support JSR-335 Feb-2013</h3>
<ul>
<li>Added two new pseudo-instructions &quot;invokespecial_int&quot; and &quot;invokestatic_int&quot; referencing cp_Imethod operands.</li>
</ul>
<h3 id="methodparameters-flag-changed-feb-2013">MethodParameters Flag changed Feb-2013</h3>
<ul>
<li>Changed flag from u4 to u2</li>
</ul>
<h3 id="changes-made-to-support-methodparameters-dec-2012">Changes made to support MethodParameters Dec-2012</h3>
<ul>
<li>Increment the version number from 170.0 to 171.0</li>
<li>Added attribute structure</li>
</ul>
<h3 id="changes-made-for-jsr-292-support-aug-2011">Changes made for JSR 292 support Aug-2011</h3>
<ul>
<li>Bump the pack200 file format version number from 160.* to 170.0</li>
<li>Add optional cp_extra_counts to the archive header.</li>
<li>Add 4 extra constant pools: cp_MethodHandle, cp_MethodType, cp_BootstrapMethod, cp_InvokeDynamic.</li>
<li>Defined the combined constant pool cp_AnyMember, comprising cp_{Field,Method,Imethod}.</li>
<li>Defined the combined constant pool cp_LoadableValue, comprising valid ldc operands.</li>
<li>Add new attribute layout codes for new constants: KM, KT, RY, RB.</li>
<li>Add combined layout codes KL (any ldc-able value) and RN (AnyMember), supplementing RQ.</li>
<li>Change the pseudo-instruction name &quot;aldc&quot; to &quot;sldc&quot;, and add &quot;qldc&quot;.</li>
</ul>
<h3 id="changes-made-for-mr-1-01-jun-2005">Changes made for MR #1 01-Jun-2005</h3>
<ul>
<li>Adjust StackMapTable based on JSR-202 changes.</li>
<li>Bump the pack200 file format version number from 160.0 to 160.1</li>
<li>Clarify inconsistent tie-breaker rule in centrality comparisons.</li>
</ul>
<h3 id="changes-made-for-mr-1-20-apr-2005">Changes made for MR #1 20-Apr-2005</h3>
<ul>
<li>Reinstate StackMap as StackMapTable JSR-202.</li>
</ul>
<hr />
<h2 id="introduction">1. Introduction</h2>
<p>This document specifies an archive format called &quot;Pack200&quot;. It is optimized for applications written in the Java programming language. Such applications are usually delivered as collections of classes, sometimes with associated resource files.</p>
<p>This format allows any number (from one to hundreds of thousands) of Java classes to be encoded by a compressor, transmitted compactly in a single block of bytes, and decoded by a decompressor into equivalent Java class files. Because it can also represent class resources and other &quot;side files&quot;, it can serve as an alternative to the JAR archive for some deployment tasks, notably downloading Java applications.</p>
<p>The Pack200 format can decrease the size of a Java application by a factor of seven to nine, compared with an equivalent JAR containing uncompressed (&quot;stored&quot;) class files. By contrast, using the zip DEFLATE algorithm integral to JAR and ZIP archives gains a factor of two. The undocumented &quot;crunch&quot; mechanism, used to deploy JDK downloads in the past, gains a corresponding factor of five to six. Note that all these figures assume and incorporate the effects of a post-pass with DEFLATE or a similar off-the-shelf compression algorithm. (See <a href="https://www.ietf.org/rfc/rfc1951.txt">DEFLATE Compressed Data Format Specification</a> for more information.)</p>
<p>The main motivation for this format is to decrease disk and bandwidth requirements for Java application packaging, transmission, and delivery. An earlier version has been used to package the downloads for Java SE 1.4.1 and 1.4.2 (code names &quot;Hopper&quot; and &quot;Mantis&quot;).</p>
<p>This format is not intended for fast loading into a virtual machine, and does not attempt to improve start-up speed or memory footprint in running Java applications. The heavy engineering requirements on a directly loadable file format would make optimal compression impossible. The decompressor of an aggressively compressed file will have a complex job to do, and must be allowed memory and CPU time to do this job. We assume that Pack200 archives will be unpacked on the same classes of machine that run Java SE and Java EE applications.</p>
<p>This format is batch-oriented, optimized for packaging and transmission of Java classes. It does not support random access of individually stored classes. In order to emphasize the sequential nature of this archive format, we will use the verb <em>transmit</em>, rather than <em>store</em>, to refer to the formatting of data produced by a compressor and accepted by a decompressor.</p>
<p>This format does not attempt to duplicate work performed by DEFLATE or other byte-oriented compression algorithms. Typically, tools using Pack200 will further compress archives by storing them in ZIP files or using some other compression technique. The presence of such a post-pass compressor is an assumption made by the design of Pack200.</p>
<p>This specification is complex, and may seen to some readers needlessly complex. The design decisions reflected here have been motivated by extensive testing and experimentation with actual Java class files found in real products. An attempt to remove complexity from this specification is likely also to remove measurably significant compression efficiency.</p>
<h2 id="archive-inputs">2. Archive Inputs</h2>
<p>A Pack200 archive, like a JAR file, carries images of class files and other (&quot;resource&quot;) files arranged in a hierarchical directory structure.</p>
<p>No special compression or transformation is performed on any file other than class files, other than (possibly) reordering them by file type. The post-pass compressor is assumed to provide adequate compression on those spans of the archive which carry images of non-class files.</p>
<p>Classes are represented in a form which suppresses their individual constant pools, in favor of a large constant pool that serves the entire archive. Thus, when a class file is extracted from a Pack200 archive, a new constant pool will be created for it, and all constant pool references adjusted. This does not change the semantics of the class, but it will generally modify the bitwise image of the file, and perhaps even its size, as unused constant pool entries are deleted.</p>
<p>Note that every class file must be fully parsed by the compressor, so that all constant pool indexes may be found and (later) renumbered. This requirement applies to any class, field, method, or code attribute which refers to the constant. The Pack200 format supports a moderate range of attributes. A modest variety of new attribute layouts may be declared to the compressor, and the Pack200 format provides a place to transmit such layouts for use by decompressors. See the section <a href="#attribute-layout-definitions">Attribute Layout Definitions</a> for more information.</p>
<h2 id="archive-file-structure-summary">3. Archive File Structure Summary</h2>
<p>The archive file consists of a short <em>archive header</em>, followed by a number of independent file sections called <em>bands</em>. (There are about 100 of them; this number can vary.) Each band transmits an array of small integers, called the <em>elements</em> of the band. After the archive header, the archive consists only of bands.</p>
<p>Logically, a band is an implicitly sized array of 32-bit unsigned integers. However, it is rare for a band to physically require more than one or two bytes per element, since element encodings are chosen to transmit the actual band values more compactly.</p>
<p>A band has no fixed header, not even an indication of its size. The count of band elements is deduced by the decompressor from the contents of previous bands, or (ultimately) from the archive header.</p>
<p>The elements of any given band have a common meaning and role. For example, the names of all transmitted classes are in a single band, while all the class field counts are in a different band. Each band is transmitted as a contiguous segment of bytes within the archive. This contiguity is the main reason that a Pack200 archive, while compact to begin with, is very compressible by utilities like zip.</p>
<p>In some bands, each element helps describe one object. For example, each class is associated with a count of fields, which is given in the archive as a corresponding value in the <code>class_field_count</code> band. In other bands, one object may be described by a <em>run</em> of zero or more elements in a band. For example, the interfaces implemented by a class are given in the archive as a corresponding run of zero or more values in the <code>class_interface</code> band; each such value is an index referring to a single class.</p>
<p>A very few bands (less than 10) contain non-homogeneous bytes, such as the images of resource files. These few are called <em>byte bands</em>. Many of the bands contain references into the constant pool. Some contain access modifier flags and related bits. One band, called the <em>char band</em>, contains string characters in a specially chosen encoding called &quot;CHAR3&quot; (somewhat akin to UTF8, but not identical). The rest of the bands transmit integers with a variety of other interpretations.</p>
<p>One of the integer bands (cp_Utf8_big_chars) carries the characters of a single CONSTANT_Utf8 string selected for special treatment. Uniquely, this band is repeated zero or more times, depending on how many strings are selected for this special treatment. (These specially-transmitted &quot;big strings&quot; are explained in the section <a href="#big_string">Utf8 Constants</a>.)</p>
<p>Most bands have an easily understood function, such as transmitting the number of methods in a class, or the name of a field, or the operand of a &quot;getfield&quot; bytecode instruction.</p>
<p>Except for the special case of byte bands, a band is never considered as a sized span of bytes, but rather as a counted series of elements which are encoded integers. Since integer encodings are typically variable-sized (when regarded as byte sequences), there is no firm rule for deriving a band's byte size from its element count. Indeed, finding the end of a band requires that it be parsed byte-by-byte.</p>
<h2 id="introduction-to-integer-encodings">4. Introduction to Integer Encodings</h2>
<p>Each band uses one or more coding tactics to encode its elements as sequences of bytes. (The post-pass compressor is expected to turn these bytes into bit sequences, but its actions are not specified by this document.) The Pack200 compressor is free to choose and vary encoding tactics used by a band. The encoding tactics used in one band are independent of those used in other bands. The space of supported encoding tactics is an important part of the Pack200 specification. The present section introduces these encodings, which are defined in detail in the section <a href="#specification-of-band-coding">Specification of Band Coding</a>.</p>
<p>As one might expect, byte bands (which encode bytewise data such as the resource file images) encode their integers as unsigned 8-bit bytes. This encoding is named BYTE1 in this specification. (Compare the type &quot;u1&quot; in the class file definition.)</p>
<p>Other bands have values with a much larger dynamic range, including (in a few cases) negative numbers, and/or values all the way up to the 32-bit unsigned maximum. Most of these encodings are variable-length, in the expectation that the typical band element will be relatively small in magnitude, even though some elements may be large and require more bytes to represent. Some bands that are expected to exhibit strong correlations in their element sequences are encoded as successive differences (delta encoding) rather than absolute numeric values.</p>
<p>Each band is associated with a <em>primary encoding</em> which the compressor and decompressor agree to use when transmitting elements of that band. For any band after the end of the segment header, except for the byte bands, the compressor can optionally specify a <em>secondary encoding</em> to use instead of the primary encoding. In essence, the band's encoding defaults to the primary, unless there is an explicitly declared secondary. This allows the Pack200 format to adapt more closely to the actual statistics of band elements.</p>
<p>For example, most bands, such as those holding counts and sizes, have a primary encoding called UNSIGNED5. This is a general-purpose unsigned encoding which represents values in the range [0..191] as a single byte, and scales up to a maximum size of five bytes for numbers larger than about fifty million. However, if a band contains only numbers in the range [0,255], the BYTE1 encoding is more compact, and the compressor is allowed to instruct the decompressor to use this instead.</p>
<p>When the compressor specifies a secondary encoding, it must emit an optional <em>band coding specifier</em>, which is described in the section <a href="#meta-coding">Meta-Coding</a>. A customized encoding method often saves many bytes, if it matches more precisely the actual dynamic range of the band's element values.</p>
<h3 id="integer-encoding-schema">4.1. Integer Encoding Schema</h3>
<p>The Pack200 format is based on a schema of integer encoding systems, parameterized by four numbers (B,H,S,D). From this infinite set, about 10 selected encodings serve as primary encodings for bands, and about 100 more serve as optional encodings. The system of (B,H,S,D) encodings is explained at length in the section <a href="#specification-of-band-coding">Specification of Band Coding</a>. For the present purposes, a brief introduction will suffice.</p>
<p>The parameter B (1&lt;=B&lt;=5) is the maximum length in bytes of the encoding of a single integer. Less significant bits are always encoded in earlier bytes.</p>
<p>The parameter H (1&lt;=H&lt;=256) is the radix of the encoding. it also determines the conditions under which the encoding's byte sequences terminate. The co-parameter L (0&lt;=L&lt;=255) is defined as (256-H). Encoded byte sequences are allowed to contain only one byte with a value less than L, and that byte must be the last in the sequence. Thus, larger H values make for longer average encoding lengths. If H is 256 and L is zero, then the encoding method is fixed-length, because all encodings must be exactly B bytes long.</p>
<p>The parameter S (0&lt;=S&lt;=2) determines whether and how the encoding represents signed numbers. (More precisely, since band elements are conventionally regarded as unsigned 32-bit integers, S determines the coding of band elements larger than the largest 31-bit unsigned number, 2147483647. But we shall continue to refer to such numbers as negative, where the distinction is irrelevant.) S denotes the number of least-significant bits which serve as a sign bit. If S is zero, the numbers are unsigned. If S is one, the LSB of the unsigned number is exclusive-ored into the right-shifted remainder of the unsigned number to produce a corresponding signed number. If S is more than one, the signed number produced is negative only if all S least-significant bits are set, and otherwise these low bits contribute to the positive magnitude of the integer. This representation is efficient for bands containing mostly-positive numbers, such as bytecode branch offsets. The interpretation of sign bits is more precisely described in the section <a href="#encoding-of-signed-integers">Encoding of Signed Integers</a>.</p>
<p>The parameter D (0&lt;=D&lt;=1) determines whether the band transmits its data via successive differences (i.e., delta encoding). In writing these encodings, the parameters S and D may be omitted if both are zero, and D may be omitted if zero.</p>
<p>Thus, the encoding (1,256,0,0), also written as (1,256), represents numbers as unsigned bytes, while (4,256) represents numbers as unsigned little-endian 32-bit integers. The encoding (1,256,1) maps single bytes to numbers in the range [-128,127]. The encoding (1,256,1,1) expresses any sequence of numbers whose successive differences are in the range [-128,127] (and whose first number is in that range).</p>
<p>The very common encoding UNSIGNED5 can represent the full unsigned range of 32-bit integers. A byte sequence in this encoding consists either of four bytes less than 192 followed by an arbitrary byte, or else from zero to three bytes less than 192 followed by a byte greater than or equal to 192. The unsigned value is formed by scaling each succeeding byte by successive powers of the radix 64, and adding all the scaled byte values together.</p>
<table>
<caption style="display:none">
integer encoding scheme
</caption>
<tr style="text-align:right">
<th id="integer_encoding_scheme_v">
value
</th>
<th id="integer_encoding_scheme_b0">
byte 0
</th>
<th id="integer_encoding_scheme_b1">
byte 1
</th>
<th id="integer_encoding_scheme_b2">
byte 2
</th>
<th id="integer_encoding_scheme_b3">
byte 3
</th>
<th id="integer_encoding_scheme_b4">
byte 4
</th>
</tr>
<tr style="text-align:right">
<td headers="integer_encoding_scheme_v">
1
</td>
<td headers="integer_encoding_scheme_b0">
1
</td>
<td headers="integer_encoding_scheme_b1">
 
</td>
<td headers="integer_encoding_scheme_b2">
 
</td>
<td headers="integer_encoding_scheme_b3">
 
</td>
<td headers="integer_encoding_scheme_b4">
 
</td>
</tr>
<tr style="text-align:right">
<td headers="integer_encoding_scheme_v">
191
</td>
<td headers="integer_encoding_scheme_b0">
191
</td>
<td headers="integer_encoding_scheme_b1">
 
</td>
<td headers="integer_encoding_scheme_b2">
 
</td>
<td headers="integer_encoding_scheme_b3">
 
</td>
<td headers="integer_encoding_scheme_b4">
 
</td>
</tr>
<tr style="text-align:right">
<td headers="integer_encoding_scheme_v">
192
</td>
<td headers="integer_encoding_scheme_b0">
192
</td>
<td headers="integer_encoding_scheme_b1">
0
</td>
<td headers="integer_encoding_scheme_b2">
 
</td>
<td headers="integer_encoding_scheme_b3">
 
</td>
<td headers="integer_encoding_scheme_b4">
 
</td>
</tr>
<tr style="text-align:right">
<td headers="integer_encoding_scheme_v">
193
</td>
<td headers="integer_encoding_scheme_b0">
193
</td>
<td headers="integer_encoding_scheme_b1">
0
</td>
<td headers="integer_encoding_scheme_b2">
 
</td>
<td headers="integer_encoding_scheme_b3">
 
</td>
<td headers="integer_encoding_scheme_b4">
 
</td>
</tr>
<tr style="text-align:right">
<td headers="integer_encoding_scheme_v">
255
</td>
<td headers="integer_encoding_scheme_b0">
255
</td>
<td headers="integer_encoding_scheme_b1">
0
</td>
<td headers="integer_encoding_scheme_b2">
 
</td>
<td headers="integer_encoding_scheme_b3">
 
</td>
<td headers="integer_encoding_scheme_b4">
 
</td>
</tr>
<tr style="text-align:right">
<td headers="integer_encoding_scheme_v">
256
</td>
<td headers="integer_encoding_scheme_b0">
192
</td>
<td headers="integer_encoding_scheme_b1">
1
</td>
<td headers="integer_encoding_scheme_b2">
 
</td>
<td headers="integer_encoding_scheme_b3">
 
</td>
<td headers="integer_encoding_scheme_b4">
 
</td>
</tr>
<tr style="text-align:right">
<td headers="integer_encoding_scheme_v">
512
</td>
<td headers="integer_encoding_scheme_b0">
192
</td>
<td headers="integer_encoding_scheme_b1">
5
</td>
<td headers="integer_encoding_scheme_b2">
 
</td>
<td headers="integer_encoding_scheme_b3">
 
</td>
<td headers="integer_encoding_scheme_b4">
 
</td>
</tr>
<tr style="text-align:right">
<td headers="integer_encoding_scheme_v">
1024
</td>
<td headers="integer_encoding_scheme_b0">
192
</td>
<td headers="integer_encoding_scheme_b1">
13
</td>
<td headers="integer_encoding_scheme_b3">
 
</td>
<td headers="integer_encoding_scheme_v">
 
</td>
<td headers="integer_encoding_scheme_b4">
 
</td>
</tr>
<tr style="text-align:right">
<td headers="integer_encoding_scheme_v">
2048
</td>
<td headers="integer_encoding_scheme_b0">
192
</td>
<td headers="integer_encoding_scheme_b1">
29
</td>
<td headers="integer_encoding_scheme_b2">
 
</td>
<td headers="integer_encoding_scheme_b3">
 
</td>
<td headers="integer_encoding_scheme_b4">
 
</td>
</tr>
<tr style="text-align:right">
<td headers="integer_encoding_scheme_v">
12479
</td>
<td headers="integer_encoding_scheme_b0">
255
</td>
<td headers="integer_encoding_scheme_b1">
191
</td>
<td headers="integer_encoding_scheme_b2">
 
</td>
<td headers="integer_encoding_scheme_b3">
 
</td>
<td headers="integer_encoding_scheme_b4">
 
</td>
</tr>
<tr style="text-align:right">
<td headers="integer_encoding_scheme_v">
12480
</td>
<td headers="integer_encoding_scheme_b0">
192
</td>
<td headers="integer_encoding_scheme_b1">
192
</td>
<td headers="integer_encoding_scheme_b2">
0
</td>
<td headers="integer_encoding_scheme_b3">
 
</td>
<td headers="integer_encoding_scheme_b4">
 
</td>
</tr>
<tr style="text-align:right">
<td headers="integer_encoding_scheme_v">
798911
</td>
<td headers="integer_encoding_scheme_b0">
255
</td>
<td headers="integer_encoding_scheme_b1">
255
</td>
<td headers="integer_encoding_scheme_b2">
191
</td>
<td headers="integer_encoding_scheme_b3">
 
</td>
<td headers="integer_encoding_scheme_b4">
 
</td>
</tr>
<tr style="text-align:right">
<td headers="integer_encoding_scheme_v">
798912
</td>
<td headers="integer_encoding_scheme_b0">
192
</td>
<td headers="integer_encoding_scheme_b1">
192
</td>
<td headers="integer_encoding_scheme_b2">
192
</td>
<td headers="integer_encoding_scheme_b3">
0
</td>
<td headers="integer_encoding_scheme_b4">
 
</td>
</tr>
<tr style="text-align:right">
<td headers="integer_encoding_scheme_v">
51130559
</td>
<td headers="integer_encoding_scheme_b0">
255
</td>
<td headers="integer_encoding_scheme_b1">
255
</td>
<td headers="integer_encoding_scheme_b2">
255
</td>
<td headers="integer_encoding_scheme_b3">
191
</td>
<td headers="integer_encoding_scheme_b4">
 
</td>
</tr>
<tr style="text-align:right">
<td headers="integer_encoding_scheme_v">
51130560
</td>
<td headers="integer_encoding_scheme_b0">
192
</td>
<td headers="integer_encoding_scheme_b1">
192
</td>
<td headers="integer_encoding_scheme_b2">
192
</td>
<td headers="integer_encoding_scheme_b3">
192
</td>
<td headers="integer_encoding_scheme_b4">
0
</td>
</tr>
<tr style="text-align:right">
<td headers="integer_encoding_scheme_v">
0xFFFFFFFF
</td>
<td headers="integer_encoding_scheme_b0">
255
</td>
<td headers="integer_encoding_scheme_b1">
252
</td>
<td headers="integer_encoding_scheme_b2">
252
</td>
<td headers="integer_encoding_scheme_b3">
252
</td>
<td headers="integer_encoding_scheme_b4">
252
</td>
</tr>
</table>
<p>Here is the set of primary encodings used by at least one band:</p>
<table>
<caption style="display:none">
set of primary encodings
</caption>
<tr>
<th id="set_of_primary_encodings_t">
Type
</th>
<th id="set_of_primary_encodings_n">
Name
</th>
<th id="set_of_primary_encodings_p">
Purpose
</th>
</tr>
<tr>
<td headers="set_of_primary_encodings_t">
(1,256)
</td>
<td headers="set_of_primary_encodings_n">
BYTE1
</td>
<td headers="set_of_primary_encodings_p">
bytes
</td>
</tr>
<tr>
<td headers="set_of_primary_encodings_t">
(3,128)
</td>
<td headers="set_of_primary_encodings_n">
CHAR3
</td>
<td headers="set_of_primary_encodings_p">
Java characters
</td>
</tr>
<tr>
<td headers="set_of_primary_encodings_t">
(5,4)
</td>
<td headers="set_of_primary_encodings_n">
BCI5
</td>
<td headers="set_of_primary_encodings_p">
bytecode positions
</td>
</tr>
<tr>
<td headers="set_of_primary_encodings_t">
(5,4,2)
</td>
<td headers="set_of_primary_encodings_n">
BRANCH5
</td>
<td headers="set_of_primary_encodings_p">
bytecode branch offsets
</td>
</tr>
<tr>
<td headers="set_of_primary_encodings_t">
(5,64)
</td>
<td headers="set_of_primary_encodings_n">
UNSIGNED5
</td>
<td headers="set_of_primary_encodings_p">
general unsigned ints
</td>
</tr>
<tr>
<td headers="set_of_primary_encodings_t">
(5,64,1)
</td>
<td headers="set_of_primary_encodings_n">
SIGNED5
</td>
<td headers="set_of_primary_encodings_p">
general signed ints
</td>
</tr>
<tr>
<td headers="set_of_primary_encodings_t">
(5,64,0,1)
</td>
<td headers="set_of_primary_encodings_n">
UDELTA5
</td>
<td headers="set_of_primary_encodings_p">
monotonic sequences
</td>
</tr>
<tr>
<td headers="set_of_primary_encodings_t">
(5,64,1,1)
</td>
<td headers="set_of_primary_encodings_n">
DELTA5
</td>
<td headers="set_of_primary_encodings_p">
autocorrelated sequences
</td>
</tr>
<tr>
<td headers="set_of_primary_encodings_t">
(5,64,2,1)
</td>
<td headers="set_of_primary_encodings_n">
MDELTA5
</td>
<td headers="set_of_primary_encodings_p">
mostly monotonic sequences
</td>
</tr>
</table>
<h2 id="band-definitions">5. Band Definitions</h2>
<p>The file as a whole consists of about 200 bands in four major groups. After a header, the constant pool contents come first, followed by most of the class schema, followed by a consolidation of all attribute information (for classes, fields, methods, codes, and the archive as a whole), and ending with bytecodes for all methods.</p>
<p>Rather than describe the bands in a long and dull sequence, we use a simple, non-recursive grammar to present them in an organized fashion. This grammar roughly parallels the grammar of a class file:</p>
<pre class="codeblock"><code>  pack200_segment:
        segment_header
        *band_headers :BYTE1
        cp_bands
        attr_definition_bands
        ic_bands
        class_bands
        bc_bands
        file_bands
</code></pre>
<p>The terminals of this grammar are scalars and bands. To make the terminals easier to recognize, scalar names begin with pound sign &quot;#&quot; and band names begin with a star &quot;*&quot;. A scalar is an encoded integer (or a small fixed number of them) which appears within the header of the archive file. When a scalar is mentioned in the grammar, it is followed by a colon and the encoding and bracketed count of the scalar value(s). Whenever a band is mentioned, it is followed by a colon and its primary encoding, followed by a comment in square brackets indicating its length. If the band encodes references into some other data structure, such as a constant pool, that structure is mentioned as a comment in parentheses. If the references are allowed to be null, that fact is mentioned also.</p>
<p>Here is an example:</p>
<pre class="codeblock"><code>  example_non_terminal:
        other_non_terminal
        #single_scalar_integer :UNSIGNED5[1]
        #four_byte_scalar :BYTE1[4]
        *band_of_integers :UNSIGNED5 [#integer_count]
        *band_of_method_references :UNSIGNED5 [SUM(*ref_counts)] (cp_Method)
        *band_of_strings_and_nulls :UNSIGNED5 [...] (null or cp_String)
</code></pre>
<p>Many of the band lengths are simply references to previous scalars (such as <code>[#class_count]</code>) or sums of previous bands which transmit counts (e.g., <code>[SUM(*class_method_count)]</code>). These bracketed lengths must be regarded as comments in the grammar, since the text of the specification defines band lengths verbally. Band counts which cannot be briefly summarized as sometimes specified in a partial expression which contains an ellipsis.</p>
<p>Occasionally we use additional grammatical notations. We use the ordinary regular expression operators <code>(X | Y)</code> means a match for either X or Y, <code>(X)*</code> means any number of matches for X, <code>(X)+</code> means one or more matches for X, and <code>(X)?</code> means either a match for X or nothing. In one case described in the section <a href="#utf8-constants">Utf8 Constants</a>, where a band may have several instances, the expression <em>(band1)</em><code>\ **\</code><em>length(band2)</em> means that there are as many instances of <em>band1</em> as there are elements in <em>band2</em>. Likewise, in three cases, the expression <em>(band1)</em><code>\ **\</code><em>#scalar</em> indicates that there are zero or one instances of <em>band1</em> according to the value (zero or one, respectively) of the boolean scalar value.</p>
<h3 id="archive-segmentation">5.1. Archive Segmentation</h3>
<p>The entire Pack200 archive format may be repeated one or more times in a transmission to the decompressor. In this case, each complete set of transmitted bands bands is viewed as a <em>segment</em> of the whole transmission. The decompressor is required to accept multiple segments, and to process each segment independently in order. The output files resulting from each segment are accumulated in order. If the decompressor is producing a JAR file, multiple segments must be accumulated into one output JAR file, whose elements are made up of the respective elements transmitted in each segment, in order.</p>
<pre class="codeblock"><code>  pack200_archive:
        (pack200_segment)+
</code></pre>
<p>Note that each segment begins anew with the Pack200 magic number and version numbers.</p>
<p>(With one caveat, this means that Pack200 archives may be concatenated with the natural meaning of combining the archives they represent. As will be seen below, if the <code>#archive_size</code> field is not present in each segment header, it must be inserted before another segment is appended, so that the decompressor can find the end of each segment. The segment header format is such that this adjustment can be made easily.)</p>
<p>When combined with a streaming transport layer, segmentation provides a way for a compressor to decrease latency or to decrease the decompressor's memory requirements, at a cost in compressor efficiency.</p>
<p>Segmentation can also help solve a scaling problem with very large archives (of many tens of megabytes), in which the width of indexes into the combined global constant pools can grow beyond the benefits of global constant sharing. By starting a new segment, the compressor resets the decompressor's constant pools, clearing out useless constants, at the cost of restating constants that are still in use. (The trade-offs are similar in flavor to the design of copying garbage collectors.)</p>
<h3 id="archive-header">5.2. Archive Header</h3>
<p>The header consists of a magic number and version information, in a format exactly parallel to the Java class file format. However, besides the magic number, there are no other big-endian integers in the Pack200 format. All integer encodings in bands present arithmetically less-significant bits first.</p>
<p>Only the archive magic numbers (the first four bytes of the segment header) are fixed in size. All other archive structures are variable in size and must therefore be parsed sequentially. Generally speaking, decompressors must perform two passes over each segment of the archive, one to size and parse the bands, and one to sequentially extract information from the bands into each JAR element in the output.</p>
<pre class="codeblock"><code>  segment_header:
        archive_magic archive_header

  archive_magic:
        #archive_magic_word :BYTE1[4]

  archive_header:
        #archive_minver :UNSIGNED5[1]
        #archive_majver :UNSIGNED5[1]
        #archive_options :UNSIGNED5[1]
        (archive_file_counts) ** (#have_file_headers)
        (archive_special_counts) ** (#have_special_formats)
        cp_counts
        class_counts

  archive_file_counts:
        #archive_size_hi :UNSIGNED5[1]
        #archive_size_lo :UNSIGNED5[1]
        #archive_next_count :UNSIGNED5[1]
        #archive_modtime :UNSIGNED5[1]
        #file_count :UNSIGNED5[1]
</code></pre>
<p>The <code>archive_magic_word</code> consists of the four bytes 0xCA, 0xFE, 0xD0, 0x0D. The <code>#archive_minver</code> must be the number 1. The <code>#archive_majver</code> must be the number 170. Both of the latter two values may be incremented in the future to reflect small revisions in this file format. Note that in previous versions of this standard, the minor and major version numbers were 7 and 150, or 1 and 160.</p>
<p>The header also contains initial counts of constant pool entries and other &quot;top-level&quot; entities. All of these counts are given in UNSIGNED5 format. Some of these counts are conditionally present, controlled by bits in the <code>#archive_options</code> word. The rule for a missing header value (and for missing values in general unless otherwise specified) is that the decompressor must behave as if it had received an explicit zero value.</p>
<h4 id="archive-options-and-file-properties">5.2.1. Archive Options and File Properties</h4>
<p>The <code>#archive_options</code> word is interpreted bitwise. Certain bits are given symbolic names as follows, where the LSB is numbered as bit zero:</p>
<table>
<caption style="display:none">
bits used in archive_options word
</caption>
<tr>
<th id="archive_options_b">
Bit
</th>
<th id="archive_options_n">
Name
</th>
<th id="archive_options_m">
Meaning if set in <code>#archive_options</code>
</th>
</tr>
<tr>
<td headers="archive_options_b">
0
</td>
<td headers="archive_options_n">
<code>have_special_formats</code>
</td>
<td headers="archive_options_m">
<code>archive_special_counts</code> contains counts
</td>
</tr>
<tr>
<td headers="archive_options_b">
1
</td>
<td headers="archive_options_n">
<code>have_cp_numbers</code>
</td>
<td headers="archive_options_m">
<code>cp_number_counts</code> contains counts
</td>
</tr>
<tr>
<td headers="archive_options_b">
2
</td>
<td headers="archive_options_n">
<code>have_all_code_flags</code>
</td>
<td headers="archive_options_m">
<code>code_flags_lo</code> contains an element for every code
</td>
</tr>
<tr>
<td headers="archive_options_b">
3
</td>
<td headers="archive_options_n">
<code>have_cp_extra_counts</code>
</td>
<td headers="archive_options_m">
<code>cp_extra_counts</code> contains counts
</td>
</tr>
<tr>
<td headers="archive_options_b">
4
</td>
<td headers="archive_options_n">
<code>have_file_headers</code>
</td>
<td headers="archive_options_m">
<code>archive_file_counts</code> contains counts
</td>
</tr>
<tr>
<td headers="archive_options_b">
5
</td>
<td headers="archive_options_n">
<code>deflate_hint</code>
</td>
<td headers="archive_options_m">
request compressed JAR file for all elements
</td>
</tr>
<tr>
<td headers="archive_options_b">
6
</td>
<td headers="archive_options_n">
<code>have_file_modtime</code>
</td>
<td headers="archive_options_m">
<code>file_modtime</code> contains modtimes
</td>
</tr>
<tr>
<td headers="archive_options_b">
7
</td>
<td headers="archive_options_n">
<code>have_file_options</code>
</td>
<td headers="archive_options_m">
<code>file_options</code> contains option bits
</td>
</tr>
<tr>
<td headers="archive_options_b">
8
</td>
<td headers="archive_options_n">
<code>have_file_size_hi</code>
</td>
<td headers="archive_options_m">
<code>file_size_hi</code> contains high-order size words
</td>
</tr>
<tr>
<td headers="archive_options_b">
9
</td>
<td headers="archive_options_n">
<code>have_class_flags_hi</code>
</td>
<td headers="archive_options_m">
<code>class_flags_hi</code> contains extra attribute flags
</td>
</tr>
<tr>
<td headers="archive_options_b">
10
</td>
<td headers="archive_options_n">
<code>have_field_flags_hi</code>
</td>
<td headers="archive_options_m">
<code>field_flags_hi</code> contains extra attribute flags
</td>
</tr>
<tr>
<td headers="archive_options_b">
11
</td>
<td headers="archive_options_n">
<code>have_method_flags_hi</code>
</td>
<td headers="archive_options_m">
<code>method_flags_hi</code> contains extra attribute flags
</td>
</tr>
<tr>
<td headers="archive_options_b">
12
</td>
<td headers="archive_options_n">
<code>have_code_flags_hi</code>
</td>
<td headers="archive_options_m">
<code>code_flags_hi</code> contains extra attribute flags
</td>
</tr>
<tr>
<td headers="archive_options_b">
13
</td>
<td headers="archive_options_n">
 
</td>
<td headers="archive_options_m">
(unused, must be zero)
</td>
</tr>
<tr>
<td headers="archive_options_b">
...
</td>
<td headers="archive_options_n">
 
</td>
<td headers="archive_options_m">
(unused, must be zero)
</td>
</tr>
<tr>
<td headers="archive_options_b">
31
</td>
<td headers="archive_options_n">
 
</td>
<td headers="archive_options_m">
(unused, must be zero)
</td>
</tr>
</table>
<p>If <code>have_special_formats</code> (the LSB) is set, the band <code>archive_special_counts</code> will have two elements, as specified in the grammar. Otherwise this band will have zero elements. Similarly, if <code>have_cp_numbers</code> is set, the band <code>cp_number_counts</code> will have four elements, as specified in the grammar. Otherwise this band will have zero elements. If <code>have_all_code_flags</code> is set, the band <code>code_flags</code> must contain one element for every <code>Code</code> attribute. Otherwise this band may have fewer elements. (This option is useful when <code>Code</code> attributes are rich in sub-attributes, perhaps because the JAR contains large amounts of debugging information.)</p>
<p>If <code>have_cp_extra_counts</code> is set, the band <code>cp_extra_counts</code> will contain four elements, as specified in the grammar. Otherwise this band will have zero elements. (The flag may only be set when <code>#archive_majver</code> is 170 or higher. These extra counts correspond to additional constant pool types introduced in recent revisions of the classfile format.)</p>
<p>If <code>have_file_headers</code> is set, the band <code>archive_file_counts</code> will have five elements, as specified in the grammar. Otherwise this band will have zero elements. If <code>deflate_hint</code> is set, the decompressor is requested (but not required) to reduce the size of its output. For example, if it produces a JAR file, it may deflate the JAR elements. If the option <code>have_file_modtime</code> (or <code>have_file_options</code>, <code>have_file_size_hi</code>, <code>have_class_flags_hi</code>, <code>have_field_flags_hi</code>, <code>have_method_flags_hi</code>, <code>have_code_flags_hi</code>, respectively) is set, the corresponding band <code>file_modtime</code> (or <code>file_options</code>, <code>file_size_hi</code>, <code>class_flags_hi</code>, <code>field_flags_hi</code>, <code>method_flags_hi</code>, <code>code_flags_hi</code>, respectively) may be non-empty, as specified below. Otherwise that band will have zero elements. Other bits in the archive options must be zero and are reserved for future use.</p>
<p>Immediately after the <code>#archive_options</code> word is a pair of 32-bit numbers which together form a 64-bit length that helps decompressors easily buffer incoming data up to the end of the archive segment without reading beyond the segment. The value <code>#archive_size</code> is the unsigned 64-bit value composed of the unsigned 32-bit words <code>#archive_size_lo</code> and <code>#archive_size_hi</code>, where the former value is the low-order 32-bit word and the latter value is the high-order 32-bit word. The value <code>#archive_size</code> is either zero or declares the number of bytes in the archive segment, starting immediately after <code>#archive_size_lo</code> and before <code>#archive_next_count</code> and ending with the last band, the <code>*file_bits</code> band. (That is, a non-zero size includes the size of <code>#archive_next_count</code>, <code>*file_bits</code>, and everything in between.) This value is redundant, but if non-zero must be correctly supplied by any compressor. If the archive segment is transmitted as part of a stream, and if other data (such as additional segments) follow the archive, the <code>#archive_size</code> value must not be zero. Although it may be completely ignored by the decompressor, this value may help some decompressors to buffer their inputs more efficiently.</p>
<p>Immediately after <code>#archive_size</code> is another value <code>#archive_next_count</code> which estimates the number of archive segments immediately following the current one. This number need not be correct, and may always be zero. It is intended to provide decompressors with a hint as to the amount of remaining decompression work to do. (Such hints are routinely displayed in progress bars.)</p>
<p>If the <code>#archive_modtime</code> value is non-zero, the decompressor is requested (but not required) to adjust the system-specific modification time for its output. For example, if the decompressor produces a JAR file, it may set the modification date of each JAR element, or of the JAR file itself, to that date, in the absence of any more specific directive, such a non-zero <code>file_modtime</code> value. The <code>#archive_modtime</code> value is interpreted as the number of seconds since the epoch used by <code>System.currentTimeMillis</code>, which is 1/1/1970, 00:00:00 GMT. However, the special value zero is reserved to indicate the absence of any modification time for the archive as a whole. A decompressor may supply an arbitrary value in place of a missing archive modification time. If this is done, and if <code>file_modtime</code> values are present, those values are interpreted relative to modification time supplied for <code>#archive_modtime</code> by the compressor.</p>
<p>The <code>#file_count</code> value gives the number of files which are described in detail by the archive. Note that a class file which is simple enough (as described below) does not need to be described as a file, because it is enough that the class itself is transmitted. Therefore, <code>#file_count</code> may be less than the number of transmitted classes. (This latter number is called <code>#class_count</code>.) On the other hand, transmitted files do not need to contain classes, so that <code>#file_count</code> can also be greater than the number of classes.</p>
<h4 id="archive-entity-counts-and-class-format">5.2.2. Archive Entity Counts and Class Format</h4>
<p>The archive file contains up to sixteen sets of constants called &quot;constant pools&quot;. (These structures are analogous, but not identical, to a similarly named structure in class files.) These constant pools are described in detail in the next section.</p>
<p>The cardinality of each constant pool is given in UNSIGNED5 format in elements of the <code>cp_counts</code> structure of the archive header:</p>
<pre class="codeblock"><code>  cp_counts:
        #cp_Utf8_count :UNSIGNED5[1]
        (cp_number_counts) ** (#have_cp_numbers)
        #cp_String_count :UNSIGNED5[1]
        #cp_Class_count :UNSIGNED5[1]
        #cp_Signature_count :UNSIGNED5[1]
        #cp_Descr_count :UNSIGNED5[1]
        #cp_Field_count :UNSIGNED5[1]
        #cp_Method_count :UNSIGNED5[1]
        #cp_Imethod_count :UNSIGNED5[1]
        (cp_extra_counts) ** (#have_cp_extra_counts)

  cp_number_counts:
        #cp_Int_count :UNSIGNED5[1]
        #cp_Float_count :UNSIGNED5[1]
        #cp_Long_count :UNSIGNED5[1]
        #cp_Double_count :UNSIGNED5[1]

  cp_extra_counts:
        #cp_MethodHandle_count :UNSIGNED5[1]
        #cp_MethodType_count :UNSIGNED5[1]
        #cp_BootstrapMethod_count :UNSIGNED5[1]
        #cp_InvokeDynamic_count :UNSIGNED5[1]

  archive_special_counts:
        #band_headers_size :UNSIGNED5[1]
        #attr_definition_count :UNSIGNED5[1]

  class_counts:
        #ic_count :UNSIGNED5[1]
        #default_class_minver :UNSIGNED5[1]
        #default_class_majver :UNSIGNED5[1]
        #class_count :UNSIGNED5[1]</code></pre>
<p>The order in which these counts occur parallels the order in which the constant pools themselves are transmitted in the archive. This order is called the <em>definition order</em> of the constant pools.</p>
<p>The four numeric constant pools are sized by <code>cp_number_counts</code>. They specify numbers used occasionally by <code>ldc</code> bytecodes. Because a minority of classes actually use such bytecodes, the sizes are optional, under the control of <code>#have_cp_numbers</code>.</p>
<p>Likewise, the last four constant pools are sized by <code>cp_extra_counts</code>. They specify linkage information for the <code>invokedynamic</code> instruction, and certain types of constants (method handles and method types). As with the numeric entries, these sizes are optional, under the control of <code>#have_cp_extra_counts</code>.</p>
<p>Every class file has a header that includes magic number and a minor and major version numbers. The magic number (0xCAFEBABE), being a fixed constant, is not transmitted in the Pack200 archive. However, the version numbers, which can vary somewhat, must be recorded.</p>
<p>In the expectation that particular version numbers will be prevalent, the archive header transmits default major and minor version numbers. Both of these numbers are given in UNSIGNED5 format.</p>
<p>Individual classes in the archive (as described in the section <a href="#attribute-bands">Attribute Bands</a>) may optionally specify their own version numbers in a pseudo-attribute which overrides the <code>#default_class_minver</code> and <code>#default_class_majver</code> given in the archive header.</p>
<p>The count <code>#band_headers_size</code> gives the size in bytes of <code>band_headers</code>. The format of these bytes, which help define band coding specifiers for secondary codings, will be discussed much later, in the section <a href="#meta-coding">Meta-Coding</a>.</p>
<p>The archive header also specifies the number of attribute types (<code>#attr_definition_count</code>), class definitions (<code>#class_count</code>), nested class declarations (<code>#ic_count</code>). These numbers are used to size various other bands, as noted in the definition of those bands.</p>
<p>The arithmetic sum of all numbers in <code>cp_counts</code> must be less than the value <code>536870912</code> (<code>2^29</code>). A compressor is forbidden to transmit an archive for which the sum reaches or exceeds this limit. This constraint is intended to allow decompressors to use, internally, a unified numbering of constants, even if certain constants (such as demangled inner class names or implicit <code>SourceFile</code> names) must be added on the fly during decompression to the constant pool.</p>
<p>Note on implementation: The <code>archive_header</code> directly contains 3 numbers, while <code>cp_counts</code> contains at least 8 numbers and <code>class_counts</code> contains exactly 4. Therefore, the minimum size of the <code>archive_header</code> is 15 bytes, and this is always preceded by 4 bytes of <code>archive_magic</code>. A decompressor which wished to avoid any spurious read-ahead could read and buffer an initial block of 19 bytes, which would be certain to contain the <code>#archive_size</code> fields. (This assumes that the version numbers are small, as they are.) It could then immediately parse enough information to determine how many additional bytes of buffer storage would be required to scan the rest of the archive, at least up to the resource file images. By the time the resource file images in <code>*file_bits</code> must be parsed, the decompressor will have already read the <code>*file_size</code> bands, and will be able to remove any uncertainty originally present in <code>#archive_size</code>. (If the <code>#archive_size</code> fields are zero, the decompressor may be forced to read blindly up to the end of all data on the input channel in order to parse the archive.)</p>
<h4 id="constant-pools">5.3. Constant Pools</h4>
<p>The format defines sixteen independent constant pools, eleven of which correspond directly to the eleven basic types of constants found in Java class files. In the Pack200 archive format, they are organized in a fixed logical ordering called their <em>definition order</em>. This order determines their presentation in the archive's band structure, and also the construction of certain constant numberings.</p>
<p>The constant pools consolidate the information in the constant pools of all input class files. Each constant pool contains a single type of constant value. Each of the eleven constant pool types found in Java 6 class files is placed in its own constant pool. A twelfth pool holds <em>signatures</em>, which in class files are UTF8 strings that represent method and field types, but in Pack200 archives are a separately compressed data type.</p>
<p>Three more constant pools hold constants defined as part of the Java 7 classfile format (major version 51 or later). One more constant pool holds constants to be assembled into the <code>BootstrapMethods</code> attribute, which may be viewed as an appendix to the classfile constant pool.</p>
<p>The following table gives the sixteen predefined constant pools in their definition order. It also defines their correspondence with the constant types found in the Java class file format.</p>
<table>
<caption style="display:none">
Constant pools in definition order
</caption>
<tr>
<th id="definition_order_n">
Name
</th>
<th id="definition_order_e">
class file element
</th>
<th id="definition_order_t">
class file tag
</th>
<th id="definition_order_p">
Purpose
</th>
</tr>
<tr>
<td headers="definition_order_n">
cp_Utf8
</td>
<td headers="definition_order_e">
CONSTANT_Utf8_info
</td>
<td headers="definition_order_t">
CONSTANT_Utf8
</td>
<td headers="definition_order_p">
basic string data
</td>
</tr>
<tr>
<td headers="definition_order_n">
cp_Int
</td>
<td headers="definition_order_e">
CONSTANT_Integer_info
</td>
<td headers="definition_order_t">
CONSTANT_Integer
</td>
<td headers="definition_order_p">
int constant
</td>
</tr>
<tr>
<td headers="definition_order_n">
cp_Float
</td>
<td headers="definition_order_e">
CONSTANT_Float_info
</td>
<td headers="definition_order_t">
CONSTANT_Float
</td>
<td headers="definition_order_p">
float constant
</td>
</tr>
<tr>
<td headers="definition_order_n">
cp_Long
</td>
<td headers="definition_order_e">
CONSTANT_Long_info
</td>
<td headers="definition_order_t">
CONSTANT_Long
</td>
<td headers="definition_order_p">
long constant
</td>
</tr>
<tr>
<td headers="definition_order_n">
cp_Double
</td>
<td headers="definition_order_e">
CONSTANT_Double_info
</td>
<td headers="definition_order_t">
CONSTANT_Double
</td>
<td headers="definition_order_p">
double constant
</td>
</tr>
<tr>
<td headers="definition_order_n">
cp_String
</td>
<td headers="definition_order_e">
CONSTANT_String_info
</td>
<td headers="definition_order_t">
CONSTANT_String
</td>
<td headers="definition_order_p">
String constant
</td>
</tr>
<tr>
<td headers="definition_order_n">
cp_Class
</td>
<td headers="definition_order_e">
CONSTANT_Class_info
</td>
<td headers="definition_order_t">
CONSTANT_Class
</td>
<td headers="definition_order_p">
class reference
</td>
</tr>
<tr>
<td headers="definition_order_n">
cp_Signature
</td>
<td headers="definition_order_e">
(see below)
</td>
<td headers="definition_order_t">
(none)
</td>
<td headers="definition_order_p">
method, field, or variable type
</td>
</tr>
<tr>
<td headers="definition_order_n">
cp_Descr
</td>
<td headers="definition_order_e">
CONSTANT_NameAndType_info
</td>
<td headers="definition_order_t">
CONSTANT_NameAndType
</td>
<td headers="definition_order_p">
pair of (name, type)
</td>
</tr>
<tr>
<td headers="definition_order_n">
cp_Field
</td>
<td headers="definition_order_e">
CONSTANT_Fieldref_info
</td>
<td headers="definition_order_t">
CONSTANT_Fieldref
</td>
<td headers="definition_order_p">
field reference
</td>
</tr>
<tr>
<td headers="definition_order_n">
cp_Method
</td>
<td headers="definition_order_e">
CONSTANT_Methodref_info
</td>
<td headers="definition_order_t">
CONSTANT_Methodref
</td>
<td headers="definition_order_p">
method call
</td>
</tr>
<tr>
<td headers="definition_order_n">
cp_Imethod
</td>
<td headers="definition_order_e">
CONSTANT_InterfaceMethodref_info
</td>
<td headers="definition_order_t">
CONSTANT_InterfaceMethodref
</td>
<td headers="definition_order_p">
interface call
</td>
</tr>
<tr>
<td headers="definition_order_n">
cp_MethodHandle
</td>
<td headers="definition_order_e">
CONSTANT_MethodHandle_info
</td>
<td headers="definition_order_t">
CONSTANT_MethodHandle
</td>
<td headers="definition_order_p">
method handle constant
</td>
</tr>
<tr>
<td headers="definition_order_n">
cp_MethodType
</td>
<td headers="definition_order_e">
CONSTANT_MethodType_info
</td>
<td headers="definition_order_t">
CONSTANT_MethodType
</td>
<td headers="definition_order_p">
method type constant
</td>
</tr>
<tr>
<td headers="definition_order_n">
cp_BootstrapMethod
</td>
<td headers="definition_order_e">
BootstrapMethods_attribute.bootstrap_methods[i]
</td>
<td headers="definition_order_t">
(none; side table to constant pool)
</td>
<td headers="definition_order_p">
bootstrap method specifier
</td>
</tr>
<tr>
<td headers="definition_order_n">
cp_InvokeDynamic
</td>
<td headers="definition_order_e">
CONSTANT_InvokeDynamic_info
</td>
<td headers="definition_order_t">
CONSTANT_InvokeDynamic
</td>
<td headers="definition_order_p">
invokedynamic call
</td>
</tr>
</table>
<p>(Note that the definition order for these constant pools is similar to the numeric ordering of the corresponding class file tag. For example, CONSTANT_Utf8 is the first tag, and cp_Utf8 is the first constant pool in the definition order. However, there are differences in detail. In particular, note that cp_String comes before cp_Class, even though the corresponding class file tags are in the reverse order.)</p>
<p>Each constant pool is logically a set of symbolic or numeric values, all of one type. In the Pack200 archive, it is structured as a sequence of such values, each with a unique index within the sequence. Elsewhere in the archive, whenever a constant must be mentioned, its index within the appropriate constant pool (or within a subset of a pool, or within a group of pools) is given.</p>
<p>Unlike the class file format, constant pool indexing in the Pack200 archive format starts at zero. In the rare places where null references are expected, the possibility is documented, and the null references themselves are encoded by a zero index, while all other index values are incremented by one. Where null references are not expected, they may still be encoded by the 32-bit index value -1.</p>
<p>Also unlike class files, there are no &quot;gaps&quot; or unused indexes associated with long or double values. Occasionally, we will refer formally to an element of a constant pool by using array notation. For example, the first three integers in the <code>cp_Int</code> constant pool are <code>cp_Int[0]</code>, <code>cp_Int[1]</code>, and <code>cp_Int[2]</code>, and the last integer is <code>cp_Int[cp_Int_count-1]</code>. Note that both bands and constant pools are treated in this specification as arrays with zero origin.</p>
<p>It is illegal for a compressor to transmit the same constant twice. That is, all constant pool entries must be unique.</p>
<p>In a class file, with a few exceptions, constant pool references are strongly typed, in that every reference either is null or refers to a constant pool entry of a fixed tag associated with the context of the reference. The exceptions are <code>ConstantValue</code> attributes and operand fields of the <code>ldc</code>, <code>ldc_w</code>, and <code>ldc2_w</code> instructions.</p>
<p>However, because constant pools in a Pack200 archive are separately indexed, all constant references must be strongly typed, so that there is only one constant pool (or subset of a pool) into which any given index applies. This is accomplished either by deducing the constant type from context (in the case of <code>ConstantValue</code> attributes) or adding extra information to the context of the reference. (Within the bytecode stream, <code>ldc</code> is split out by constant type into distinct instructions <code>sldc</code>, <code>ildc</code>, etc.)</p>
<p>The layout of constant pool bands in the archive follows the definition order of the constant pools themselves. Each constant pool is represented in its turn by a sequence of one or more bands. The sequence of constant pool bands is therefore structured as follows:</p>
<pre class="codeblock"><code>  cp_bands:
        cp_Utf8
        *cp_Int :UDELTA5 [#cp_Int_count]
        *cp_Float :UDELTA5 [#cp_Float_count]
        cp_Long
        cp_Double
        *cp_String :UDELTA5 [#cp_String_count] (cp_Utf8)
        *cp_Class :UDELTA5 [#cp_Class_count] (cp_Utf8)
        cp_Signature
        cp_Descr
        cp_Field
        cp_Method
        cp_Imethod
        cp_MethodHandle
        *cp_MethodType :UDELTA5 [#cp_MethodType_count] (cp_Signature)
        cp_BootstrapMethod
        cp_InvokeDynamic</code></pre>
<p>As can be seen here, constant pools whose entries can be derived from a single 32-bit integer or a single reference are represented as single bands. The other constant pools are represented as groups of bands. Each constant pool gives its name to a corresponding grammar element. The production of <code>cp_bands</code> declares the order of each band or group of bands that transmits the constants in the eponymous constant pool.</p>
<p>Note the use of UDELTA5 as primary encodings for several bands. Although the Pack200 file format does not require any particular ordering of values in constant pools, it is generally advantageous to order them so that the encoded values in bands using UDELTA5 are monotonically increasing. (Negative deltas can be encoded, although expensively, by UDELTA5. Also, a signed secondary encoding may be chosen by the compressor instead of UDELTA5.) The choice of primary encodings in this specification reflects an expectation that high-quality compressors, when presented with a choice of output orderings, will make choices that result in good use of primary band encodings.</p>
<p>In a few cases, several of the sixteen constant pools are combined into a group, so that indexes can be formed to refer to elements of the group as a whole. Such a group is completely defined by its constituent constant pools. An index into a constant pool group is always formed consistently with the overall order of the constituent constant pools, as well as with the internal order of each pool. For example, if a group <code>cp_ABC</code> is formed of three pools <code>cp_A</code>, <code>cp_B</code>, and <code>cp_C</code> of sizes <code>COUNT(cp_A)</code>, <code>COUNT(cp_B)</code>, and <code>COUNT(cp_C)</code>, respectively, then a group index selects from one of the three pools depending on whether it is in the range <code>0 .. COUNT(cp_A)-1</code>, <code>COUNT(cp_A) .. COUNT(cp_A)+COUNT(cp_B)-1</code>, or <code>COUNT(cp_A)+COUNT(cp_B) .. COUNT(cp_ABC)-1</code>, respectively. The size of the pool group is of course the sum of the constituent pools.</p>
<p>In some other cases, subsets of constant pools are indexed in an abbreviated fashion. An index into a constant pool subset is always formed consistently with the order of the pool itself. For example, the index <code>0</code> always refers to the first element of the subset, the index <code>1</code> refers to the second, and so on.</p>
<p>Here are definitions of the pool groups used in this specification.</p>
<table>
<caption style="display:none">
Constant pool groups
</caption>
<tr>
<th id="cp_groups_n">
Name
</th>
<th id="cp_groups_c">
Constituents
</th>
<th id="cp_groups_p">
Purpose
</th>
</tr>
<tr>
<td headers="cp_groups_n">
cp_All
</td>
<td headers="cp_groups_c">
(all sixteen pools)
</td>
<td headers="cp_groups_p">
generic references
</td>
</tr>
<tr>
<td headers="cp_groups_n">
cp_LoadableValue
</td>
<td headers="cp_groups_c">
cp_Int, cp_Float, cp_Long, cp_Double, cp_String, cp_Class, cp_MethodHandle, cp_MethodType
</td>
<td headers="cp_groups_p">
<code>qldc</code> operand, bootstrap method argument
</td>
</tr>
<tr>
<td headers="cp_groups_n">
cp_AnyMember
</td>
<td headers="cp_groups_c">
cp_Field, cp_Method, cp_Imethod
</td>
<td headers="cp_groups_p">
<code>get</code> or <code>invoke</code> operand, method handle component
</td>
</tr>
</table>
<p>The group <code>cp_All</code> comprises the sequence of all constants, in their natural order of occurrence within the Pack200 archive. Thus, an index into <code>cp_All</code> is in effect an untyped reference to any constant.</p>
<h5 id="scalar-constants">5.3.1. Scalar Constants</h5>
<p>The encoding of the <code>cp_Utf8</code> constant pool will be described shortly. First we will describe the coding of the numeric, string, and class constant pools.</p>
<p>The values in the <code>cp_Int</code> constant pool are directly represented by the values encoded in its band. The values in the <code>cp_Float</code> constant pool are obtained as if by applying <code>java.lang.Float.intBitsToFloat</code> to the 32-bit values encoded in its band.</p>
<p>The 64-bit values of the <code>cp_Long</code> band are obtained by adjoining, as high and low words, corresponding 32-bit values from the two bands <code>cp_Long_hi</code> and <code>cp_Long_lo</code>. (They contain the high and low words, respectively.) Likewise, the values of the <code>cp_Double</code> band are obtained by first adjoining high and low words from two other bands, and then retyping the resulting 64-bit integers as if by applying <code>java.lang.Double.longBitsToDouble</code>. The high and low words are in the bands <code>cp_Double_hi</code> and <code>cp_Double_lo</code>, respectively.</p>
<pre class="codeblock"><code>  cp_Long:
        *cp_Long_hi :UDELTA5 [#cp_Long_count]
        *cp_Long_lo :DELTA5 [#cp_Long_count]

  cp_Double:
        *cp_Double_hi :UDELTA5 [#cp_Double_count]
        *cp_Double_lo :DELTA5 [#cp_Double_count]
</code></pre>
<p>When floating point values are eventually written to class files, their bits must be accurately stored, as if they were processed by <code>java.lang.Float.floatToRawIntBits</code> or <code>java.lang.Double.doubleToRawLongBits</code>. In this way &quot;NaN&quot; values are transmitted faithfully, without normalization.</p>
<p>(Note: Although it would be possible to extend the band-coding techniques of Pack200 to encode 64-bit values directly, this file format always transmits 64-bit values as pairs of 32-bit values, transmitted in pairs of bands. This simplifies implementations, allowing them to process band data with 32-bit data paths.)</p>
<p>Each string in a <code>cp_String</code> constant pool is represented in its band by a reference to the string's spelling, as a <code>cp_Utf8</code> constant.</p>
<p>Likewise, each class in a <code>cp_Class</code> constant pool is represented in its band by a reference to the class's spelling, as a <code>cp_Utf8</code> constant. (As in the class file and the VM, the spelling uses the slash character to delimit package prefix components.)</p>
<h5 id="utf8-constants">5.3.2. Utf8 Constants</h5>
<p>Each value in the <code>cp_Utf8</code> constant pool is an array of zero or more 16-bit Java characters. (The name &quot;Utf8&quot; is an anachronism, referring only to the basic character string type in Java class files. No part of the Pack200 file format uses any UTF encoding, but the term &quot;Utf8&quot; is retained to emphasize the connection with class files.) As in the class file format, all character string data is transmitted in this one kind of constant pool entry. When the context is clear enough, we loosely refer to these arrays as &quot;strings&quot;, even though they are distinct from the Java constants in the cp_String constant pool.</p>
<p>If <code>cp_Utf8</code> is not empty, its first value is always the empty string. Thus, the empty string is always given an index of zero. No band values are transmitted to represent this empty string. (Values in the bands <code>cp_Utf8_prefix</code> and <code>cp_Utf8_suffix</code> pertain to strings after the empty string in <code>cp_Utf8</code>.) Because constants cannot be duplicated, all other elements of <code>cp_Utf8</code> contain at least one character.</p>
<p>Each string in the <code>cp_Utf8</code> constant pool is represented in the archive file in two parts, a prefix and a suffix. The suffix is represented both by a count and a sequence of character codes. The prefix is represented only by a count; the characters of the prefix are duplicated from the previous string. This technique allows the compressor (if it chooses) to represent strings by means of their successive differences. The first suffix value and the first two prefix values are suppressed in the transmitted archive. The values, if transmitted, would always be zero, since the first <code>cp_Utf8</code> string is always empty, and the second string can never share a non-empty prefix with the first string.</p>
<p>Each suffix is transmitted in exactly one of two ways, as a <em>small suffix</em> or a <em>big suffix</em>. Small suffixes are transmitted contiguously in one large band. Big suffixes are rare; they are intended as a way to compactly transmit strings with unusual statistics, such as strings which are really tables of numeric data. Each big suffix is transmitted in its own band. This allows the compressor the option to choose an efficiently customized secondary coding for the characters in each large, unusual string.</p>
<p><a id="band_replicated"></a></p>
<pre class="codeblock"><code>  cp_Utf8:
        *cp_Utf8_prefix :DELTA5      [MAX(0,#cp_Utf8_count-2)]
        *cp_Utf8_suffix :UNSIGNED5   [MAX(0,#cp_Utf8_count-1)]
        *cp_Utf8_chars :CHAR3        [SUM( *cp_Utf8_suffix )]
        *cp_Utf8_big_suffix :DELTA5  [COUNT(0, *cp_Utf8_suffix )]
        (*cp_Utf8_big_chars :DELTA5)
          ** length(cp_Utf8_big_suffix)  [SUM( *cp_Utf8_big_suffix )]
</code></pre>
<p>(Note: It is helpful, but not required by this specification, to order the strings lexicographically and find maximal common prefixes between adjacent strings. It is permissible to ignore the prefix sharing feature and declare all prefixes to be zero.)</p>
<p>The band <code>cp_Utf8_suffix</code> contains one less than <code>#cp_Utf8_count</code> elements. It specifies, in order, the small suffix length of each constant pool string (except the implicit first string, which is empty). The band <code>cp_Utf8_prefix</code> contains two less than <code>#cp_Utf8_count</code> elements. It specifies, in order, the prefix length of each constant pool string (except the first two strings, which always have zero prefix lengths). The prefix length encodes the length of a prefix substring shared by both <code>cp_Utf8[i-1]</code> and <code>cp_Utf8[i]</code>. If there are fewer than three strings in <code>cp_Utf8</code>, then <code>cp_Utf8_prefix</code> is empty. The prefix length is typically a large proportion (sometimes half) of the total length.</p>
<p>Each value in the band <code>cp_Utf8_chars</code> is a 16-bit number expressing a Java character. This band contains the characters of all small suffixes, in order. For each successive string, <code>cp_Utf8_chars</code> contains an additional run of values encoding the characters of its small suffix, if any. Therefore, the total length of this band is the sum of all values in the <code>cp_Utf8_suffix</code> band.</p>
<p><a id="big_string"></a></p>
<p>Whenever a small suffix length for a constant pool entry is zero, the string has no small suffix, but a big suffix instead. The length of each big suffix is given by an element of the <code>cp_Utf8_big_suffix</code> band. (Therefore, the length of this band is precisely the count of zero values in the <code>cp_Utf8_suffix</code> band.) Each big suffix is transmitted as a separate band of 16-bit character values, one band element per character. There is one such band per big suffix. These bands immediately follow the <code>cp_Utf8_big_suffix</code> band, and are collectively called the <code>cp_Utf8_big_chars</code> bands. Although normally data of the same type are collected into a single band, these strings are placed in separate bands so that they may be independently encoded. These strings typically encode arrays of binary data, rather than true Java characters.</p>
<p>A big suffix can have a length of zero, which means that the constant pool entry is a non-empty prefix of the previous string. In such a case, the corresponding suffix band will occupy no space in the archive file, since bands of zero length occupy no bytes at all.</p>
<p>Please see the Appendix section <a href="#representation-of-cp_utf8-constant-pool">Representation of <code>cp_Utf8</code> Constant Pool</a> for pseudo-code explaining this concept.</p>
<h5 id="type-signatures">5.3.3. Type Signatures</h5>
<p>Each <code>cp_Signature</code> constant pool entry represents a type string, exactly as field and method types are declared in the class file format. Although the class file format uses simple <code>Utf8</code> constant pool entries for such strings, the Pack200 file format allocates a separate constant pool for them, in order to use more compact representation than for general strings.</p>
<p>Signature constants are special in that they can contain embedded references to <code>cp_Class</code> constants. The signature constant is equivalent to a Utf8 constant, once the embedded class references are expanded into their spellings. Signature constants are flexible enough to represent arbitrary strings, but are intended for strings that often contain class names following the capital letter ell <code>'L'</code>. These include field, method, and local variables types, and generic <code>Signature</code> attributes.</p>
<p>Each signature string is decomposed into a <em>form</em> and a sequence of zero or more class references. The class references are obtained by locating in the original signature string all sequences that match the pattern &quot;<code>L</code><em>classname</em>&quot;, removing the <em>classname</em> part, and treating it as a reference into the <code>cp_Class</code> constant pool. The form is defined as the residue after the class names have been removed from the original string.</p>
<p>The form is not allowed to contain any occurrences of the letter ell ('<code>L</code>'), other than those which mark removed class names.</p>
<p>Thus, the form will contain the character '<code>L</code>' wherever the original type string refers to a class. By counting the number of these characters in a form, the decompressor may deduce the number of classes to which the original type string refers. This number is called the <em>class length</em> of the form.</p>
<p>Note that <code>cp_Class</code> constants are not required to refer to existing classes, nor are they even required to have valid class name spellings. Therefore, the compressor has considerable latitude in choosing which class names (if any) it will extract from signature strings. In an extreme case, the compressor can make each form identical to its corresponding signature string, and simply satisfy its class length by emitting references to a fictitious class with an empty name. (This class length would have to include any occurrences of <code>'L'</code> in the class names themselves.)</p>
<p>Note also that these encoding rules do not require a class name to be followed by any particular character, although it will generally be a semicolon, or perhaps a left-angle bracket, in the case of an instance of a generic type in a <code>Signature</code> attribute.</p>
<p>The rules also allow the compressor to decide, arbitrarily, how many characters (if any) after each letter ell <code>'L'</code> will be transmitted as part of a class name. Therefore, a given signature string may be representable by several forms, any of which the decompressor must be prepared to process.</p>
<p>Here are some examples:</p>
<table>
<caption style="display:none">
sample decompressions
</caption>
<tr style="text-align:center">
<th id="sample_decompressions_t">
Type Signature String
</th>
<th id="sample_decompressions_f">
Form
</th>
<th id="sample_decompressions_c">
Class<br /> Len.
</th>
<th id="sample_decompressions_c2">
Class...
</th>
</tr>
<tr>
<td headers="sample_decompressions_t">
<code>F</code>
</td>
<td headers="sample_decompressions_f">
<code>F</code>
</td>
<td headers="sample_decompressions_c">
0
</td>
<td headers="sample_decompressions_c2">
 
</td>
</tr>
<tr>
<td headers="sample_decompressions_t">
<code>[Z</code>
</td>
<td headers="sample_decompressions_f">
<code>[Z</code>
</td>
<td headers="sample_decompressions_c">
0
</td>
<td headers="sample_decompressions_c2">
 
</td>
</tr>
<tr>
<td headers="sample_decompressions_t">
<code>[[[LLL;</code>
</td>
<td headers="sample_decompressions_f">
<code>[[[L;</code>
</td>
<td headers="sample_decompressions_c">
1
</td>
<td headers="sample_decompressions_c2">
<code>LL</code>
</td>
</tr>
<tr>
<td headers="sample_decompressions_t">
<code>[[[LLL;</code>
</td>
<td headers="sample_decompressions_f">
<code>[[[LLL;</code>
</td>
<td headers="sample_decompressions_c">
3
</td>
<td headers="sample_decompressions_c2">
<code>(empty), (empty), (empty)</code>
</td>
</tr>
<tr>
<td headers="sample_decompressions_t">
<code>([Ljava/lang/String;)V</code>
</td>
<td headers="sample_decompressions_f">
<code>([L;)V</code>
</td>
<td headers="sample_decompressions_c">
1
</td>
<td headers="sample_decompressions_c2">
<code>java/lang/String</code>
</td>
</tr>
<tr>
<td headers="sample_decompressions_t">
<code>Ljava/util/List&amp;lt;Lpkg/Item;&amp;gt;;</code>
</td>
<td headers="sample_decompressions_f">
<code>L&amp;lt;L;&amp;gt;;</code>
</td>
<td headers="sample_decompressions_c">
2
</td>
<td headers="sample_decompressions_c2">
<code>java/util/List, pkg/Item</code>
</td>
</tr>
<tr>
<td headers="sample_decompressions_t">
<code>(Ljava/lang/String;II)Lpkg/Item;</code>
</td>
<td headers="sample_decompressions_f">
<code>(L;II)L;</code>
</td>
<td headers="sample_decompressions_c">
2
</td>
<td headers="sample_decompressions_c2">
<code>java/lang/String, pkg/Item</code>
</td>
</tr>
<tr>
<td headers="sample_decompressions_t">
<code>Ljava/util/List&amp;lt;Ljava/lang/Byte;&amp;gt;;</code>
</td>
<td headers="sample_decompressions_f">
<code>L&amp;lt;L;&amp;gt;;</code>
</td>
<td headers="sample_decompressions_c">
2
</td>
<td headers="sample_decompressions_c2">
<code>java/util/List, java/lang/Byte</code>
</td>
</tr>
<tr>
<td headers="sample_decompressions_t">
<code>&amp;lt;ELEM:&amp;gt;(Ljava/util/List&amp;lt;TELEM;&amp;gt;;)TELEM;</code>
</td>
<td headers="sample_decompressions_f">
<code>&amp;lt;EL:&amp;gt;(L&amp;lt;TEL;&amp;gt;;)TEL;</code>
</td>
<td headers="sample_decompressions_c">
1
</td>
<td headers="sample_decompressions_c2">
<code>EM, java/util/List, EM, EM</code>
</td>
</tr>
<tr>
<td headers="sample_decompressions_t">
<code>ALLOWABLE</code>
</td>
<td headers="sample_decompressions_f">
<code>ALLOWABLE</code>
</td>
<td headers="sample_decompressions_c">
3
</td>
<td headers="sample_decompressions_c2">
<code>(empty), (empty), (empty)</code>
</td>
</tr>
<tr>
<td headers="sample_decompressions_t">
<code>ALLOWABLE</code>
</td>
<td headers="sample_decompressions_f">
<code>AL</code>
</td>
<td headers="sample_decompressions_c">
1
</td>
<td headers="sample_decompressions_c2">
<code>LOWABLE</code>
</td>
</tr>
<tr>
<td headers="sample_decompressions_t">
<code>ALLOWABLE</code>
</td>
<td headers="sample_decompressions_f">
<code>ALABL</code>
</td>
<td headers="sample_decompressions_c">
2
</td>
<td headers="sample_decompressions_c2">
<code>LOW, E</code>
</td>
</tr>
</table>
<p>The forms of all strings in the <code>cp_Signature</code> constant pool are given in order in the <code>cp_Signature_form</code> band, as one <code>cp_Utf8</code> reference per signature string. For each form, the class-length sequence of classes required to reconstitute the signature string is transmitted as a run of <code>cp_Class</code> references in the <code>cp_Signature_classes</code> band. As a consequence of these definitions, the length of the <code>cp_Signature_classes</code> band is the total number of letter ell <code>'L'</code> occurrences in the sequence of spellings of forms mentioned in <code>cp_Signature_form</code>.</p>
<pre class="codeblock"><code>  cp_Signature:
        *cp_Signature_form :DELTA5 [#cp_Signature_count](cp_Utf8)
        *cp_Signature_classes :UDELTA5 [COUNT(&#39;L&#39;,...)] (cp_Class)
</code></pre>
<p>Please see the Appendix section for <a href="#representation-of-cp_signature-constant-pool">Representation of <code>cp_Signature</code> Constant Pool</a> pseudo-code explaining this concept.</p>
<h5 id="tuple-constants">5.3.4. Tuple Constants</h5>
<p>The next four constant pools contain ordered pairs of various kinds of values (types, names, strings, or classes). Each <code>cp_Descr</code> constant is an ordered pair of a name (represented as a <code>cp_Utf8</code> reference) and a type (represented as a <code>cp_Signature</code> reference). These references are transmitted in corresponding elements of the <code>cp_Descr_name</code> and <code>cp_Descr_type</code> bands.</p>
<p>Likewise, each <code>cp_Field</code>, <code>cp_Method</code>, or <code>cp_Imethod</code> constant is an ordered pair of a class (represented as a <code>cp_Class</code> reference) and a name-and-type descriptor (represented as a <code>cp_Descr</code> reference). Again, these references are transmitted in corresponding elements of the associated bands.</p>
<pre class="codeblock"><code>  cp_Descr:
        *cp_Descr_name :DELTA5 [#cp_Descr_count] (cp_Utf8)
        *cp_Descr_type :UDELTA5 [#cp_Descr_count] (cp_Signature)
  cp_Field:
        *cp_Field_class :DELTA5 [#cp_Field_count] (cp_Class)
        *cp_Field_desc :UDELTA5 [#cp_Field_count] (cp_Descr)
  cp_Method:
        *cp_Method_class :DELTA5 [#cp_Method_count] (cp_Class)
        *cp_Method_desc :UDELTA5 [#cp_Method_count] (cp_Descr)
  cp_Imethod:
        *cp_Imethod_class :DELTA5 [#cp_Imethod_count] (cp_Class)
        *cp_Imethod_desc :UDELTA5 [#cp_Imethod_count] (cp_Descr)
</code></pre>
<h5 id="extra-constants">5.3.5. Extra Constants</h5>
<p>For additional constant pools define symbolic references for <code>invokedynamic</code> instructions and related entities. (These constant pools are only non-empty if their corresponding counts are non-zero, which in turn can only be true if <code>cp_extra_counts</code> is present.) Each <code>cp_MethodHandle</code> is an ordered pair of a reference kind (a small integer) and a reference to an element of <code>cp_Field</code>, <code>cp_Method</code>, or <code>cp_Imethod</code>. (This reference is transmitted as an index into <code>cp_AnyMember</code>, which is defined above as a pool group containing those three pools.) Each <code>cp_MethodType</code> is represented as a <code>cp_Signature</code> reference. Each <code>cp_InvokeDynamic</code> is an ordered pair of a bootstrap method specifier (represented as a <code>cp_BootstrapMethod</code>) and a type (represented as a <code>cp_Signature</code> reference). Each <code>cp_BootstrapMethod</code> specifier is an ordered pair of a bootstrap method reference (represented as a <code>cp_MethodHandle</code>) and a counted series of zero or more constant pool references to constants which can be loaded onto the JVM stack. (These references are transmitted as indexes into the pool group <code>cp_LoadableValue</code>.) All these values and references are transmitted in associated bands as described below.</p>
<pre class="codeblock"><code>  cp_MethodHandle:
        *cp_MethodHandle_refkind :DELTA5 [#cp_MethodHandle_count]
        *cp_MethodHandle_member :UDELTA5 [#cp_MethodHandle_count] (cp_AnyMember)
  cp_BootstrapMethod:
        *cp_BootstrapMethod_ref :DELTA5 [#cp_BootstrapMethod_count] (cp_MethodHandle)
        *cp_BootstrapMethod_arg_count :UDELTA5 [#cp_BootstrapMethod_count]
        *cp_BootstrapMethod_arg :DELTA5 [SUM(*BootstrapMethod_arg_count)] (cp_LoadableValue)
  cp_InvokeDynamic:
        *cp_InvokeDynamic_spec :DELTA5 [#cp_InvokeDynamic_count] (cp_BootstrapMethod)
        *cp_InvokeDynamic_descr :UDELTA5 [#cp_InvokeDynamic_count] (cp_Descr)</code></pre>
<h4 id="file-attributes">5.4. File Attributes</h4>
<p>Since a JAR archive consists of a sequence of files, each with contents and a few other attributes, the Pack200 archive can also represent a sequence of files with their attributes. Of course, the contents of class files are specially transmitted, but whether a file (i.e., a JAR archive element) contains a class or another resource, the Pack200 archive is able to transmit the following attributes:</p>
<ul>
<li>name of file <em>(optional for classes)</em></li>
<li>contents of file <em>(optional for classes)</em></li>
<li>modification time of file <em>(optional)</em></li>
<li>deflation hint for file <em>(optional)</em></li>
<li>order of file in archive <em>(optional for classes)</em></li>
</ul>
<p>A class file whose contents are compressed by Pack200 is marked as a &quot;stub&quot; with a special option bit. A class stub file must be declared to have a length of zero. It may be declared to have the empty string for its name. If there are not enough class stub files transmitted to match with the number of classes transmitted, the decompressor must act as if the compressor had transmitted an additional series of trivial stubs, with no name or contents, and modification time and deflation hint copied from the archive header.</p>
<p>Each resource file is transmitted in the Pack200 archive as a simple bytewise image, under a relative pathname using slash '/' as a directory separator. (This is the same pathname convention as is used in ZIP archives.) Each file (both resource files and class files) can optionally be associated with a deflation hint and a modification date.</p>
<pre class="codeblock"><code>  file_bands:
        *file_name :UNSIGNED5 [#file_count] (cp_Utf8)
        *file_size_hi :UNSIGNED5 [#file_count*(#have_file_size_hi)]
        *file_size_lo :UNSIGNED5 [#file_count]
        *file_modtime :DELTA5 [#file_count*(#have_file_modtime)]
        *file_options :UNSIGNED5 [#file_count*(#have_file_options)]
        *file_bits :BYTE1 [SUM(*file_size)]
</code></pre>
<p>There are no additional file attributes, such as comments, extra attributes, or CRC values. An application which requires such attributes on some files may encode those files into an appropriate archive file format (such as ZIP), and transmit those archives as resource files in a Pack200 archive.</p>
<p>Each file name is transmitted as an element of the <code>file_name</code> band, and each length (in bytes) is transmitted in the corresponding elements of the <code>file_size_lo</code> band and (if present) the <code>file_size_hi</code> band. All three bands are of length <code>#file_count</code>, except that <code>file_size_hi</code> has zero elements if the <code>have_file_size_hi</code> bit in the <code>#archive_options</code> is clear.</p>
<p>The length in bytes of each file is the corresponding unsigned 32-bit value taken from the <code>file_size_lo</code> band, if the <code>file_size_hi</code> band is empty. Otherwise, the file length is the unsigned 64-bit value composed of the corresonding unsigned 32-bit elements of the <code>file_size_lo</code> and <code>file_size_hi</code> bands, where the former value is the low-order 32-bit word and the latter value is the high-order 32-bit word.</p>
<p>The bytes of all non-class (i.e., resource) files follow immediately in the <code>file_bits</code> band. Each file is given as a corresponding run of byte values.</p>
<p>The optional band <code>file_modtime</code>, if not empty, supplies a modification time for each resource file (and potentially for class files, if class file stubs are present). Each integer value gives a difference (in seconds) from the <code>#archive_modtime</code> value. (Therefore, if the <code>#archive_modtime</code> value is zero, the individual file times must be interpreted as absolute values.) The order of transmission of <code>file_modtime</code> is consistent with <code>file_name</code>. This band is empty if the <code>have_file_modtime</code> bit in the <code>#archive_options</code> is clear.</p>
<p>The optional band <code>file_options</code>, if not empty, supplies flag bits for each resource file (and potentially for class files, if class file stubs are present). This band is empty if the <code>have_file_options</code> bit in the <code>#archive_options</code> is clear. Each <code>file_options</code> word is interpreted bitwise. Certain bits are given symbolic names as follows, where the LSB is numbered as bit zero:</p>
<table>
<caption style="display:none">
description of file_options bits
</caption>
<tr>
<th id="file_options_b">
Bit
</th>
<th id="file_options_n">
Name
</th>
<th id="file_options_p">
Purpose
</th>
</tr>
<tr>
<td headers="file_options_b">
0
</td>
<td headers="file_options_n">
deflate_hint
</td>
<td headers="file_options_p">
request compressed JAR file element
</td>
</tr>
<tr>
<td headers="file_options_b">
1
</td>
<td headers="file_options_n">
is_class_stub
</td>
<td headers="file_options_p">
this file contains class bytecodes
</td>
</tr>
</table>
<p>If <code>deflate_hint</code> (the LSB) is set, the decompressor is requested (but not required) to reduce the size of its output. For example, if it produces a JAR file, it may deflate the JAR elements. Since the <code>deflate_hint</code> bit in the <code>#archive_options</code> word has the same effect, the two bits are in effect combined with a logical OR for each file. If <code>is_class_stub</code> (the second LSB) is set, this resource file description is actually a <em>stub</em>, and the file contents are defined as the bytecodes of one of the classes defined in the Pack200 archive. Other bits in the file options must be zero and are reserved for future use.</p>
<p>If a transmitted file is marked as a class stub, its contents must be transmitted as if the file were empty. (That is, <code>file_size_hi</code> and <code>file_size_lo</code> must both be zero, and there may not be any corresponding bytes in <code>file_bits</code>.) The decompressor is required to supply contents for the resource file by reconstituting the contents of a class file for a class transmitted in <code>class_this</code>, etc. Like any other resource file, the class stub is allowed to have a name, a modification time and a <code>deflate_hint</code>.</p>
<p>The class stubs and classes correspond in order. Define the derived parameter <code>#class_stub_count</code> as the number of files marked as class stubs. (It is also the count of <code>is_class_stub</code> bits set in <code>file_options</code>.) Then <code>#class_stub_count</code> must be no larger than <code>#class_count</code>. The first class stub defines a file which receives bytecodes for the first class, and so on. Although a class stub has a name (transmitted in <code>file_name</code>), this name may be the empty string. In this case, the decompressor is required to use the standard name for the class file, which is created from the class's bytecode name (using slash '/' for a package separator) by appending the string &quot;.class&quot;. (Thus, a classfile can have an arbitrary non-standard name, but the compression works best if its name is derived from its class in the usual way.)</p>
<p>If <code>#class_count</code> is larger than <code>#class_stub_count</code>, then the decompressor must behave as if a sufficient number of trivial extra class stubs were transmitted after the last explicit file. These trivial stubs have an empty name string and a zero <code>deflate_hint</code> or <code>file_modtime</code>.</p>
<p>Thus, in the simple case where there are no class stubs at all (perhaps because <code>have_file_options</code> is zero), the decompressor must produce its files in their transmission order, followed by the transmission order of the classes. Each class file must have its standard name, and a modification time and deflation hint inherited from <code>#archive_modtime</code> and the <code>deflate_hint</code> bit in <code>#archive_options</code>. But at the cost of extra transmission size, the compressor can direct the decompressor to present the resources and class files in any fixed order, with arbitrary names, modification times, and deflation hints for each output file. The decompressor must honor this ordering, if its output is in a form (such as a JAR archive) where order is significant.</p>
<p>Compressors are free, unless otherwise directed, to choose any ordering of files. It is often advantageous to place files with similar statistics next to each other, so that the post-pass compressor (if any) may process their contents together (in the same window, in the case of the DEFLATE algorithm). It is likely that a compressor which is able to reorder its input files for efficient transmission will have a command option which forces it to retain the order in which input files were presented, because this order is significant to some (but not all) deployment applications.</p>
<p>Compressors are free to transmit class files as if they were resource files. This provides a way to transmit class files which must be preserved bit-for-bit, or which compressors cannot transmit compressed with sufficient accuracy. Decompressors are required to accept class files transmitted &quot;bitwise&quot; as resource files.</p>
<p>Note: The bands controlling files and their attributes are transmitted last in the archive, in order to ease decompressor implementation slightly, since the last thing a decompressor does is to assemble output files. In particular, resource files can be of arbitrary size, and placing their bits at the end of the archive allows the decompressor to avoid allocating temporary storage for them.</p>
<h4 id="flags-and-attributes">5.5. Flags and Attributes</h4>
<p>The Pack200 file format directly supports up to 16 modifier bits in all output flags fields, as defined by the class file format. It also directly supports certain predefined attributes, such as <code>Code</code>, <code>InnerClasses</code>, and <code>ConstantValue</code> It is also possible for the compressor to define additional attributes, passing enough information to the decompressor to properly extract their data from bands and reconstitute them in class files. The presence or absence of all attributes is controlled by the setting of certain bits in flag bands.</p>
<p>Five sets of <em>flag bands</em> carry modifier bits and/or attribute control bits. The <code>ic_flags</code> band carries modifier bits for nested classes. Also, modifier and attribute control bits are carried by <code>class_flags_lo</code>, <code>field_flags_lo</code>, <code>method_flags_lo</code>, and <code>code_flags_lo</code>, and the four corresponding optional high word bands, <code>class_flags_hi</code>, <code>field_flags_hi</code>, <code>method_flags_hi</code>, and <code>code_flags_hi</code>. (There is no high word for <code>ic_flags</code>.) Each value in these bands is interpreted as an unsigned 32-bit binary number. Each bit in these bands independently specifies the presence of a Java access modifier (such as <code>ACC_PRIVATE</code>), or of a class, field, method, or code attribute (such as <code>Deprecated</code> or <code>SourceFile</code>), or of some other necessary control information (such as whether a class file has a non-default version number).</p>
<p>Every class (resp. field, method, <code>Code</code> attribute) has a corresponding flags value of up to 63 bits transmitted in <code>class_flags_lo</code> (resp., <code>field_flags_lo</code>, <code>method_flags_lo</code>, <code>code_flags_lo</code>) and optionally in <code>class_flags_hi</code> (resp., <code>field_flags_hi</code>, <code>method_flags_hi</code>, <code>code_flags_hi</code>). These flags values, assembled into 64-bit numbers, are named <code>class_flags</code> (resp., <code>field_flags</code>, <code>method_flags</code>, <code>code_flags</code>). Except for <code>Code</code> attributes, each of the low sixteen flag bits may be used to transmit access flags. The high sixteen bits (or forty-seven, if the optional high word is transmitted) are used to indicate the presence of attributes, either predefined or compressor-defined. The sixty-fourth bit position of a flags value (if transmitted) is reserved and must be zero.</p>
<p>The flags value for a <code>Code</code> attribute is optional and taken to be zero if missing. A <code>Code</code> attribute has a corresponding flags value transmitted if and only if either the <code>have_all_code_flags</code> bit in the <code>#archive_options</code> is set, or else the element of <code>code_headers</code> corresponding to the <code>Code</code> attribute has the special value zero. (See the discussion of code headers in the section <a href="#code_headers">Class Schema</a>.)</p>
<p>For classes, nested classes, fields, and methods, the assignment of flag bit positions to modifiers is the same as that in the class file format. (For example, the LSB always represents <code>ACC_PUBLIC</code>, in both Pack200 archive and class file formats.) An <em>overflow attribute</em> is an attribute whose presence is not indicated directly via a flag bit, and but is instead indicated by a occurrence of its index in a separate band. For classes, fields, methods, and codes, bit 16 (as set in the mask 0x0001000) indicates the presence of overflow attributes. For nested classes, flag bit 16 indicates the presence of explicit outer class and name fields, as explained in the section <a href="#explicit_outer">Nested Classes</a>.</p>
<table>
<caption style="display:none">
Listing of flag bits
</caption>
<tr style="text-align:center">
<th id="flag_bits_b">
Bit
</th>
<th id="flag_bits_m">
Meaning
</th>
</tr>
<tr>
<td headers="flag_bits_b" style="text-align:right">
0
</td>
<td headers="flag_bits_m">
ACC_PUBLIC
</td>
</tr>
<tr>
<td headers="flag_bits_b" style="text-align:right">
1
</td>
<td headers="flag_bits_m">
ACC_PRIVATE
</td>
</tr>
<tr>
<td headers="flag_bits_b" style="text-align:right">
2
</td>
<td headers="flag_bits_m">
ACC_PROTECTED
</td>
</tr>
<tr>
<td headers="flag_bits_b" style="text-align:right">
3
</td>
<td headers="flag_bits_m">
ACC_STATIC
</td>
</tr>
<tr>
<td headers="flag_bits_b" style="text-align:right">
4
</td>
<td headers="flag_bits_m">
ACC_FINAL
</td>
</tr>
<tr>
<td headers="flag_bits_b" style="text-align:right">
5
</td>
<td headers="flag_bits_m">
ACC_SYNCHRONIZED (ACC_SUPER)
</td>
</tr>
<tr>
<td headers="flag_bits_b" style="text-align:right">
6
</td>
<td headers="flag_bits_m">
ACC_VOLATILE (ACC_BRIDGE*)
</td>
</tr>
<tr>
<td headers="flag_bits_b" style="text-align:right">
7
</td>
<td headers="flag_bits_m">
ACC_TRANSIENT (ACC_VARARGS*)
</td>
</tr>
<tr>
<td headers="flag_bits_b" style="text-align:right">
8
</td>
<td headers="flag_bits_m">
ACC_NATIVE
</td>
</tr>
<tr>
<td headers="flag_bits_b" style="text-align:right">
9
</td>
<td headers="flag_bits_m">
ACC_INTERFACE
</td>
</tr>
<tr>
<td headers="flag_bits_b" style="text-align:right">
10
</td>
<td headers="flag_bits_m">
ACC_ABSTRACT
</td>
</tr>
<tr>
<td headers="flag_bits_b" style="text-align:right">
11
</td>
<td headers="flag_bits_m">
ACC_STRICT
</td>
</tr>
<tr>
<td headers="flag_bits_b" style="text-align:right">
12
</td>
<td headers="flag_bits_m">
ACC_SYNTHETIC
</td>
</tr>
<tr>
<td headers="flag_bits_b" style="text-align:right">
13
</td>
<td headers="flag_bits_m">
ACC_ANNOTATION
</td>
</tr>
<tr>
<td headers="flag_bits_b" style="text-align:right">
14
</td>
<td headers="flag_bits_m">
ACC_ENUM
</td>
</tr>
<tr>
<td headers="flag_bits_b" style="text-align:right">
16
</td>
<td headers="flag_bits_m">
overflow (more band data elsewhere)
</td>
</tr>
</table>
<h5 id="assignment-of-flag-bits-to-attributes">5.5.1. Assignment of Flag Bits to Attributes</h5>
<p>The assignment of flag bit positions to attributes is done at the option of the compressor, and is independently specified by the compressor for the four kinds of flag words that have to do with attribute-carrying objects (in classes, fields, methods, and codes). When a flag bit position is assigned to an attribute, if that bit is visible in the class file, it must be forced clear before the decompressor writes it to the class file. Therefore, if the compressor expects the decompressor to reproduce a particular non-zero flag bit as output, the compressor must refrain from assigning that bit position to attributes.</p>
<p>In particular, the low-order 16 bits of class, field, and method flags are visible in the class file, and can thus carry modifier bits. None of the bits of a code flags word is visible in the class file; these flag bits are used only for code sub-attributes.</p>
<p>By contrast, the low-order 16 bits of nested class records are used solely for modifiers, since nested class records do not contain attributes. In the rest of this section on attributes, we will disregard the flag words associated with nested class records.</p>
<p>Any of the 63 bit positions in a flags value can be assigned by the compressor to indicate to the decompressor the presence of some particular attribute. The compressor may &quot;take over&quot; a modifier bit by assigning it an attribute definition. (This is done by emitting a definition for the attribute, which mentions that bit position.)</p>
<p>If the compressor &quot;takes over&quot; a bit (modifier or not) that is being used by default for another purpose, the bit loses its previous meaning. However, the compressor may not emit an explicit definition for the same bit twice (in the same context).</p>
<p>Each kind of attribute is defined by four pieces of information: the entity to which it applies (class, field, method, or code), the bit position, if any, to which it is assigned, the name of the attribute (as it appears in the class file), and the layout of the attribute (which allows the decompressor to properly format occurrences of the attribute in the class file). It is an error for the compressor to specify the same name and layout twice in the same context. It is not an error to repeat a name with a different layout, or a layout with a different name.</p>
<p>The first two items are bit-encoded into a single-byte &quot;header&quot;, and transmitted in the <code>attr_definition_headers</code> band. The last two items are transmitted as <code>cp_Utf8</code> references in corresponding elements of the <code>attr_definition_name</code> and <code>attr_definition_layout</code>. Thus there are three bands by which the compressor declares attribute types to the decompressor, and each band is of length <code>#attr_definition_count</code>.</p>
<pre class="codeblock"><code>  attr_definition_bands:
        *attr_definition_headers :BYTE1 [#attr_definition_count]
        *attr_definition_name :UNSIGNED5 [#attr_definition_count] (cp_Utf8)
        *attr_definition_layout :UNSIGNED5 [#attr_definition_count] (cp_Utf8)</code></pre>
<p>The least significant two bits of an attribute definition header byte are treated as an unsigned field, and give the attribute's <em>context type</em>, which is type of entity to which the attribute applies:</p>
<table>
<caption style="display:none">
description of least two significant bits of an attribute definition header byte
</caption>
<tr style="text-align:center">
<th id="l2sb_h">
<code>(h &amp;amp; 0x03)</code>
</th>
<th id="l2sb_c">
Context Type
</th>
</tr>
<tr>
<td headers="l2sb_h" style="text-align:right">
0
</td>
<td headers="l2sb_c">
attribute applies to classes
</td>
</tr>
<tr>
<td headers="l2sb_h" style="text-align:right">
1
</td>
<td headers="l2sb_c">
attribute applies to fields
</td>
</tr>
<tr>
<td headers="l2sb_h" style="text-align:right">
2
</td>
<td headers="l2sb_c">
attribute applies to methods
</td>
</tr>
<tr>
<td headers="l2sb_h" style="text-align:right">
3
</td>
<td headers="l2sb_c">
attribute applies to Code attributes
</td>
</tr>
</table>
<p>The most significant six bits of an attribute definition header byte are treated as an unsigned field, and give the optional bit position to which the attribute is assigned in the flags word.</p>
<table>
<caption style="display:none">
definition of two most significant bits of an attribute definition header byte
</caption>
<tr style="text-align:center">
<th id="m2sb_h" style="text-align:right">
<code>(h &amp;gt;&amp;gt; 2)</code>
</th>
<th id="m2sb_f">
Flag Bit Assignment
</th>
</tr>
<tr>
<td headers="m2sb_h" style="text-align:right">
0
</td>
<td headers="m2sb_f">
overflow attribute, not assigned to any bit
</td>
</tr>
<tr>
<td headers="m2sb_h" style="text-align:right">
1
</td>
<td headers="m2sb_f">
attribute assigned to bit 0 (LSB of lo word)
</td>
</tr>
<tr>
<td headers="m2sb_h" style="text-align:right">
2
</td>
<td headers="m2sb_f">
attribute assigned to bit 1
</td>
</tr>
<tr>
<td headers="m2sb_h" style="text-align:right">
3
</td>
<td headers="m2sb_f">
attribute assigned to bit 2
</td>
</tr>
<tr>
<td headers="m2sb_h" style="text-align:center">
...
</td>
<td headers="m2sb_f">
</td>
</tr>
<tr>
<td headers="m2sb_h" style="text-align:right">
32
</td>
<td headers="m2sb_f">
attribute assigned to bit 31 (MSB of lo word)
</td>
</tr>
<tr>
<td headers="m2sb_h" style="text-align:right">
33
</td>
<td headers="m2sb_f">
attribute assigned to bit 32 (LSB of hi word)
</td>
</tr>
<tr>
<td headers="m2sb_h" style="text-align:center">
...
</td>
<td headers="m2sb_f">
</td>
</tr>
<tr>
<td headers="m2sb_h" style="text-align:right">
63
</td>
<td headers="m2sb_f">
attribute assigned to bit 62
</td>
</tr>
<tr>
<td headers="m2sb_h" style="text-align:right">
(no value)
</td>
<td headers="m2sb_f">
bit 63 must be zero (MSB of hi word)
</td>
</tr>
</table>
<p>Every class attribute, whether predefined in this specification or explicitly defined by the compressor, has a unique number called its <em>attribute index</em>. If the attribute is assigned a flag bit, then its attribute index is identical to the flag bit's position (a number in [0..62]). (All predefined attributes are assigned a flag bit by default.)</p>
<p>If a class attribute is not assigned a flag bit, it is an overflow attribute, and its index is assigned sequentially in the order in which class attributes are defined (i.e., transmitted). The first index to be assigned sequentially in this way is 32 if <code>#have_class_flags_hi</code> is clear, and 63 if it is set. These indexes are used within the archive to declare attribute occurrences for individual classes.</p>
<p>Likewise, field, method, and code attributes are assigned their own attribute indexes, independently of class attributes and of each other. Therefore, an attribute (i.e., a name and layout pair) is uniquely specified within the archive by its context type and attribute index. The field and method attributes may be assigned to flag bits, or else they are overflow attributes with indexes of 32 or larger. Like other attributes, code attributes may be assigned explicit numbers or implicitly assigned indexes starting with 32. (As with class attributes, if the high flag word bands are selected by the appropriate bit of <code>#archive_options</code>, then field, method, or code overflow attributes have indexes of 63 or larger.)</p>
<p>Some attributes are predefined, and do not require the compressor to emit definitions for them. They have implicitly defined layouts and flag bit assignments (i.e., indexes).</p>
<p>Attribute indexes less than 63 are usable in all cases, but they may conflict with those assigned to predefined attributes, including predefined attributes defined (in the range 16 to 62) in future expansions of the Pack200 format. In the present version, all predefined attributes have indexes in the range [17..31], so that modifier flags are not taken over by default, and high flag words do not need to be used routinely.</p>
<p>Here are the names and index assignments of the predefined attributes. (The predefined layouts are given below.)</p>
<table>
<caption style="display:none">
Names and index assignments of predefined attributes
</caption>
<tr style="text-align:center">
<th id="predef_i">
Index
</th>
<th id="predef_c">
Context Type
</th>
<th id="predef_n">
Name
</th>
</tr>
<tr>
<td headers="predef_i" style="text-align:right">
16
</td>
<td headers="predef_c">
C,F,M
</td>
<td headers="predef_n">
(overflow attributes)
</td>
</tr>
<tr>
<td headers="predef_i" style="text-align:right">
17
</td>
<td headers="predef_c">
Class
</td>
<td headers="predef_n">
SourceFile
</td>
</tr>
<tr>
<td headers="predef_i" style="text-align:right">
18
</td>
<td headers="predef_c">
Class
</td>
<td headers="predef_n">
EnclosingMethod
</td>
</tr>
<tr>
<td headers="predef_i" style="text-align:right">
19
</td>
<td headers="predef_c">
C,F,M
</td>
<td headers="predef_n">
Signature
</td>
</tr>
<tr>
<td headers="predef_i" style="text-align:right">
20
</td>
<td headers="predef_c">
C,F,M
</td>
<td headers="predef_n">
Deprecated
</td>
</tr>
<tr>
<td headers="predef_i" style="text-align:right">
21
</td>
<td headers="predef_c">
C,F,M
</td>
<td headers="predef_n">
RuntimeVisibleAnnotations
</td>
</tr>
<tr>
<td headers="predef_i" style="text-align:right">
22
</td>
<td headers="predef_c">
C,F,M
</td>
<td headers="predef_n">
RuntimeInvisibleAnnotations
</td>
</tr>
<tr>
<td headers="predef_i" style="text-align:right">
23
</td>
<td headers="predef_c">
Class
</td>
<td headers="predef_n">
InnerClasses
</td>
</tr>
<tr>
<td headers="predef_i" style="text-align:right">
24
</td>
<td headers="predef_c">
Class
</td>
<td headers="predef_n">
&quot;class-file version&quot;
</td>
</tr>
<tr>
<td headers="predef_i" style="text-align:right">
17
</td>
<td headers="predef_c">
Field
</td>
<td headers="predef_n">
ConstantValue
</td>
</tr>
<tr>
<td headers="predef_i" style="text-align:right">
17
</td>
<td headers="predef_c">
Method
</td>
<td headers="predef_n">
Code
</td>
</tr>
<tr>
<td headers="predef_i" style="text-align:right">
18
</td>
<td headers="predef_c">
Method
</td>
<td headers="predef_n">
Exceptions
</td>
</tr>
<tr>
<td headers="predef_i" style="text-align:right">
23
</td>
<td headers="predef_c">
Method
</td>
<td headers="predef_n">
RuntimeVisibleParameterAnnotations
</td>
</tr>
<tr>
<td headers="predef_i" style="text-align:right">
24
</td>
<td headers="predef_c">
Method
</td>
<td headers="predef_n">
RuntimeInvisibleParameterAnnotations
</td>
</tr>
<tr>
<td headers="predef_i" style="text-align:right">
25
</td>
<td headers="predef_c">
Method
</td>
<td headers="predef_n">
AnnotationDefault
</td>
</tr>
<tr>
<td headers="predef_i" style="text-align:right">
26
</td>
<td headers="predef_c">
Method
</td>
<td headers="predef_n">
MethodParameters
</td>
</tr>
<tr>
<td headers="predef_i" style="text-align:right">
27
</td>
<td headers="predef_c">
C,F,M,Code
</td>
<td headers="predef_n">
RuntimeVisibleTypeAnnotations
</td>
</tr>
<tr>
<td headers="predef_i" style="text-align:right">
28
</td>
<td headers="predef_c">
C,F,M,Code
</td>
<td headers="predef_n">
RuntimeInvisibleTypeAnnotations
</td>
</tr>
<tr>
<td headers="predef_i" style="text-align:right">
0
</td>
<td headers="predef_c">
Code
</td>
<td headers="predef_n">
StackMapTable
</td>
</tr>
<tr>
<td headers="predef_i" style="text-align:right">
1
</td>
<td headers="predef_c">
Code
</td>
<td headers="predef_n">
LineNumberTable
</td>
</tr>
<tr>
<td headers="predef_i" style="text-align:right">
2
</td>
<td headers="predef_c">
Code
</td>
<td headers="predef_n">
LocalVariableTable
</td>
</tr>
<tr>
<td headers="predef_i" style="text-align:right">
3
</td>
<td headers="predef_c">
Code
</td>
<td headers="predef_n">
LocalVariableTypeTable
</td>
</tr>
<tr>
<td headers="predef_i" style="text-align:right">
16
</td>
<td headers="predef_c">
Code
</td>
<td headers="predef_n">
(overflow attributes)
</td>
</tr>
</table>
<p>Bit 16 is predefined as an indicator of the presence of overflow attributes for classes, fields, methods, and codes. If an entity has overflow attributes, it will possess a corresponding count in an &quot;attr_count&quot; band, and each overflow attribute will be part of a run of values in an &quot;attr_indexes&quot; band, which specifies the layouts of the overflow attributes. This processing of overflow attributes is described more fully in the section <a href="#overflow_bits">Attribute Bands</a>.</p>
<p>These predefined attribute indexes determine not only which bit positions are used to select those attributes, but also the fixed band order in which the attribute data are transmitted, as described in the section <a href="#attribute-layout-definitions">Attribute Layout Definitions</a>.</p>
<p>Certain bits are predefined to support the five types of metadata attributes on classes, fields, and methods, <code>RuntimeVisibleAnnotations</code>, <code>RuntimeInvisibleAnnotations</code>, <code>RuntimeVisibleParameterAnnotations</code>, <code>RuntimeInvisibleParameterAnnotations</code>, and <code>AnnotationDefault</code>. (The last three types apply only to methods.) The meaning and format of these attributes is defined by JSR 175. Similarly type metadata attributes <code>RuntimeVisibleTypeAnnotations</code> and <code>RuntimeInvisibleTypeAnnotations</code> on classes, fields, methods and code, are predefined. The meaning and format of these attributes are defined and described by JSR 308.</p>
<p>It is permissible for a compressor to refrain from setting bits in any flag words except for bit 16, and transmit all attribute layout indexes explicitly in <code>class_attr_indexes</code> or a similar band. Decompressors are required to process either kind of occurrence of an attribute index. (It is also permissible, though useless, for an attribute count to be an explicitly transmitted as zero.) Compressors are encouraged to make clever choices and clear bit 16 and set other assigned flag bits when possible.</p>
<p>Note that none of the predefined bits interfere with any present or future flag bits in the 16-bit flag values stored in the class file format. However, compressors are free to reuse one of the low-order 16 bits of the flags word, by binding them to other attributes, if no file actually sets them.</p>
<p>The <code>InnerClasses</code> attribute is treated specially, as documented in the section <a href="#nested-classes">Nested Classes</a>, and it is an error for the compressor to emit an attribute definition for it in the class context. The <code>Code</code> attribute is also treated specially. It is an error to emit an attribute definition for it in the method context.</p>
<p>This specification does not define how a compressor is informed of the existence or format of attributes which are not predefined. It simply assumes that compressors are informed of such attributes, and it requires that compressors properly transmit this information to decompressors. As a special case, it is reasonable for any compressor to transmit an attribute containing no bytes (i.e., of zero length) as if its layout were known to be the empty string.</p>
<h5 id="attribute-layout-definitions">5.5.2. Attribute Layout Definitions</h5>
<p>Attribute layouts govern the compressor as it parses attribute bodies from class files into collections of scalar values. Layouts also govern the decompressor as it decodes transmitted bands of those scalar values, and stores them, correctly formatted, into class files. For example, when a class file stores an unsigned integer in two bytes (in big-endian order) in an attribute, the decompressor uses a layout declaration to this effect, so that it can take a band element (which is a 32-bit integer that in this case happens to be less than 65536) and store it correctly into a class file. The transmission of such an integer is very different from the transmission of a constant pool reference, even though they appear as undifferentiated bytes in the class file format.</p>
<p>In what follows, we say that some given element of an attribute layout <em>governs</em> a scalar value stored in a class file attribute, if the decompressor must use that element to reconstitute, into a class file, the representation of that scalar value. We also say that the given layout element governs the band in which the scalar value is transmitted.</p>
<p>An attribute layout is defined by a string in a &quot;little language&quot;. The string must be parsed by the decompressor into a sequence of <em>layout elements</em>, each of which governs the transmission and storage of attribute values. In particular, the layout declares the locations of all constant pool references, allowing their values to be transmitted with appropriate representations, either as constant pool indexes or else some other sort of number.</p>
<p>The simplest usable attribute layout would be a sequence of constant pool reference declarations, intermixed with one-byte declarations to govern everything else, and compressors are free to use such layouts to describe attributes. However, more specific attribute layouts lead to better compression.</p>
<p>Attributes typically contain constant pool references and small integers. They often contain integers which control the replication of subsequent patterns. Constant pool references are strongly typed where possible, and the encoding provision for null references must be declared also. Small integers which encode flag bits or bytecode indexes are also declared as such, so that special encoding techniques may be used on them.</p>
<p>Layout declarations are UTF8 strings formed according to the following grammar. (This grammar is independent of the grammar which describes band structure, or any other grammar appearing in other parts of this specification.)</p>
<pre class="codeblock"><code>  attribute_layout:
        ( layout_element )* | ( callable )+
  layout_element:
        ( integral | replication | union | call | reference )

  callable:
        &#39;[&#39; body &#39;]&#39;
  body:
        ( layout_element )+

  integral:
        ( unsigned_int | signed_int | bc_index | bc_offset | flag )
  unsigned_int:
        uint_type
  signed_int:
        &#39;S&#39; uint_type
  any_int:
        ( unsigned_int | signed_int )
  bc_index:
        ( &#39;P&#39; uint_type | &#39;PO&#39; uint_type )
  bc_offset:
        &#39;O&#39; any_int
  flag:
        &#39;F&#39; uint_type
  uint_type:
        ( &#39;B&#39; | &#39;H&#39; | &#39;I&#39; | &#39;V&#39; )

  replication:
        &#39;N&#39; uint_type &#39;[&#39; body &#39;]&#39;

  union:
        &#39;T&#39; any_int (union_case)* &#39;(&#39; &#39;)&#39; &#39;[&#39; (body)? &#39;]&#39;
  union_case:
        &#39;(&#39; union_case_tag (&#39;,&#39; union_case_tag)* &#39;)&#39; &#39;[&#39; (body)? &#39;]&#39;
  union_case_tag:
        ( numeral | numeral &#39;-&#39; numeral )
  call:
        &#39;(&#39; numeral &#39;)&#39;

  reference:
        reference_type ( &#39;N&#39; )? uint_type
  reference_type:
        ( constant_ref | schema_ref | utf8_ref | untyped_ref )
  constant_ref:
        ( &#39;KI&#39; | &#39;KJ&#39; | &#39;KF&#39; | &#39;KD&#39; | &#39;KS&#39; | &#39;KQ&#39; | &#39;KM&#39; | &#39;KT&#39; | &#39;KL&#39; )
  schema_ref:
        ( &#39;RC&#39; | &#39;RS&#39; | &#39;RD&#39; | &#39;RF&#39; | &#39;RM&#39; | &#39;RI&#39; | &#39;RY&#39; | &#39;RB&#39; | &#39;RN&#39; )
  utf8_ref:
        &#39;RU&#39;
  untyped_ref:
        &#39;RQ&#39;

  numeral:
        &#39;(&#39; (&#39;-&#39;)? (digit)+ &#39;)&#39;
  digit:
        ( &#39;0&#39; | &#39;1&#39; | &#39;2&#39; | &#39;3&#39; | &#39;4&#39; | &#39;5&#39; | &#39;6&#39; | &#39;7&#39; | &#39;8&#39; | &#39;9&#39; )
</code></pre>
<p>Each occurrence of an attribute in a class file is associated (by the compressor) with a corresponding layout definition which describes accurately the meaning of that attribute's bytes. The compressor must assign each format element its own band for transmitting successive values of that format element. In the case of the predefined attributes, the bands assigned to their layout elements are defined by name in this specification.</p>
<p>Each value governed by an attribute layout element is converted by the compressor into a 32-bit value and transmitted as an element of a band uniquely created for and governed by that layout element. For <code>integral</code> layout elements, the conversion simply represents the number stored in the class file under the given type, while <code>reference</code> elements convert a local constant pool reference (local to the class file, that is) into a global, typed reference within the archive.</p>
<p>Multiple occurrences of the same kind of layout element are regarded as distinct layout elements. Also, bands are never shared by layouts. Therefore, every new layout definition transmitted by the compressor implicitly defines its own set of bands. Reassigning an previously defined attribute layout to a new index creates a new set of bands; it does not reuse the previously defined sets of bands.</p>
<p>If the compressor defines new attributes, it must also create the bands they govern. It must transmit these bands, immediately after the place reserved in the band grammar for predefined attributes (at the end of <code>class_attr_bands</code>, <code>field_attr_bands</code>, <code>method_attr_bands</code>, or <code>code_attr_bands</code>). The ordering of these bands must correspond to the definition order of the attribute layout elements that govern them. In this way, the decompressor will be able to find those attribute values.</p>
<p><a id="def_order"></a></p>
<p>The <em>definition order</em> of two layout elements in the same attribute layout string corresponds to their order of occurrence within that string. The definition order of two layout elements not in the same attribute layout string corresponds to the index order of their layout definitions in the <code>attr_definition_layout</code> band. (That is, bands for layouts with lower indexes precede bands for layouts of the same context type but with higher indexes. This is true even if the lower-indexed layout happens to be defined later in the <code>attr_definition_layout</code> band.) Note that the bands governed by predefined attributes appear to follow such an ordering also. However, the bands of predefined class attributes precede all the other class attribute bands, and likewise for fields, methods, and code attributes.</p>
<p>Integer values stored in attributes are sized as 1, 2, or 4 bytes, depending on the use of the format character 'B', 'H', or 'I', respectively. A integer type is normally unsigned but prefixed with 'S' becomes signed. This signing governs the lengthening of 1-byte and 2-byte types to 32-bit values (either sign extension or zero filling). It also determines the primary encoding used to transmit the 32-bit values. Because all integers stored in class files are &quot;big-endian&quot;, all integral format elements refer to integers coded with higher-order bits in earlier bytes.</p>
<p><code>Integral</code> layouts (i.e., those elements under the <code>integral</code> nonterminal) govern signed or unsigned integer values. Integral layouts whose declarations include the 'P' or 'O' characters use special primary encodings (BCI5 or BRANCH5) as described below. Any other integral layouts whose declarations include the 'S' character govern bands with a primary encoding of SIGNED5. Unsigned integer and flag layout elements govern bands with a primary encoding of UNSIGNED5, except that the integer layout 'B' (unsigned byte) governs a band with a primary encoding of BYTE1.</p>
<p>(Note that there is no special encoding for signed bytes. If an attribute contains a signed byte field, it may be just as well to treat that field as if it were unsigned, and give it a plain 'B' layout element. Besides completeness, the 'SB' layout is intended to allow small-magnitude one-byte integers to be transmitted using a byte alphabet in which sign bits are rare. This is desirable when the post-pass compressor uses Huffman coding to represent bytes; such codings perform best when a consistent byte alphabet is presented to the compressor.)</p>
<p>A stored bytecode index is declared with the layout prefix 'P'. This layout element may only be used on methods or codes. Any number may be stored in a bytecode index. However, before the stored numbers are transmitted as band elements, they are renumbered in the expectation that byte positions not on instruction boundaries will be rare.</p>
<p><a id="bci_psc_ref"></a> <a id="bci_renumbering"></a></p>
<p>The <em>BCI renumbering</em> compactly indexes instruction boundaries, and also provides a coding (somewhat less compact) for all other 32-bit integers, such as the addresses of bytes inside instructions or outside the bounds of the bytecodes. In particular, the first byte of the first instruction is numbered zero, the first byte of the second instruction is numbered one, and so on through all instructions. The byte position one past the last instruction is numbered with the next number (the number of instructions). The second byte of the first multibyte instruction is numbered with the next number, which is one more than the number of all instructions. All remaining unnumbered bytes are assigned subsequent numbers, without any further disturbances of ordering. For large enough positive numbers, and for negative numbers, the renumbering is the identity function.</p>
<p>For purposes of locating instruction boundaries for BCI renumbering, the _wide bytecode (0xc4) is taken to be part of the following instruction, whose format it helps determine. If the compressor transmits byte_escape (254) or ref_escape (253) pseudo-instructions, the decompressor must accept the bytecode sequences produced by each of these instructions as integral instructions, when computing BCI renumberings. Thus, there will be an instruction boundary for each byte in bc_codes (except _wide bytecodes), plus an extra boundary for each &quot;aload_0_xxx&quot; variation (such as &quot;aload_0_getstatic_this&quot;), because these pseudo-opcodes expand to pairs of bytecode instructions.</p>
<p>Please see the Appendix section <a href="#representation-of-byte-offsets">Representation of Byte Offsets</a> for pseudo-code explaining this concept.</p>
<p>If the layout element is prefixed by 'P' and not 'PO', then the renumbered bytecode index is transmitted. This renumbering is called the <em>bytecode index renumbering</em>. The primary encoding for bands containing bytecode indexes is BCI5.</p>
<p>Here is an example of how this works. Imagine a method with 20 bytes of bytecode data and five instructions, at the following positions: <code>{ 0, 4, 6, 10, 17 }</code>. BCI renumbering translates these particular numbers compactly to <code>[0..4]</code>. More completely, BCI renumbering translates <code>[0..20]</code> to the numbers <code>{ 0, 6, 7, 8, 1, 9, 2, 10, 11, 12, 3, 13, 14, 15, 16, 17, 18, 4, 19, 20, 5 }</code>, and anything outside the range <code>[0..20]</code> stays the same after BCI renumbering. If a attribute of this method has a 'P' layout element, and has the number 6 stored in the class file, the number 2 will be transmitted, since 6 is the offset of the third instruction.</p>
<p>If the layout prefix is 'PO', the previous layout element must also have been a bytecode index of layout type 'P' or 'PO'. (There must not be intervening structure, such as brackets '[' or ']'.) In this case, the value transmitted in the band governed by the 'PO' element is the difference between the renumbered bytecode index governed by the current 'PO' element, and the renumbered bytecode index governed by the previous 'P' or 'PO' element. (In the case of a previous 'P' element, this is in fact the value transmitted at the corresponding position in the previous band.)</p>
<p>The 'PO' layout elements govern the same kind of attribute data as 'P' elements, but they use an encoding which expects that adjacent bytecode indexes are correlated. This renumbering, including a difference with the previous element, is called the <em>bytecode offset renumbering</em> The primary encoding for bands containing bytecode offsets is BRANCH5. This encoding is used even if the layout element contains the 'S' or the 'B' character.</p>
<p>A bytecode offset is declared with the layout prefix 'O'. This layout element must immediately follow a previous bytecode index element (with prefix 'P' and not 'PO'). Any value governed by this layout element is regarded as an offset, which when applied to the corresponding previously stored bytecode index, produces another bytecode index. That is, both the previous value and the sum of the previous value and the current value are expected to refer to instruction boundaries. As with the 'PO' layout, the value transmitted is the difference of the two renumbered bytecode indexes. Bands governed by 'PO' layouts contain bytecode offsets, and use the BRANCH5 primary encoding. Unlike the 'PO' layout, the stored value governed by an 'O' layout is the difference between two bytecode indexes.</p>
<p>Thus, bands governed by both 'O' and 'PO' layouts contain bytecode offsets, and use BRANCH5 to encode those offsets. But attribute values governed by both 'P' and 'PO' layouts store absolute bytecode indexes; only 'O' layouts govern stored bytecode offsets. The stored offsets are treated as unsigned fields in the class file unless the 'S' character is present. By contrast, stored indexes are always treated as unsigned fields.</p>
<p>If the preceding example attribute for a 20-byte method also has a 'PO' layout element following its 'P' element, and the number 20 is stored in the class file, the number to be transmitted is found by renumbering 20 to 5, and then subtracting the previous transmitted number (5-2). The number 3 will therefore be transmitted. If instead the stored number is 7 (a BCI inside the instruction at position 6), the transmitted number will be (10-2) or 8. The same transmitted values (3, 8), if governed by an 'O' layout element instead of 'PO', would correspond to stored values of 14 (20-6) and 1 (7-6), instead of 20 and 7.</p>
<p>A flag element (with prefix 'F') encodes integer values which are expected to encode short array of bits, rather than arithmetic values. The bits are not required to be interpreted as access modifiers. The primary encoding for bands transmitting flag layout elements is UNSIGNED5, except that 'FB' layouts use a primary encoding of BYTE1.</p>
<p>Integral values transmitted under the 'V' format character instead of 'B', 'H', or 'I' occupy no bytes at all in the class file attribute. These layout elements allow the decompressor to use counts or tags to control transmission without having them appear directly in class file attributes. For example, consider an attribute which is an array of bytes that is not self-sizing but expands to fill the byte-count mentioned in the attribute header in the class file. Such an attribute might have a layout specification of 'NV[B]'. The compressor would be responsible to decide which values to transmit for a 'V' layout element. (Such decisions would have to make use of detailed information about attribute formats that is not part of this specification.) In all cases, the decompressor must respect these values (when used as counts or tags) but must not store them in the class file.</p>
<p>A <em>replication</em> is introduced by a prefix 'N', which is followed by an integer element called the <em>replication count</em>, and by then a series of elements, called the <em>replication body</em>, enclosed in square brackets. The attribute data governed by this layout consists of a replication count followed by an array of data counted by the replication count. Each array element is governed by the layouts in the replication body.</p>
<p>A replication count layout element governs a band transmitting the replication counts, which has a primary encoding of UNSIGNED5 (or BYTE1, if the layout starts with 'NB'). The bands governed by the corresponding replication body may be sized by summing the values transmitted in the band containing the counts.</p>
<p>A <em>union</em> is introduced by a prefix 'T', which is followed by an integer element called the <em>union tag</em>, and by then a series of labeled, bracketed groups of elements, called the <em>union cases</em>. (The numerals can have any number of digits, but their arithmetic values are truncated to 32-bit integers before being compared with band values, which also are 32 bits in size.) Each label but the last consists of one or more parenthesized, possibly signed decimal numerals, called <em>union tags</em>. The last label (which is the default case) must be an empty pair of parentheses. (No union may contain two occurrences of the same case tag.) The attribute data governed by this layout consists of an integral tag value followed by data whose format is determined by the tag. The data following the tag is governed by the (unique) union case whose label matches the tag's value, or else the default case. The bands governed by each union case may be sized by counting the number of values in the band governed by the tag's layout. As with plain integral bands, the primary encoding of union tag band is SIGNED5, BYTE1, or UNSIGNED5, depending on whether the layout contains an 'S' character, is 'TB', or otherwise.</p>
<p>In a union tag, two numerals separated by a hyphen specify an inclusive range. The second number must be greater than the first. This is an abbreviation for the list of all numerals from the first to the second, inclusive. The layout is treated exactly as if the abbreviation were replaced by the complete list.</p>
<p>Constant pool references in an attribute may be typed strongly, and transmitted as indexes into one of the archive's constant pools. The layout types beginning with 'KI', 'KJ', 'KF', 'KD', and 'KS' must govern stored indexes in the local constant pool to constants of type integer, long, float, double, and string. The layout types beginnig 'KM' and 'KT' govern indexes to constants of type MethodHandle and MethodType. Likewise, the layout types beginning with 'RC', 'RS', 'RD', 'RF', 'RM', 'RI', and 'RU' must govern stored indexes in the local constant pool to symbols of type class, signature, descriptor (pair of name and type), field reference, method reference, interface method reference, and UTF8 string. The layout type 'RY' governs indexes to invokedynamic descriptors, while the type 'RB' governs indexes to bootstrap method specifiers (which are elements of the <code>BootstrapMethods</code> attribute, not of the constant pool). All these references are transmitted as 32-bit indexes into the corresponding global constant pools, in bands with primary encoding of UNSIGNED5. (This is true even of layouts which contain 'B'.) See table below.</p>
<p>Note that signature references (layout 'RS') are identical to Utf8 references (layout 'RU') within a class file, but lead to different coding tactics in the archive file, since the <code>cp_Utf8</code> and <code>cp_Signature</code> constant pools have independent indexes and are transmitted differently.</p>
<p>The layout elements beginning 'KQ' may only occur in attributes on fields. They refer to constants in a constant pool whose identity is determined by the field's signature. (This layout element is probably useful only for <code>ConstantValue</code> attributes, which are predefined.) The following table gives field signatures legal for use with 'KQ' layouts, and the corresponding constant pools in which the corresponding stored references must be found.</p>
<table>
<caption style="display:none">
field signatures for use with KQ layouts
</caption>
<tr>
<th id="kq_f">
Field Signature
</th>
<th id="kq_c">
'KQ' Constant Pool
</th>
</tr>
<tr>
<td headers="kq_f">
B
</td>
<td headers="kq_c">
cp_Int
</td>
</tr>
<tr>
<td headers="kq_f">
S
</td>
<td headers="kq_c">
cp_Int
</td>
</tr>
<tr>
<td headers="kq_f">
C
</td>
<td headers="kq_c">
cp_Int
</td>
</tr>
<tr>
<td headers="kq_f">
Z
</td>
<td headers="kq_c">
cp_Int
</td>
</tr>
<tr>
<td headers="kq_f">
I
</td>
<td headers="kq_c">
cp_Int
</td>
</tr>
<tr>
<td headers="kq_f">
J
</td>
<td headers="kq_c">
cp_Long
</td>
</tr>
<tr>
<td headers="kq_f">
F
</td>
<td headers="kq_c">
cp_Float
</td>
</tr>
<tr>
<td headers="kq_f">
D
</td>
<td headers="kq_c">
cp_Double
</td>
</tr>
<tr>
<td headers="kq_f">
Ljava/lang/String;
</td>
<td headers="kq_c">
cp_String
</td>
</tr>
<tr>
<td headers="kq_f">
Ljava/lang/Class;
</td>
<td headers="kq_c">
cp_Class
</td>
</tr>
</table>
<p>Three additional layout types transmit indexes into constant pool groups, instead of individual constant pools. They may be used when the compressor elects to use a layout which has references that are not strongly typed. The combined type 'KL' may be used for any index that refers to a valid operand of the 'ldc' instruction, and the transmitted indexes will be renumbered relative to the <code>cp_LoadableValue</code> pool group. Similarly, the combined layout type 'RN' may be used for any index that refers to a valid operand of any of the 'get' or 'invoke' instructions (except 'invokedynamic'), and these indexes will renumbered relative to the <code>cp_AnyMember</code> pool group.</p>
<p>Finally, if a constant pool reference cannot be typed at all, the compressor must use an <code>untyped_ref</code> ('RQ'), which transmits an index into the comprehensive constant pool group <code>cp_All</code>. For example, all the elements of the <code>cp_Utf8</code> pool are numbered the same in the 'RQ' and 'RU' layouts. But the first element (element zero) of the <code>cp_Int</code> pool is numbered, for untyped references, as <code>cp_Utf8_count</code>, and the first element of the <code>cp_Float</code> pool is numbered, for untyped references, as <code>cp_Utf8_count+cp_Int_count</code>.</p>
<p>If a compressor is faced with an attribute which contains a constant pool index of an unexpected type, it may either refuse to transmit the attribute, or elect to transmit the attribute under a relaxed layout definition using 'RQ' or 'RQN' elements instead of more strongly-typed elements. (If the unexpected type is a loadable constant or member reference, the compressor may elect to use 'RN' or 'KL' elements instead.) Decompressors are required to honor all legal layout definitions transmitted by compressors, even if they might produce illegally formatted class files. (In an extreme case, a compressor may elect to transmit a class file as if it were a resource file, obtaining no class-specific compression, but preserving unusually formatted attributes with bit-for-bit accuracy.)</p>
<p>If a <code>reference</code> layout type includes the character 'N', all band values encoding constant pool entries are incremented by one, and the null value is encoded as zero. Otherwise, the null value is encoded as negative one (-1).</p>
<p>The effect on primary band encodings of the rules given above may be summarized as a list of prioritized rules for layout elements, where the first applicable rule determines the encoding:</p>
<ul>
<li>If the layout contains 'O', use BRANCH5.</li>
<li>Otherwise, if the layout contains 'P', use BCI5.</li>
<li>Otherwise, if the layout contains 'S' but not 'KS' or 'RS', use SIGNED5.</li>
<li>Otherwise, if the layout contains 'B' but not 'RB', use BYTE1.</li>
<li>For all other layouts use UNSIGNED5.</li>
</ul>
<p>Here is a table summarizing bands and encodings for various layout elements. (Not all possible combinations of types and integer sizes are shown.)</p>
<table>
<caption style="display:none">
summary of bands and encodings for various layout elements
</caption>
<tr style="text-align:center">
<th id="layout_l">
Layout<br /> Element
</th>
<th id="layout_s">
Stored<br /> Value
</th>
<th id="layout_t">
Transmitted<br /> Value
</th>
<th id="layout_p">
Primary<br /> Encoding
</th>
</tr>
<tr>
<td headers="layout_l">
B
</td>
<td headers="layout_s">
u1
</td>
<td headers="layout_t">
x
</td>
<td headers="layout_p">
BYTE1
</td>
</tr>
<tr>
<td headers="layout_l">
FB
</td>
<td headers="layout_s">
u1
</td>
<td headers="layout_t">
x
</td>
<td headers="layout_p">
BYTE1
</td>
</tr>
<tr>
<td headers="layout_l">
SB
</td>
<td headers="layout_s">
u1
</td>
<td headers="layout_t">
(byte)x
</td>
<td headers="layout_p">
SIGNED5
</td>
</tr>
<tr>
<td headers="layout_l">
H
</td>
<td headers="layout_s">
u2
</td>
<td headers="layout_t">
x
</td>
<td headers="layout_p">
UNSIGNED5
</td>
</tr>
<tr>
<td headers="layout_l">
FH
</td>
<td headers="layout_s">
u2
</td>
<td headers="layout_t">
x
</td>
<td headers="layout_p">
UNSIGNED5
</td>
</tr>
<tr>
<td headers="layout_l">
SH
</td>
<td headers="layout_s">
u2
</td>
<td headers="layout_t">
(short)x
</td>
<td headers="layout_p">
SIGNED5
</td>
</tr>
<tr>
<td headers="layout_l">
I
</td>
<td headers="layout_s">
u4
</td>
<td headers="layout_t">
x
</td>
<td headers="layout_p">
UNSIGNED5
</td>
</tr>
<tr>
<td headers="layout_l">
FI
</td>
<td headers="layout_s">
u4
</td>
<td headers="layout_t">
x
</td>
<td headers="layout_p">
UNSIGNED5
</td>
</tr>
<tr>
<td headers="layout_l">
SI
</td>
<td headers="layout_s">
u4
</td>
<td headers="layout_t">
x
</td>
<td headers="layout_p">
SIGNED5
</td>
</tr>
<tr>
<td headers="layout_l">
PH
</td>
<td headers="layout_s">
u2
</td>
<td headers="layout_t">
renumber_bci(x)
</td>
<td headers="layout_p">
BCI5
</td>
</tr>
<tr>
<td headers="layout_l">
POH
</td>
<td headers="layout_s">
u2
</td>
<td headers="layout_t">
renumber_bci(x) - renumber_bci(x0)
</td>
<td headers="layout_p">
BRANCH5
</td>
</tr>
<tr>
<td headers="layout_l">
OH
</td>
<td headers="layout_s">
u2
</td>
<td headers="layout_t">
renumber_bci(x0+x) - renumber_bci(x0)
</td>
<td headers="layout_p">
BRANCH5
</td>
</tr>
<tr>
<td headers="layout_l">
NB[...]
</td>
<td headers="layout_s">
u1
</td>
<td headers="layout_t">
x <em>(also serves as size count)</em>
</td>
<td headers="layout_p">
BYTE1
</td>
</tr>
<tr>
<td headers="layout_l">
NH[...]
</td>
<td headers="layout_s">
u2
</td>
<td headers="layout_t">
x <em>(also serves as size count)</em>
</td>
<td headers="layout_p">
UNSIGNED5
</td>
</tr>
<tr>
<td headers="layout_l">
NI[...]
</td>
<td headers="layout_s">
u4
</td>
<td headers="layout_t">
x <em>(also serves as size count)</em>
</td>
<td headers="layout_p">
UNSIGNED5
</td>
</tr>
<tr>
<td headers="layout_l">
TB...
</td>
<td headers="layout_s">
u1
</td>
<td headers="layout_t">
x
</td>
<td headers="layout_p">
BYTE1
</td>
</tr>
<tr>
<td headers="layout_l">
TSB...
</td>
<td headers="layout_s">
u1
</td>
<td headers="layout_t">
(byte)x
</td>
<td headers="layout_p">
SIGNED5
</td>
</tr>
<tr>
<td headers="layout_l">
TH...
</td>
<td headers="layout_s">
u2
</td>
<td headers="layout_t">
x
</td>
<td headers="layout_p">
UNSIGNED5
</td>
</tr>
<tr>
<td headers="layout_l">
TSH...
</td>
<td headers="layout_s">
u2
</td>
<td headers="layout_t">
(short)x
</td>
<td headers="layout_p">
SIGNED5
</td>
</tr>
<tr>
<td headers="layout_l">
KIB
</td>
<td headers="layout_s">
u1
</td>
<td headers="layout_t">
indexOf(lcp[x], cp_Int)
</td>
<td headers="layout_p">
UNSIGNED5
</td>
</tr>
<tr>
<td headers="layout_l">
KIH
</td>
<td headers="layout_s">
u2
</td>
<td headers="layout_t">
indexOf(lcp[x], cp_Int)
</td>
<td headers="layout_p">
UNSIGNED5
</td>
</tr>
<tr>
<td headers="layout_l">
KII
</td>
<td headers="layout_s">
u4
</td>
<td headers="layout_t">
indexOf(lcp[x], cp_Int)
</td>
<td headers="layout_p">
UNSIGNED5
</td>
</tr>
<tr>
<td headers="layout_l">
KINH
</td>
<td headers="layout_s">
u2
</td>
<td headers="layout_t">
1+indexOf(lcp[x], cp_Int)
</td>
<td headers="layout_p">
UNSIGNED5
</td>
</tr>
<tr>
<td headers="layout_l">
KJH
</td>
<td headers="layout_s">
u2
</td>
<td headers="layout_t">
indexOf(lcp[x], cp_Long)
</td>
<td headers="layout_p">
UNSIGNED5
</td>
</tr>
<tr>
<td headers="layout_l">
KFH
</td>
<td headers="layout_s">
u2
</td>
<td headers="layout_t">
indexOf(lcp[x], cp_Float)
</td>
<td headers="layout_p">
UNSIGNED5
</td>
</tr>
<tr>
<td headers="layout_l">
KDH
</td>
<td headers="layout_s">
u2
</td>
<td headers="layout_t">
indexOf(lcp[x], cp_Double)
</td>
<td headers="layout_p">
UNSIGNED5
</td>
</tr>
<tr>
<td headers="layout_l">
KSH
</td>
<td headers="layout_s">
u2
</td>
<td headers="layout_t">
indexOf(lcp[x], cp_String)
</td>
<td headers="layout_p">
UNSIGNED5
</td>
</tr>
<tr>
<td headers="layout_l">
KQH
</td>
<td headers="layout_s">
u2
</td>
<td headers="layout_t">
indexOf(lcp[x], cp_FieldSpecific)
</td>
<td headers="layout_p">
UNSIGNED5
</td>
</tr>
<tr>
<td headers="layout_l">
KMH
</td>
<td headers="layout_s">
u2
</td>
<td headers="layout_t">
indexOf(lcp[x], cp_MethodHandle)
</td>
<td headers="layout_p">
UNSIGNED5
</td>
</tr>
<tr>
<td headers="layout_l">
KTH
</td>
<td headers="layout_s">
u2
</td>
<td headers="layout_t">
indexOf(lcp[x], cp_MethodType)
</td>
<td headers="layout_p">
UNSIGNED5
</td>
</tr>
<tr>
<td headers="layout_l">
KLH
</td>
<td headers="layout_s">
u2
</td>
<td headers="layout_t">
indexOf(lcp[x], cp_LoadableValue)
</td>
<td headers="layout_p">
UNSIGNED5
</td>
</tr>
<tr>
<td headers="layout_l">
RCH
</td>
<td headers="layout_s">
u2
</td>
<td headers="layout_t">
indexOf(lcp[x], cp_Class)
</td>
<td headers="layout_p">
UNSIGNED5
</td>
</tr>
<tr>
<td headers="layout_l">
RSH
</td>
<td headers="layout_s">
u2
</td>
<td headers="layout_t">
indexOf(lcp[x], cp_Signature)
</td>
<td headers="layout_p">
UNSIGNED5
</td>
</tr>
<tr>
<td headers="layout_l">
RDH
</td>
<td headers="layout_s">
u2
</td>
<td headers="layout_t">
indexOf(lcp[x], cp_Descr)
</td>
<td headers="layout_p">
UNSIGNED5
</td>
</tr>
<tr>
<td headers="layout_l">
RFH
</td>
<td headers="layout_s">
u2
</td>
<td headers="layout_t">
indexOf(lcp[x], cp_Field)
</td>
<td headers="layout_p">
UNSIGNED5
</td>
</tr>
<tr>
<td headers="layout_l">
RMH
</td>
<td headers="layout_s">
u2
</td>
<td headers="layout_t">
indexOf(lcp[x], cp_Method)
</td>
<td headers="layout_p">
UNSIGNED5
</td>
</tr>
<tr>
<td headers="layout_l">
RIH
</td>
<td headers="layout_s">
u2
</td>
<td headers="layout_t">
indexOf(lcp[x], cp_Imethod)
</td>
<td headers="layout_p">
UNSIGNED5
</td>
</tr>
<tr>
<td headers="layout_l">
RUH
</td>
<td headers="layout_s">
u2
</td>
<td headers="layout_t">
indexOf(lcp[x], cp_Utf8)
</td>
<td headers="layout_p">
UNSIGNED5
</td>
</tr>
<tr>
<td headers="layout_l">
RQH
</td>
<td headers="layout_s">
u2
</td>
<td headers="layout_t">
indexOf(lcp[x], cp_All)
</td>
<td headers="layout_p">
UNSIGNED5
</td>
</tr>
<tr>
<td headers="layout_l">
RQNH
</td>
<td headers="layout_s">
u2
</td>
<td headers="layout_t">
1+indexOf(lcp[x], cp_All)
</td>
<td headers="layout_p">
UNSIGNED5
</td>
</tr>
<tr>
<td headers="layout_l">
RQNI
</td>
<td headers="layout_s">
u4
</td>
<td headers="layout_t">
1+indexOf(lcp[x], cp_All)
</td>
<td headers="layout_p">
UNSIGNED5
</td>
</tr>
<tr>
<td headers="layout_l">
RYH
</td>
<td headers="layout_s">
u2
</td>
<td headers="layout_t">
indexOf(lcp[x], cp_InvokeDynamic)
</td>
<td headers="layout_p">
UNSIGNED5
</td>
</tr>
<tr>
<td headers="layout_l">
RBH
</td>
<td headers="layout_s">
u2
</td>
<td headers="layout_t">
indexOf(class.BootstrapMethods[x], cp_BootstrapMethod)
</td>
<td headers="layout_p">
UNSIGNED5
</td>
</tr>
<tr>
<td headers="layout_l">
RNH
</td>
<td headers="layout_s">
u2
</td>
<td headers="layout_t">
indexOf(lcp[x], cp_AnyMember)
</td>
<td headers="layout_p">
UNSIGNED5
</td>
</tr>
</table>
<p>Here, the variable <em>x</em> names a value stored in the attribute, governed by the layout element. The variable <em>x0</em> names the stored value governed by the immediately previous layout element, which must have begun with 'P'. The expression <em>renumber_bci(x)</em> denotes the renumbering of a bytecode index <em>x</em> to shorten references to instruction boundaries, as described above. The expression <em>lcp[x]</em> denotes a local constant pool reference, with index <em>x</em>, or a distinct null value if <em>x</em> is zero.</p>
<p>The expression <em>class.BootstrapMethods[x]</em> denotes an element of the <code>BootstrapMethods</code> attribute of the current class. This attribute contains additional complex constants required by <code>CONSTANT_InvokeDynamic</code> constant pool entries.</p>
<p>The expression <em>indexOf(lcp[x], cp)</em> denotes the index (zero-based) in a Pack200 global constant pool <em>cp</em> of the constant <em>lcp[x]</em>, which is assumed to be of a type appropriate to <em>cp</em>. This expression has the value -1 if <em>lcp[x]</em> has the distinct null value.</p>
<p>Note that a null reference can always be transmitted in a band containing references, by transmitting the value zero (if the band is specified to accept nulls) or by transmitting the value -1 (otherwise). The UNSIGNED5 encoding can represent -1 in five bytes.</p>
<p>The name <em>cp_FieldSpecific</em> refers to a global constant pool selected by the enclosing field's signature, as described above.</p>
<h5 id="recursive-layouts">5.5.3. Recursive Layouts</h5>
<p>The top-level structure of a layout specification may be a series of bodies which are independently <em>callable</em> layouts. In such a case, the attribute data governed by the whole layout specification is governed by the first body in the sequence of callables. The other callables can govern data, but they only do this if they are actually called. The effect is to define a mutually recursive set of layout specifications, and give control to the first. Note that callables may not be nested inside any other syntax. This feature is useful for supporting recursively structured class file attributes, such as metadata.</p>
<p>A <em>call</em> layout element is a parenthesized signed decimal numeral <em>N</em>. It refers to the <em>N</em>th <em>callable</em> in the top-level structure of the layout specification, relative to the callable in which the call appears. (It is illegal for calls to appear outside of callables.) We will refer to this callable as the call's <em>callee</em>.</p>
<p>(For example, the layout element '(2)' calls the second callable layout after the one in which the call appears. There must be a matching callee for every callable. A call spelled '(1)' must not appear in the last callable of a layout, and likewise a call spelled '(-1)' must not occur in the first callable. Note that the self-call spelled '(0)' is always legal.)</p>
<p>A <em>call</em> layout element indirectly governs the attribute data more directly governed by the callable that the layout element calls. As far as class file format is concerned, the effect is the same as if the text within the callable's body were substituted instead of the call.</p>
<p>However, this substitution semantics does not describe the effect of a call layout element on band structure. A call layout element does not directly govern any bands, but rather specifies that the data it indirectly governs is to be transmitted in the bands governed more directly by the callee.</p>
<p>If a call's callee begins textually later than the call itself, the call is a <em>forward call</em>. The effect of a forward call is simply to make the bands of the callee sharable by the call and any other forward calls to the same callee. For example, the following layout specification has two bands, the latter of which transmits data indirectly governed by either of the union cases. (The default union case governs no bands, so that a tag byte other than ASCII 'A' or 'B' has no following bytes. Whitespace has been added to the layout for ease of reading.)</p>
<pre class="codeblock"><code>        [TB
          (65) [(1)]
          (66) [(1)]
          (  ) []
          ]
        [H]
</code></pre>
<p>A call's callee can also begin textually earlier than the call itself. Such a call, which must have a spelling of the form '(0)' or '(-<em>N</em>)', is referred to as a <em>backward call</em>. Its callee is referred to as a <em>backward callable</em>. (Callables which are the target of no calls or only of forward calls are not backward callables; all others are.) Backward calls and callables introduce the possibility of recursion and looping. Here is an example of an N-ary tree whose leaves are Utf8 strings preceded by a zero-byte, and whose internal nodes are counted arrays of tree nodes preceded by a one-byte: In this example, the callee encloses the call, for a direct recursion. The layout governs three bands, under the elements 'TB', 'NH', and 'RUH'.</p>
<pre class="codeblock"><code>        [TB
          (1) [NH[ (0) ]]
          (0) [RUH]
        ]
</code></pre>
<p>The sizing of bands governed by such mutually-recursive layouts is assisted by explicit counts of backward calls, transmitted before any of the layout's attribute bands, in <code>class_attr_calls</code> and three similar bands, which are described later.</p>
<h5 id="default-attribute-layouts">5.5.4. Default Attribute Layouts</h5>
<p>The layout definitions of the predefined attributes are as follows:</p>
<table>
<caption style="display:none">
layout definitions for predefined attributes
</caption>
<tr style="text-align:center">
<th id="predef_attr_layout_c">
Context Type
</th>
<th id="predef_attr_layout_n">
Name
</th>
<th id="predef_attr_layout_l">
Layout Definition
</th>
</tr>
<tr>
<td headers="predef_attr_layout_c">
Class
</td>
<td headers="predef_attr_layout_n">
&quot;class-file version&quot;
</td>
<td headers="predef_attr_layout_l">
<em>(empty) *(see note)</em>
</td>
</tr>
<tr>
<td headers="predef_attr_layout_c">
Class
</td>
<td headers="predef_attr_layout_n">
InnerClasses
</td>
<td headers="predef_attr_layout_l">
<em>(empty) *(see note)</em>
</td>
</tr>
<tr>
<td headers="predef_attr_layout_c">
Class
</td>
<td headers="predef_attr_layout_n">
EnclosingMethod
</td>
<td headers="predef_attr_layout_l">
RCHRDNH
</td>
</tr>
<tr>
<td headers="predef_attr_layout_c">
Class
</td>
<td headers="predef_attr_layout_n">
SourceFile
</td>
<td headers="predef_attr_layout_l">
RUNH *(see note)
</td>
</tr>
<tr>
<td headers="predef_attr_layout_c">
Class
</td>
<td headers="predef_attr_layout_n">
Signature
</td>
<td headers="predef_attr_layout_l">
RSH
</td>
</tr>
<tr>
<td headers="predef_attr_layout_c">
Class
</td>
<td headers="predef_attr_layout_n">
(metadata)
</td>
<td headers="predef_attr_layout_l">
(see <a href="#metadata-layouts">Metadata Layouts</a>)
</td>
</tr>
<tr>
<td headers="predef_attr_layout_c">
Class
</td>
<td headers="predef_attr_layout_n">
Deprecated
</td>
<td headers="predef_attr_layout_l">
<em>(empty)</em>
</td>
</tr>
<tr>
<td headers="predef_attr_layout_c">
Class
</td>
<td headers="predef_attr_layout_n">
(type metadata)
</td>
<td headers="predef_attr_layout_l">
(see <a href="#metadata-layouts">Metadata Layouts</a>)
</td>
</tr>
<tr>
<td headers="predef_attr_layout_c">
Field
</td>
<td headers="predef_attr_layout_n">
ConstantValue
</td>
<td headers="predef_attr_layout_l">
KQH
</td>
</tr>
<tr>
<td headers="predef_attr_layout_c">
Field
</td>
<td headers="predef_attr_layout_n">
Signature
</td>
<td headers="predef_attr_layout_l">
RSH
</td>
</tr>
<tr>
<td headers="predef_attr_layout_c">
Field
</td>
<td headers="predef_attr_layout_n">
(metadata)
</td>
<td headers="predef_attr_layout_l">
(see <a href="#metadata-layouts">Metadata Layouts</a>)
</td>
</tr>
<tr>
<td headers="predef_attr_layout_c">
Field
</td>
<td headers="predef_attr_layout_n">
Deprecated
</td>
<td headers="predef_attr_layout_l">
<em>(empty)</em>
</td>
</tr>
<tr>
<td headers="predef_attr_layout_c">
Field
</td>
<td headers="predef_attr_layout_n">
(type metadata)
</td>
<td headers="predef_attr_layout_l">
(see <a href="#metadata-layouts">Metadata Layouts</a>)
</td>
</tr>
<tr>
<td headers="predef_attr_layout_c">
Method
</td>
<td headers="predef_attr_layout_n">
Code
</td>
<td headers="predef_attr_layout_l">
<em>(empty) *(see note)</em>
</td>
</tr>
<tr>
<td headers="predef_attr_layout_c">
Method
</td>
<td headers="predef_attr_layout_n">
Exceptions
</td>
<td headers="predef_attr_layout_l">
NH[RCH]
</td>
</tr>
<tr>
<td headers="predef_attr_layout_c">
Method
</td>
<td headers="predef_attr_layout_n">
Signature
</td>
<td headers="predef_attr_layout_l">
RSH
</td>
</tr>
<tr>
<td headers="predef_attr_layout_c">
Method
</td>
<td headers="predef_attr_layout_n">
(metadata)
</td>
<td headers="predef_attr_layout_l">
(see <a href="#metadata-layouts">Metadata Layouts</a>)
</td>
</tr>
<tr>
<td headers="predef_attr_layout_c">
Method
</td>
<td headers="predef_attr_layout_n">
Deprecated
</td>
<td headers="predef_attr_layout_l">
<em>(empty)</em>
</td>
</tr>
<tr>
<td headers="predef_attr_layout_c">
Method
</td>
<td headers="predef_attr_layout_n">
MethodParameters
</td>
<td headers="predef_attr_layout_l">
NB[RUNHFH]
</td>
</tr>
<tr>
<td headers="predef_attr_layout_c">
Method
</td>
<td headers="predef_attr_layout_n">
(type metadata)
</td>
<td headers="predef_attr_layout_l">
(see <a href="#metadata-layouts">Metadata Layouts</a>)
</td>
</tr>
<tr>
<td headers="predef_attr_layout_c">
Code
</td>
<td headers="predef_attr_layout_n">
StackMapTable
</td>
<td headers="predef_attr_layout_l">
(see <a href="#stack-map-layouts">Stack Map Layouts</a>)
</td>
</tr>
<tr>
<td headers="predef_attr_layout_c">
Code
</td>
<td headers="predef_attr_layout_n">
LineNumberTable
</td>
<td headers="predef_attr_layout_l">
NH[PHH]
</td>
</tr>
<tr>
<td headers="predef_attr_layout_c">
Code
</td>
<td headers="predef_attr_layout_n">
LocalVariableTable
</td>
<td headers="predef_attr_layout_l">
NH[PHOHRUHRSHH]
</td>
</tr>
<tr>
<td headers="predef_attr_layout_c">
Code
</td>
<td headers="predef_attr_layout_n">
LocalVariableTypeTable
</td>
<td headers="predef_attr_layout_l">
NH[PHOHRUHRSHH]
</td>
</tr>
<tr>
<td headers="predef_attr_layout_c">
Code
</td>
<td headers="predef_attr_layout_n">
(type metadata)
</td>
<td headers="predef_attr_layout_l">
(see <a href="#metadata-layouts">Metadata Layouts</a>)
</td>
</tr>
</table>
<p>The star '*' in the layout definitions of &quot;class-file version&quot;, <code>InnerClasses</code>, <code>SourceFile</code>, and <code>Code</code> reflects the fact that these attributes are given special processing. For a class, the &quot;<a href="#special_version_number">class-file version</a>&quot; pseudo-attribute is transmitted as if using the format <code>VV</code>, but the decompressor does not store the result in a class file attribute, but rather in the class file header. (See the discussion in the section <a href="#attribute-bands">Attribute Bands</a>.) For a class, the <code>InnerClasses</code> attribute is partially transmitted as if using the format <code>NV[RCVTV[(0)[]()[RCNVRUNV]]]</code>, but the decompressor processes the received values further before (possibly) emitting an <code>InnerClasses</code> attribute. (See the discussion in the section <a href="#local-innerclasses-attributes">Local InnerClasses Attributes</a>.) When a <code>SourceFile</code> attribute is transmitted using the predefined layout, a special rule allows it to default to the obvious standard string. Finally, for a method, the <code>Code</code> attribute is transmitted under the <code>code_bands</code>.</p>
<h5 id="stack-map-layouts">5.5.5. Stack Map Layouts</h5>
<p>There is a predefined attribute layout for the <code>StackMapTable</code> attribute of a <code>Code</code> attribute. With some whitespace and abbreviation added for readability, it is as follows:</p>
<pre class="codeblock"><code>
  [NH[(1)]]
  [TB
    (64-127)  [(2)]
    (247)     [(1)(2)]
    (248-251) [(1)]
    (252)     [(1)(2)]
    (253)     [(1)(2)(2)]
    (254)     [(1)(2)(2)(2)]
    (255)     [(1)NH[(2)]NH[(2)]]
    ()        []
    ]
  [H]
  [TB
    (7) [RCH]
    (8) [PH]
    ()  []
    ]
</code></pre>
<p>The following observations may be deduced by comparing this layout specification with the class file format specification which defines the <code>StackMapTable</code> attribute. The second callable describes a <code>stack_map_frame</code> structure from the class file format specification. Within the union in the second callable, the cases stand for the following <code>stack_map_frame</code> union members, respectively: <code>same_locals_1_stack_item_frame</code>, <code>same_locals_1_stack_item_extended</code>, <code>chop_frame</code> (and also <code>same_frame_extended</code>), <code>append_frame</code> (for three layout union cases), <code>full_frame</code>, and (in the default layout union case) <code>same_frame</code>. The third and fourth callables describe an <code>offset_delta</code> value and a <code>verification_type_info</code> structure from the class file format specification.</p>
<h5 id="metadata-layouts">5.5.6. Metadata Layouts</h5>
<p>The predefined attribute layouts for non-parameter metadata annotations are the same in all three contexts. With some whitespace added for readability, the layout is as follows:</p>
<pre class="codeblock"><code>
  [NH[(1)]]
  [RSH NH[RUH(1)]]
  [TB
    (66,67,73,83,90) [KIH]
    (68)  [KDH]
    (70)  [KFH]
    (74)  [KJH]
    (99)  [RSH]
    (101) [RSH RUH]
    (115) [RUH]
    (91)  [NH[(0)]]
    (64)  [RSH NH[RUH(0)]]
    ()    []
    ]
</code></pre>
<p>Both visible and invisible annotations use this layout. The second callable describes an <code>annotation</code> structure from the metadata specification. The third callable describes a <code>element_value</code> structure from the metadata specification. This last callable, all by itself, is used for the <code>AnnotationDefault</code> attribute on methods. Method parameter annotations (both visible and invisible) are also predefined using this layout, with a prepended callable to count the number of parameters:</p>
<pre class="codeblock"><code>
  [NB[(1)]]
  [NH[(1)]]
  [RSH NH[RUH(1)]]
  [TB...]
</code></pre>
<p><br />
Additionally RuntimeVisibleTypeAnnotation and RuntimeInvisibleTypeAnnotation are predefined, using similar strategies as before. Both visible and invisible type annotations use a common layout. (They were defined by JSR 308).</p>
<pre class="codeblock"><code>
  [NH[(1)(2)(3)]]
  [TB
    (0-1)            [B]
    (16)             [FH]
    (17-18)          [BB]
    (19-21)          []
    (22)             [B]
    (23)             [H]
    (64-65)          [NH[PHOHH]]
    (66)             [H]
    (67-70)          [PH]
    (71-75)          [PHB]
    ()               []
    ]
   [NB[BB]]
   [RSH NH[RUH(1)]]
   [TB...]</code></pre>
<p>The first callable defines the <code>type_annotation</code> as a whole. The second callable refers to <code>target_type</code> and <code>target_info</code> union structure, and the third callable refers to <code>target_path</code> structure. The remaining callables are identical with layouts specified above for metadata. Specifically the fourth and the fifth callables refers to the <code>annotation</code> and <code>element_value</code> structures specified for metadata. (These were defined in the JSR 175 specification). Like the previous metadata layouts, these type metadata layouts are predefined in the compressor, and are applicable to Class, Field, Method, and also Code structures.</p>
<h5 id="unusual-layout-usages">5.5.7. Unusual Layout Usages</h5>
<p>It is possible for the compressor to emit any number of definitions for the same attribute name. These definitions are assigned different attribute indexes (and perhaps flag bits), and are treated as distinct attributes, despite having the same name. If an attribute is too complex to define in the layout language, each occurrence of that attribute can be given a separate definition by the compressor. The minimum requirement is that each layout accurately declare the size of the corresponding attribute occurrence, and locate all constant pool references within that occurrence.</p>
<h4 id="source-file-abbreviation">5.6. Source File Abbreviation</h4>
<p>When a null reference is transmitted in the band governed by the predefined <code>SourceFile</code> attribute, the decompressor is required to replace it by a reference to a Utf8 string whose spelling consists of the associated class name string, with the following modifications made, in order:</p>
<ul>
<li>Every character up to and including the last slash or dot ('/' or '.') is removed. (This removes any package prefix.)</li>
<li>If there is a character of code 0x2D or lower in the remaining string, the first such and all following characters are removed. (This removes any nested class name mangling.)</li>
<li>The suffix characters &quot;.java&quot; are appended.</li>
</ul>
<p>This rule matches the historical behavior of many Java compilers, and allows the compressor to avoid allocating Utf8 strings for &quot;obvious&quot; derived <code>SourceFile</code> names. (If a compressor needs to transmit an irregular <code>SourceFile</code> attribute with a true null reference, it must use a non-standard layout.) Here is a table of examples of class names and the corresponding derived <code>SourceFile</code> names.</p>
<table>
<caption style="display:none">
examples of prediction, nonprediction, and misprediction
</caption>
<tr style="text-align:center">
<th id="derived_names_c">
Class
</th>
<th id="derived_names_s">
<code>SourceFile</code>
</th>
</tr>
<tr>
<td headers="derived_names_c">
foo
</td>
<td headers="derived_names_s">
foo.java
</td>
</tr>
<tr>
<td headers="derived_names_c">
foo/bar
</td>
<td headers="derived_names_s">
bar.java
</td>
</tr>
<tr>
<td headers="derived_names_c">
foo/bar$baz
</td>
<td headers="derived_names_s">
bar.java
</td>
</tr>
<tr>
<td headers="derived_names_c">
foo/bar#baz#1
</td>
<td headers="derived_names_s">
bar.java
</td>
</tr>
<tr>
<td headers="derived_names_c">
foo.bar.baz#1
</td>
<td headers="derived_names_s">
baz.java
</td>
</tr>
</table>
<h4 id="nested-classes">5.7. Nested Classes</h4>
<p>A nested class record is a four-tuple specifying two classes, a name, and some flags, as documented for the <code>InnerClasses</code> attribute of class files. It is primarily represented in the Pack200 archive by four bands, whose contents are applied equally to all class files in the archive.</p>
<pre class="codeblock"><code>  ic_bands:
        *ic_this_class :UDELTA5 [#ic_count] (cp_Class)
        *ic_flags :UNSIGNED5 [#ic_count]
        *ic_outer_class :DELTA5 [COUNT(1&lt;&lt;16,...)]  (null or cp_Class)
        *ic_name :DELTA5 [LENGTH(*ic_outer_class)] (null or cp_Utf8)
</code></pre>
<p>These four-tuples are shared globally, like constant pool entries. In this specification, they are conventionally written <code>&lt;C,F,C2,N&gt;</code>, even though they are stored in a different order in the class file format. As a set, these globally defined four-tuples are called <code>ic_All</code>. There is usually no explicit linkage from individual classes in the archive to nested class records. Instead, when extracting a class file from a Pack200 archive, an subset of nested class records may be selected which is sufficient to describe all nested classes actually mentioned in the extracted class file's constant pool. For any class file X to be extracted, this subset will be called <code>ic_Relevant(X)</code>, the <em>relevant subset</em> for X of <code>ic_All</code>. The algorithm for selecting the relevant subset is described in the section <a href="#ordering-of-constant-pools">Ordering of Constant Pools</a>. Optionally, the compressor can specify, for any given class, an adjustment to its relevant subset, by transmitting a local <code>InnerClasses</code> attribute. This also is described in the section <a href="#local-innerclasses-attributes">Local InnerClasses Attributes</a>.</p>
<p>The <code>ic_this_class</code> and <code>ic_flags</code> bands are both of length <code>#ic_count</code>, and the corresponding elements of these bands specify, for each tuple, the nested class identity (represented as a <code>cp_Class</code> reference) and the flags bitmask.</p>
<p><a id="explicit_outer"></a></p>
<p>The nested class flag bit at position 16 (as set in the mask 0x00010000) is inside the archive file to indicate if there are corresponding entries for the tuple in the <code>ic_outer_class</code> and <code>ic_name</code> bands. Thus, the length of both of these bands is the sum of all flag bits at position 16. Typically, only a few percent of nested classes need to set this bit and specify outer and name fields explicitly.</p>
<p>If a tuple has an entry in the <code>ic_outer_class</code> and <code>ic_name</code> bands, these specify its outer class and simple name. (They are represented respectively as a possibly null <code>cp_Class</code> reference and a possibly null <code>cp_Utf8</code> reference.) Otherwise, the tuple's outer class and name are said to be <em>predicted</em>. In this case, they must be correctly predictable from the name of the nested class itself, by parsing its spelling.</p>
<p><a id="icn_psc_ref"></a></p>
<p>A nested class has a <em>bytecode name</em> which names the class within class files. The spelling of this name, sometimes called a &quot;mangled name&quot;, has extra punctuation signs and perhaps digits as well as the name of a containing class. If the bytecode name can be parsed into an outer class and a class name, and this class and name are identical with the true outer class and class name of the nested class, then we say the outer class and class name are <em>predictable</em>.</p>
<p>The extraction of the predictable outer class and class name must follow the following grammar for class bytecode names, as applied to the spelling of the nested class name. (This grammar is independent of the grammar governing band structure, or any other grammar appearing in other parts of this specification.) The terminal DOLLAR refers to any character (such as '$' or '#') whose code is 0x2D or lower. The terminals SLASH refers to the slash or dot characters '/' or '.', which have the codes 0x2E and 0x2F. The terminal DIGIT refers to an ASCII decimal digit, one of the ten character codes from 0x30 to 0x39 inclusive. The terminal LETTER refers to any other character. That is, it refers to any character whose code is 0x3A or higher.</p>
<pre class="codeblock"><code>  bcn:
        (bcnCase1 | bcnCase2 | bcnCase3 | bcnCase4)
  bcnCase1:
        packageQual (namePart)? DOLLAR number
  bcnCase2:
        packageQual (namePart)? DOLLAR number DOLLAR predictableICName
  bcnCase3:
        predictableOuter DOLLAR predictableICName
  bcnCase4:
        packageQual (namePart)?

  predictableOuter:
        packageQual namePart
  predictableICName:
        LETTER (LETTER | DIGIT)*

  namePart:
        (LETTER | DIGIT | DOLLAR)+
  number:
        (DIGIT)+
  packageQual:
        (namePart SLASH)*
</code></pre>
<p>This grammar ambiguously divides an arbitrary class name into several parts, which may include an optional <em>predictedOuter</em> prefix, an optional <em>predictedICName</em> suffix, and a optional numeric suffix. Any ambiguity must be resolved by preferring the alternative cases for <code>bcn</code> nonterminal in the order given. E.g., if <code>bcnCase1</code> matches, it is used, even though either or both other cases may match also.</p>
<p>The predictable nested class name is the string corresponding to the <code>predictableICName</code> nonterminal, if it was parsed. Otherwise the predictable nested class name is taken to be null.</p>
<p>If a <code>predictableOuter</code> outer nonterminal is parsed, the corresponding string is the predictable outer class name. Otherwise the predictable outer class reference is taken to be null. Note that if a <code>number</code> nonterminal is parsed, no <code>predictableOuter</code> can be parsed. Here are some examples of prediction, nonprediction, and misprediction:</p>
<h3 id="inner-class-prediction-examples">Inner Class Prediction Examples</h3>
<h4 id="example-1">Example 1</h4>
<table>
<caption style="display:none">
inner class prediction example 1
</caption>
<tr>
<td headers="ic_prediction_ic_ex1" style="text-align:right">
nested class:
</td>
<td headers="ic_prediction_ic_ex1">
member named <code>Entry</code> of <code>java/util/Map</code>
</td>
</tr>
<tr>
<td headers="ic_prediction_ic_ex1" style="text-align:right">
mangled name:
</td>
<td headers="ic_prediction_ic_ex1">
<code>java/util/Map$Entry</code>
</td>
</tr>
<tr>
<td headers="ic_prediction_ic_ex1" style="text-align:right">
outer, name:
</td>
<td headers="ic_prediction_ic_ex1">
<code>java/util/Map</code>, <code>Entry</code>
</td>
</tr>
<tr>
<td headers="ic_prediction_ic_ex1" style="text-align:center">
predictable?
</td>
<td headers="ic_prediction_ic_ex1">
yes (since <code>Map.Entry</code> is a member of <code>Map</code>)
</td>
</table>
<h4 id="example-2">Example 2</h4>
<table>
<caption style="display:none">
inner class prediction example 2
</caption>
<tr>
<td headers="ic_prediction_ic_ex2" style="text-align:right">
nested class:
</td>
<td headers="ic_prediction_ic_ex2">
anonymous
</td>
</tr>
<tr>
<td headers="ic_prediction_ic_ex2" style="text-align:right">
mangled name:
</td>
<td headers="ic_prediction_ic_ex2">
<code>java/util/AbstractList$1</code>
</td>
</tr>
<tr>
<td headers="ic_prediction_ic_ex2" style="text-align:right">
outer, name:
</td>
<td headers="ic_prediction_ic_ex2">
<em>(none)</em>, <em>(none)</em>
</td>
</tr>
<tr>
<td headers="ic_prediction_ic_ex2" style="text-align:center">
predictable?
</td>
<td headers="ic_prediction_ic_ex2">
yes (since the ic_name is null)
</td>
</tr>
</table>
<h4 id="example-3">Example 3</h4>
<table>
<caption style="display:none">
inner class prediction example 3
</caption>
<tr>
<td headers="ic_prediction_ic_ex3" style="text-align:right">
nested class:
</td>
<td headers="ic_prediction_ic_ex3">
non-member, named <code>Local</code>
</td>
</tr>
<tr>
<td headers="ic_prediction_ic_ex3" style="text-align:right">
mangled name:
</td>
<td headers="ic_prediction_ic_ex3">
<code>java/util/AbstractList\$2\$Local</code>
</td>
</tr>
<tr>
<td headers="ic_prediction_ic_ex3" style="text-align:right">
outer, name:
</td>
<td headers="ic_prediction_ic_ex3">
<em>(none)</em>, <code>Local</code>
</td>
</tr>
<tr>
<td headers="ic_prediction_ic_ex3" style="text-align:center">
predictable?
</td>
<td headers="ic_prediction_ic_ex3">
yes (since the ic_name is <code>Local</code>)
</td>
</tr>
</table>
<h4 id="example-4">Example 4</h4>
<table>
<caption style="display:none">
inner class prediction example 4
</caption>
<tr>
<td headers="ic_prediction_ic_ex4" style="text-align:right">
nested class:
</td>
<td headers="ic_prediction_ic_ex4">
non-member, named <code>Local</code>
</td>
</tr>
<tr>
<td headers="ic_prediction_ic_ex4" style="text-align:right">
mangled name:
</td>
<td headers="ic_prediction_ic_ex4">
<code>java/util/AbstractList#2#Local</code>
</td>
</tr>
<tr>
<td headers="ic_prediction_ic_ex4" style="text-align:right">
outer, name:
</td>
<td headers="ic_prediction_ic_ex4">
<em>(none)</em>, <code>Local</code>
</td>
</tr>
<tr>
<td headers="ic_prediction_ic_ex4" style="text-align:center">
predictable?
</td>
<td headers="ic_prediction_ic_ex4">
yes (since the ic_name is <code>Local</code>)
</td>
</tr>
</table>
<h4 id="example-5">Example 5</h4>
<table>
<caption style="display:none">
inner class prediction example 5
</caption>
<tr>
<td headers="ic_prediction_ic_ex5" style="text-align:right">
nested class:
</td>
<td headers="ic_prediction_ic_ex5">
member named <code>\$2\$Local</code> of <code>Foo</code>
</td>
</tr>
<tr>
<td headers="ic_prediction_ic_ex5" style="text-align:right">
mangled name:
</td>
<td headers="ic_prediction_ic_ex5">
<code>Foo\$\$2$Local</code>
</td>
</tr>
<tr>
<td headers="ic_prediction_ic_ex5" style="text-align:right">
outer, name:
</td>
<td headers="ic_prediction_ic_ex5">
<em>(none)</em>, <code>Local</code>
</td>
</tr>
<tr>
<td headers="ic_prediction_ic_ex5" style="text-align:center">
predictable?
</td>
<td headers="ic_prediction_ic_ex5">
no (outer name missing, ic_name mispredicted)
</td>
</tr>
</table>
<h4 id="example-6">Example 6</h4>
<table>
<caption style="display:none">
inner class prediction example 6
</caption>
<tr>
<td headers="ic_prediction_ic_ex6" style="text-align:right">
nested class:
</td>
<td headers="ic_prediction_ic_ex6">
class named <code>Red\$Herring</code>
</td>
</tr>
<tr>
<td headers="ic_prediction_ic_ex6" style="text-align:right">
mangled name:
</td>
<td headers="ic_prediction_ic_ex6">
<code>Red\$Herring</code>
</td>
</tr>
<tr>
<td headers="ic_prediction_ic_ex6" style="text-align:right">
outer, name:
</td>
<td headers="ic_prediction_ic_ex6">
<code>Red</code>, <code>Herring</code>
</td>
</tr>
<tr>
<td headers="ic_prediction_ic_ex6" style="text-align:center">
predictable?
</td>
<td headers="ic_prediction_ic_ex6">
no (the predicted ic_name Herring)
</td>
</tr>
</table>
<h4 id="example-7">Example 7</h4>
<table>
<caption style="display:none">
inner class prediction example 7
</caption>
<tr>
<td headers="ic_prediction_ic_ex7" style="text-align:right">
nested class:
</td>
<td headers="ic_prediction_ic_ex7">
member named <code>Q</code> of <code>X$1</code>
</td>
</tr>
<tr>
<td headers="ic_prediction_ic_ex7" style="text-align:right">
mangled name:
</td>
<td headers="ic_prediction_ic_ex7">
<code>X\$1\$Q</code>
</td>
</tr>
<tr>
<td headers="ic_prediction_ic_ex7" style="text-align:right">
outer, name:
</td>
<td headers="ic_prediction_ic_ex7">
<em>(none)</em>, <code>Q</code>
</td>
</tr>
<tr>
<td headers="ic_prediction_ic_ex7" style="text-align:center">
predictable?
</td>
<td headers="ic_prediction_ic_ex7">
no (since <code>Q</code> is a member of <code>X$1</code>)
</td>
</tr>
</table>
<h4 id="example-8">Example 8</h4>
<table>
<caption style="display:none">
inner class prediction example 8
</caption>
<tr>
<td headers="ic_prediction_ic_ex8" style="text-align:right">
nested class:
</td>
<td headers="ic_prediction_ic_ex8">
member named <code>Z</code> of <code>X\$Y</code>
</td>
</tr>
<tr>
<td headers="ic_prediction_ic_ex8" style="text-align:right">
mangled name:
</td>
<td headers="ic_prediction_ic_ex8">
<code>X\$Y\$Z</code>
</td>
</tr>
<tr>
<td headers="ic_prediction_ic_ex8" style="text-align:right">
outer, name:
</td>
<td headers="ic_prediction_ic_ex8">
<code>X\$Y</code>, <code>Z</code>
</td>
</tr>
<tr>
<td headers="ic_prediction_ic_ex8" style="text-align:center">
predictable?
</td>
<td headers="ic_prediction_ic_ex8">
yes (since X$Y.Z is a member of X$Y)
</td>
</tr>
</table>
<h4 id="example-9">Example 9</h4>
<table>
<caption style="display:none">
inner class prediction example 9
</caption>
<tr>
<td headers="ic_prediction_ic_ex9" style="text-align:right">
nested class:
</td>
<td headers="ic_prediction_ic_ex9">
member named <code>Y\$Z</code> of <code>X</code>
</td>
</tr>
<tr>
<td headers="ic_prediction_ic_ex9" style="text-align:right">
mangled name:
</td>
<td headers="ic_prediction_ic_ex9">
<code>X\$Y\$Z</code>
</td>
</tr>
<tr>
<td headers="ic_prediction_ic_ex9" style="text-align:right">
outer, name:
</td>
<td headers="ic_prediction_ic_ex9">
<code>X\$Y</code>, <code>Z</code>
</td>
</tr>
<tr>
<td headers="ic_prediction_ic_ex9" style="text-align:center">
predictable?
</td>
<td headers="ic_prediction_ic_ex9">
no (outer name and ic_name are mispredicted)
</td>
</tr>
</table>
<p>When a decompressor is processing a nested class name marked &quot;predictable&quot;, it must parse the nested class's bytecode name into an enclosing class, an optional number, and an optional name. (The compressor might choose to always specify outer classes and names explicitly, in which case the decompressor would not be required to parse the nested class names at all. However, decompressors must always be prepared to perform this parsing.)</p>
<p>If the compressor did not transmit an entry in <code>cp_Utf8</code> or <code>cp_Class</code> for a predicted name or outer class, the decompressor must create such a constant internally. It will be referred to as a <code>cp_Utf8</code> or <code>cp_Class</code> entry, even though it is not in the constant transmission sequence <code>cp_All</code>. However, if the compressor did transmit a constant with the same spelling as the predicted name or outer class, the decompressor must use that constant rather than creating a new one. The creation of such internal constants within the decompressor is detectable in an output file because they are inserted in a special order in the output file's constant pool. (See discussion of the output ordering rules in the section <a href="#ordering-of-constant-pools">Ordering of Constant Pools</a>.)</p>
<p>Please see the Appendix section <a href="#representation-of-predictable-nested-class-names">Representation of Byte Offsets</a> for pseudo-code explaining this concept.</p>
<p>When the decompressor receives the <code>ic_this_class</code>, <code>ic_flags</code>, <code>ic_name</code>, and <code>ic_outer_class</code> bands, and performs any required name parsing, it creates the set <code>ic_All</code> of four-tuples. This set is the primary source of <code>InnerClasses</code> attributes synthesized for individual class files by the decompressor.</p>
<h4 id="class-schema">5.8. Class Schema</h4>
<p>The purpose of the Pack200 archive is to transmit a set of classes in a form which a decompressor can later use to reconstruct class files. As a rule, each separate kind of data stored in class files is transmitted in a band dedicated to all values of that kind. Here is the band structure for all class-specific information except bytecodes:</p>
<pre class="codeblock"><code>  class_bands:
        *class_this :DELTA5 [#class_count] (cp_Class)
        *class_super :DELTA5 [#class_count] (cp_Class)
        *class_interface_count :DELTA5 [#class_count]
        *class_interface :DELTA5 [SUM(*class_interface_count)] (cp_Class)
        *class_field_count :DELTA5 [#class_count]
        *class_method_count :DELTA5 [#class_count]

        *field_descr :DELTA5 [SUM(*class_field_count)] (cp_Descr)
        field_attr_bands

        *method_descr :MDELTA5 [SUM(*class_method_count)] (cp_Descr)
        method_attr_bands

        class_attr_bands
        code_bands
</code></pre>
<p>The <code>class_this</code>, <code>class_super</code>, <code>class_flags_lo</code>, <code>class_flags_hi</code> (if present), <code>class_interface_count</code>, <code>class_field_count</code>, and <code>class_method_count</code> bands are all of length <code>#class_count</code>, and the corresponding elements of these bands transmit in turn each class's name and super-class, and the number of implemented interfaces, declared fields, and declared methods. (The access modifier bits in each class's flags word are mixed with attribute indicators, and are transmitted in <code>class_flags_lo</code>, as defined above.)</p>
<p>The <code>class_interface</code> band contains runs of class interface declarations, one run for each element of <code>class_interface_count</code>, and applying to the corresponding class.</p>
<p>Each element of <code>class_this</code>, <code>class_super</code>, and <code>class_interface</code> is a reference (in fact, a non-null reference) to the constant pool <code>cp_Class</code>.</p>
<p>In the unique case of <code>java/lang/Object</code>, the stored super-class must be a null reference. Rather than disturbing the transmission of all other elements of the <code>class_super</code> band, we use the convention that a compressor, when it encounters a null super-class reference, must transmit in its place a duplicate of the current class's reference. (Since it is illegal for a class to inherit from itself, this renumbering of null references is unambiguous.)</p>
<p>The <code>field_descr</code> bands contain one run of elements for each element of <code>class_field_count</code>, and apply to successive fields in the corresponding class. The <code>method_descr</code> bands contain one run of elements for each element of <code>class_method_count</code>, and apply to successive methods in the corresponding class.</p>
<p>(Unlike the class file format, field and method descriptors are stored as single references to a &quot;name-and-type&quot; constant pool, rather than as pairs of name references and type references.)</p>
<p>The <code>method_descr</code> band has a primary encoding which performs best if the method references are mostly sorted. Compressors may elect to take advantage of this fact by sorting the methods in each class. (Note: It is generally acceptable for compressors to reorder methods for best compression, but fields must not be reordered, since their order is apparent through reflection and significant to some facilities, such as serialization.)</p>
<p>Attribute bands are placed in the positions indicated by the grammar. They are described below. The attribute bands include flags bands, which carry both access modifiers and attribute indicators for the corresponding classes, fields, and methods.</p>
<p>The Pack200 archive ends with bands devoted to method code blocks and the bytecodes themselves. If a method has a code attribute, the compressor must mention it in the flags bit (the 6th LSB) to which it is assigned, or as an overflow attribute (with an index of 6). The fields of a Code attribute are transmitted in the bands organized under the <code>code_bands</code> nonterminal.</p>
<p>The specification of each Code attribute begins with three key parameters, which declare the number of stack and local slots, and the number of handlers. <code>#Stack</code> is the number of stack slots used by the code. <code>#NALocal</code> is the number of non-argument locals used by the code. (The actual number of locals declared in the class file will be <code>#NALocal</code> plus the number of locals required by method parameters, as determined by the method's signature.) <code>#Handler</code> is the number of exception handlers.</p>
<p><a id="code_headers"></a></p>
<p>The <code>code_headers</code> band contains a series of bytes, each of which tersely encodes the first three key parameters of a code attribute: Each of the 255 non-zero byte values encodes a unique triple of <code>#NALocal</code>, <code>#Stack</code>, and <code>#Handler</code>. There is (of course) one code header for each Code attribute transmitted.</p>
<p>The special code header byte zero (0x00) indicates that the code attribute's three parameters are to be found, instead, in the <code>code_max_stack</code>, <code>code_max_na_locals</code>, and <code>code_handler_count</code> bands. If the code header byte is non-zero, these three bands do not transmit entries for the corresponding Code attribute.</p>
<p>The <code>code_flags_lo</code> band transmits an entry for a corresponding <code>Code</code> attribute if and only if one or both of the following is true: the Code attribute's code header byte is zero, or the <code>have_all_code_flags</code> bit is set in the <code>#archive_options</code> word. If a <code>Code</code> attribute does not have a transmitted <code>code_flags_lo</code> value, its flags word is taken to be zero, and it has no sub-attributes. The <code>code_flags_hi</code> band transmits a corresponding entry if and only if the <code>code_flags_lo</code> value was transmitted as just described, and also <code>#have_code_flags_hi</code> is set.</p>
<p>Non-zero code header bytes denote code attribute parameters according to the following scheme:</p>
<table>
<caption style="display:none">
&quot;bands that transmit appropriately-typed constant pool references
</caption>
<tr style="text-align:center">
<th id="typed_cp_h">
Header Range
</th>
<th id="typed_cp_s">
#Stack
</th>
<th id="typed_cp_n">
#NALocal
</th>
<th id="typed_cp_h1">
#Handler
</th>
</tr>
<tr>
<td headers="typed_cp_h">
1 &lt;= x &lt;= 144
</td>
<td headers="typed_cp_s">
(x-1) % 12
</td>
<td headers="typed_cp_n">
(x-1) / 12
</td>
<td headers="typed_cp_h1">
0
</td>
</tr>
<tr>
<td headers="typed_cp_h">
145 &lt;= x &lt;= 208
</td>
<td headers="typed_cp_s">
(x-145) % 8
</td>
<td headers="typed_cp_n">
(x-145) / 8
</td>
<td headers="typed_cp_h1">
1
</td>
</tr>
<tr>
<td headers="typed_cp_h">
209 &lt;= x &lt;= 255
</td>
<td headers="typed_cp_s">
(x-209) % 7
</td>
<td headers="typed_cp_n">
(x-209) / 7
</td>
<td headers="typed_cp_h1">
2
</td>
</tr>
<tr>
<td headers="typed_cp_h">
x = 0
</td>
<td headers="typed_cp_s">
<code>code_max_stack</code>
</td>
<td headers="typed_cp_n">
<code>code_max_na_locals</code>
</td>
<td headers="typed_cp_h1">
<code>code_handler_count</code>
</td>
</tr>
</table>
<p>This scheme allows a single byte to describe a Code attribute in about 95% of all cases. (Note: If debugging attributes are not stripped, the compressor should probably set the <code>have_all_code_flags</code> bit, so that the presence of these attributes will not force the use of the special zero code header byte.)</p>
<p>Regardless of whether the exception handler count is encoded in the one-byte code header, or whether it is an explicit element of <code>code_handler_count</code>, for each code attribute there is a run of values in <code>code_handler_start_P</code>, <code>code_handler_end_PO</code>, <code>code_handler_catch_PO</code>, and <code>code_handler_class_RCN</code>, one for each handler, as if those bands were governed by an attribute layout <code>'NV[PHPOHPOHRCNH]'</code> (there is no band governed by the <code>'NV'</code> layout element itself; it is the handler count).</p>
<p>That is, each triplet of <code>Handler.start</code>, <code>Handler.end</code>, and <code>Handler.catch</code> values are transmitted as renumbered (by <em>renumber_bci</em>). Also, <code>Handler.end</code> is transmitted as a difference of its renumbering with that of <code>Handler.start</code> in the same triplet, and <code>Handler.catch</code> is transmitted as a difference of its renumbering with that of <code>Handler.end</code> in the same triplet. Finally, <code>code_handler_class_RCN</code> is transmitted as an incremented reference into <code>cp_Class</code>, or zero if the handler class reference is null.</p>
<pre class="codeblock"><code>  code_bands:
        *code_headers :BYTE1 [COUNT(Code,...)]

        *code_max_stack :UNSIGNED5 [COUNT(0,*code_headers)]
        *code_max_na_locals :UNSIGNED5 [COUNT(0,*code_headers)]

        *code_handler_count :UNSIGNED5 [COUNT(0,*code_headers)]
        *code_handler_start_P :BCI5 [SUM(*code_handler_count)]
        *code_handler_end_PO :BRANCH5 [SUM(*code_handler_count)]
        *code_handler_catch_PO :BRANCH5 [SUM(*code_handler_count)]
        *code_handler_class_RCN :UNSIGNED5 [SUM(*code_handler_count)] (null or cp_Class)

        code_attr_bands
</code></pre>
<h4 id="attribute-bands">5.9. Attribute Bands</h4>
<p>Here, collected in one place, are the bands which transmit attributes. If the compressor sets bits in the flags word of a class, field, or method, and those bits are assigned (by the compressor) to attributes, then the compressor must also retrieve the stored values governed by each selected attribute layout and transmit them in the bands governed by that layout.</p>
<p><a id="overflow_bits"></a></p>
<p>If the compressor marks a class (resp. field, method, or code) as having overflow attributes, it must transmit a corresponding element in the <code>class_attr_count</code> band (resp. <code>field_attr_count</code>, <code>method_attr_count</code>, or <code>code_attr_count</code> band). This count, in turn, specifies the size of a run in <code>class_attr_indexes</code> (resp. <code>field_attr_indexes</code>, <code>method_attr_indexes</code>, or <code>code_attr_indexes</code>) of indexes of attribute layouts governing attributes of the class (resp. field, method, or code). The compressor must transmit a attribute layout definition index for each overflow attribute.</p>
<p>For each attribute layout selected by a bit in an element of <code>class_flags</code> or by an element of <code>class_attr_indexes</code>, the compressor must retrieve data governed by the layout elements from the class attribute and transmit elements encoding this data in the bands governed by the layout. Similar conditions apply for field, method, and code attributes.</p>
<p>For each attribute layout that transmits data and contains backward calls, the compressor must transmit the number of times each backward callable will be the subject of a backward call as the decompressor works its way through attribute layouts. These call counts are transmitted in the <code>class_attr_calls</code>, <code>field_attr_calls</code>, <code>method_attr_calls</code>, and <code>code_attr_calls</code> bands, according to the context type of the layouts they apply to. The call counts are transmitted, one per backward callable, in the definition order of the callables. (See the section <a href="#def_order">Attribute Layout Definitions</a>.) Call counts are only transmitted for backward callables which occur within layouts that are used at least once. Call counts do <em>not</em> count entries to any callable because of a forward call, nor do they count the initial call to a callable which initiates attribute processing. A call count might be zero if a backward callable occurs in a layout that is used, but which does not happen to reach the backward callable. These call counts are needed to break a circularity inherent in the sizing of bands for mutually-recursive layouts. They provide the minimum information necessary for the decompressor to locate all the bands in the archive, prior to distributing the band values to the various output classes. For this reason, the call counts are supplied one per layout, summed over all attribute occurrences of that each layout.</p>
<p>The decompressor is responsible for processing any explicit attribute layout definitions transmitted by the compressor. It must prepare to receive the additional bands governed by those layouts. When it reads layout definition indexes, it must prepare to read in the correct number of values transmitted in each of those additional bands.</p>
<p>The grammar of bands defined in this specification includes bands governed by all predefined attribute layouts. For clarity, some band names mention a part of the layout element that created them. Note that the Deprecated attributes have no bands, because their layouts are empty.</p>
<p>Attributes named &quot;Synthetic&quot;, although part of the standard class file format in earlier versions of Java, are not directly supported in this specification, because that attribute has been replaced by a new flag bit (ACC_SYNTHETIC, 0x1000) in more recent versions of Java. However, compressors are encouraged to process Synthetic attributes, and any other zero-length attributes not predefined here, by assigning them unused flag bits, and emitting explicit zero-length layout definitions for decompressors to follow.</p>
<p>If the compressor elects to define new layouts, the bands governed by those layouts are added immediately after the bands for the predefined layouts. (The order and structure of the predefined attribute bands reflects the predefined layout definitions in a regular way, as if the compressor had in fact defined them explicitly.)</p>
<pre class="codeblock"><code>
  class_attr_bands:
        *class_flags_hi :UNSIGNED5 [#class_count*#have_class_flags_hi]
        *class_flags_lo :UNSIGNED5 [#class_count]
        *class_attr_count :UNSIGNED5 [COUNT(1&lt;&lt;16,...)]
        *class_attr_indexes :UNSIGNED5 [SUM(*class_attr_count)]
        *class_attr_calls :UNSIGNED5 [...]
        *class_SourceFile_RUN :UNSIGNED5 [COUNT(SourceFile,...)] (null or cp_Utf8)
        *class_EnclosingMethod_RC :UNSIGNED5 [COUNT(EnclosingMethod,...)] (cp_Class)
        *class_EnclosingMethod_RDN :UNSIGNED5 [COUNT(EnclosingMethod,...)] (null or cp_Descr)
        *class_Signature_RS :UNSIGNED5 [COUNT(Signature,..)] (cp_Signature)
        class_metadata_bands
        ic_local_bands
        *class_file_version_minor_H :UNSIGNED5 [COUNT(version,...)]
        *class_file_version_major_H :UNSIGNED5 [COUNT(version,...)]
        {class_attr_element_bands...}

  field_attr_bands:
        *field_flags_hi :UNSIGNED5 [SUM(*class_field_count)*#have_field_flags_hi]
        *field_flags_lo :UNSIGNED5 [SUM(*class_field_count)]
        *field_attr_count :UNSIGNED5 [COUNT(1&lt;&lt;16,...)]
        *field_attr_indexes :UNSIGNED5 [SUM(*field_attr_count)]
        *field_attr_calls :UNSIGNED5 [...]
        *field_ConstantValue_KQ :UNSIGNED5 [COUNT(ConstantValue,...)] (cp_Int, etc.; see note)
        *field_Signature_RS :UNSIGNED5 [COUNT(Signature,...)] (cp_Signature)
        field_metadata_bands

  method_attr_bands:
        *method_flags_hi :UNSIGNED5 [SUM(*class_method_count)*#have_method_flags_hi]
        *method_flags_lo :UNSIGNED5 [SUM(*class_method_count)]
        *method_attr_count :UNSIGNED5 [COUNT(1&lt;&lt;16,...)]
        *method_attr_indexes :UNSIGNED5 [SUM(*method_attr_count)]
        *method_attr_calls :UNSIGNED5 [...]
        *method_Exceptions_N :UNSIGNED5 [COUNT(Exceptions,...)]
        *method_Exceptions_RC :UNSIGNED5 [SUM(*method_Exceptions_N)] (cp_Class)
        *method_Signature_RS :UNSIGNED5 [COUNT(Signature,...)] (cp_Signature)
        method_metadata_bands
        *method_MethodParameters_NB :BYTE1 [...]
        *method_MethodParameters_name_RUN :UNSIGNED5 [...] (null or cp_Utf8)
        *method_MethodParameters_flag_FH :UNSIGNED5 [...] (flag)
        {method_attr_element_bands...}

  code_attr_bands:
        *code_flags_hi :UNSIGNED5 [...*#have_code_flags_hi]
        *code_flags_lo :UNSIGNED5 [...]
        *code_attr_count :UNSIGNED5 [COUNT(1&lt;&lt;16,...)]
        *code_attr_indexes :UNSIGNED5 [SUM(*code_attr_count)]
        *code_attr_calls :UNSIGNED5 [...]
        *code_StackMapTable_N :UNSIGNED5 [COUNT(StackMapTable,...)]
        *code_StackMapTable_frame_T :BYTE1 [SUM(*code_StackMapTable_N)]
        *code_StackMapTable_local_N :UNSIGNED5 [COUNT(255,*code_StackMapTable_frame_T)]
        *code_StackMapTable_stack_N :UNSIGNED5 [COUNT(255,*code_StackMapTable_frame_T)]
        *code_StackMapTable_offset :UNSIGNED5 [...]
        *code_StackMapTable_T :BYTE1 [...]
        *code_StackMapTable_RC :UNSIGNED5 [COUNT(7,*code_StackMapTable_T)]
        *code_StackMapTable_P :BCI5 [COUNT(8,*code_StackMapTable_T)]
        *code_LineNumberTable_N :UNSIGNED5 [...]
        *code_LineNumberTable_bci_P :BCI5 [...]
        *code_LineNumberTable_line :UNSIGNED5 [...]
        *code_LocalVariableTable_N :UNSIGNED5 [...]
        *code_LocalVariableTable_bci_P :BCI5 [...]
        *code_LocalVariableTable_span_O :BRANCH5 [...]
        *code_LocalVariableTable_name_RU :UNSIGNED5 [...] (cp_Utf8)
        *code_LocalVariableTable_type_RS :UNSIGNED5 [...] (cp_Signature)
        *code_LocalVariableTable_slot :UNSIGNED5 [...]
        *code_LocalVariableTypeTable_N :UNSIGNED5 [...]
        *code_LocalVariableTypeTable_bci_P :BCI5 [...]
        *code_LocalVariableTypeTable_span_O :BRANCH5 [...]
        *code_LocalVariableTypeTable_name_RU :UNSIGNED5 [...] (cp_Utf8)
        *code_LocalVariableTypeTable_type_RS :UNSIGNED5 [...] (cp_Signature)
        *code_LocalVariableTypeTable_slot :UNSIGNED5 [...]
        {code_attr_element_bands...}
</code></pre>
<p><a id="special_version_number"></a></p>
<p>A class possesses a &quot;class-file version&quot; pseudo-attribute if its class file's minor or major version differs from the <code>#default_class_minver</code> or <code>#default_class_majver</code>, respectively. This pseudo-attribute is a pair of 16-bit integers giving the major and minor version numbers of the class's file. These integers are stored in the header of the class's file, rather than in an attribute record. As is the convention with classfiles, the minor version number comes first. Thus minor version numbers are transmitted in the band <code>class_file_version_minor_H</code>, and major version numbers in <code>class_file_version_major_H</code>. Decompressors are not required to process archives with greater minor or major version numbers than those of the specification they were engineered to process. Decompressors are required to process archives with the same major and smaller or equal minor version numbers.</p>
<h5 id="local-innerclasses-attributes">Local InnerClasses Attributes</h5>
<p>A transmitted class may possess a local <code>InnerClasses</code> attribute, which is taken to be an <em>adjustment</em> to that class file's eventually written <code>InnerClasses</code> attribute. Specifically, the local <code>InnerClasses</code> attribute specifes a set of four-tuples which must be combined with a corresponding relevant subset drawn from <code>ic_All</code>. The algorithm for doing this is described in the section <a href="#ordering-of-constant-pools">Ordering of Constant Pools</a>, but it amounts to starting with the subset of four-tuples from <code>ic_All</code> which pertain to CONSTANT_Class entries of the output constant pool (barring CONSTANT_Class entries required only by the <code>InnerClasses</code> attribute itself), and then forming the set symmetric difference between that relevant set and the local <code>InnerClasses</code> attribute.</p>
<p>The four-tuples of all local <code>InnerClasses</code> attributes are transmitted in five bands:</p>
<pre class="codeblock"><code>  ic_local_bands:
        *class_InnerClasses_N :UNSIGNED5 [COUNT(InnerClasses,...)]
        *class_InnerClasses_RC :UNSIGNED5 [SUM(*class_InnerClasses_N)] (cp_Class)
        *class_InnerClasses_F :UNSIGNED5 [SUM(*class_InnerClasses_N)]
        *class_InnerClasses_outer_RCN :UNSIGNED5 [COUNT(!=0,*class_InnerClasses_F)]  (null or cp_Class)
        *class_InnerClasses_name_RUN :UNSIGNED5 [COUNT(!=0,*class_InnerClasses_F)] (null or cp_Utf8)
</code></pre>
<p>Each four-tuple <code>&lt;C,F,C2,N&gt;</code> transmitted in these attribute bands is called a <em>local IC tuple</em>. (Note that the class file format stores the elements of these four-tuples in a different order, <code>(C,C2,N,F)</code>.) For a given class file X, the sequence of local IC tuples is called <code>ic_Local(X)</code>.</p>
<p>For each local IC tuple, the compressor transmits, at minimum, a <code>C</code> value and an <code>F</code> value. If a transmitted flags value <code>F</code> is not zero, there are also corresponding transmitted constant pool references <code>C2</code> and <code>N</code>. As a whole, the transmitted local tuple may or may not be equivalent to a global tuple from <code>ic_All</code>.</p>
<p>As an abbreviation, the compressor may transmit only a <code>C</code> and a flags value of zero, if the local IC tuple to be transmitted is equivalent to a member of <code>ic_All</code>, and no other member of <code>ic_All</code> defines the same class <code>C</code>. In this case the decompressor must behave exactly as if all four tuple components had been explicitly transmitted.</p>
<p>(If all four components of a local tuple are transmitted, and the flags value to be transmitted is in fact zero, the value <code>0x00010000</code> must be transmitted instead of zero for the flags.)</p>
<p>Frequently, the compressor will not need to transmit any local IC tuples at all, since the set of four-tuples to be stored in the class's <code>InnerClasses</code> attribute will be exactly <code>ic_Relevant(X)</code>, with no adjustment required. If extraneous four-tuples (beyond those required by a minimized constant pool) are found in the input class file, then some local IC tuples will be needed (with zero flags), to provide local &quot;roots&quot; for the extra <code>InnerClasses</code> entries. This can occur if a compiler requires an <code>InnerClasses</code> entry for a class mentioned only in a signature. Compressors are required to predict which classes require such extra local roots, and transmit only the unexpected four-tuples.</p>
<h5 id="metadata-transmission">5.9.1. Metadata Transmission</h5>
<p>There are nine groups of bands governed by the metadata layouts. They are summarized here.</p>
<pre class="codeblock"><code>  class_metadata_bands:
        class_RVA_bands
        class_RIA_bands

  field_metadata_bands:
        field_RVA_bands
        field_RIA_bands

  method_metadata_bands:
        method_RVA_bands
        method_RIA_bands
        method_RVPA_bands
        method_RIPA_bands
        method_AD_bands

  class_RVA_bands:
        *class_RVA_anno_N :UNSIGNED5 [...]
        *class_RVA_type_RS :UNSIGNED5 [...] (cp_Signature)
        *class_RVA_pair_N :UNSIGNED5 [...]
        *class_RVA_name_RU :UNSIGNED5 [...] (cp_Utf8)
        *class_RVA_T :BYTE1 [...]
        *class_RVA_caseI_KI :UNSIGNED5 [...] (cp_Int)
        *class_RVA_caseD_KD :UNSIGNED5 [...] (cp_Double)
        *class_RVA_caseF_KF :UNSIGNED5 [...] (cp_Float)
        *class_RVA_caseJ_KJ :UNSIGNED5 [...] (cp_Long)
        *class_RVA_casec_RS :UNSIGNED5 [...] (cp_Signature)
        *class_RVA_caseet_RS :UNSIGNED5 [...] (cp_Signature)
        *class_RVA_caseec_RU :UNSIGNED5 [...] (cp_Utf8)
        *class_RVA_cases_RU :UNSIGNED5 [...] (cp_Utf8)
        *class_RVA_casearray_N :UNSIGNED5 [...]
        *class_RVA_nesttype_RS :UNSIGNED5 [...] (cp_Signature)
        *class_RVA_nestpair_N :UNSIGNED5 [...]
        *class_RVA_nestname_RU :UNSIGNED5 [...] (cp_Utf8)

  class_RIA_bands:
        *class_RIA_anno_N :UNSIGNED5 [...]
        (analogous to class_RVA_bands)

  field_RVA_bands:
        *field_RVA_anno_N :UNSIGNED5 [...]
        (analogous to class_RVA_bands)

  field_RIA_bands:
        *field_RIA_anno_N :UNSIGNED5 [...]
        (analogous to field_RVA_bands)

  method_RVA_bands:
        *method_RVA_anno_N :UNSIGNED5 [...]
        (analogous to class_RVA_bands)

  method_RIA_bands:
        *method_RIA_anno_N :UNSIGNED5 [...]
        (analogous to method_RIA_bands)

  method_RVPA_bands:
        *method_RVPA_param_NB :BYTE1 [...]
        *method_RVPA_anno_N :UNSIGNED5 [...]
        (analogous to method_RVA_bands)

  method_RIPA_bands:
        *method_RIPA_param_NB :BYTE1 [...]
        *method_RIPA_anno_N :UNSIGNED5 [...]
        (analogous to method_RVPA_bands)

  method_AD_bands
        *method_AD_T :BYTE1 [...]
        *method_AD_caseI_KI :UNSIGNED5 [...] (cp_Int)
        *method_AD_caseD_KD :UNSIGNED5 [...] (cp_Double)
        *method_AD_caseF_KF :UNSIGNED5 [...] (cp_Float)
        *method_AD_caseJ_KJ :UNSIGNED5 [...] (cp_Long)
        *method_AD_casec_RS :UNSIGNED5 [...] (cp_Signature)
        *method_AD_caseet_RS :UNSIGNED5 [...] (cp_Signature)
        *method_AD_caseec_RU :UNSIGNED5 [...] (cp_Utf8)
        *method_AD_cases_RU :UNSIGNED5 [...] (cp_Utf8)
        *method_AD_casearray_N :UNSIGNED5 [...]
        *method_AD_nesttype_RS :UNSIGNED5 [...] (cp_Signature)
        *method_AD_nestpair_N :UNSIGNED5 [...]
        *method_AD_nestname_RU :UNSIGNED5 [...] (cp_Utf8)</code></pre>
<p>As an aid to understanding the metadata layout, here is a brief description of each of the method metadata bands, as used by classfiles which comply with JSR 175. The class and field metadata bands function in a similar way.</p>
<p>Note that JSR 175 does not allow embedded references to CONSTANT_Class entries, even where a reference to a class is required. Instead, JSR 175 requires that references to classes be encoded as field signatures. (Their names are bracketed by 'L' and ';'.) The Pack200 archive transmits all such values as references into <code>cp_Signature</code>, not <code>cp_Class</code>.</p>
<p>For each use of a parameter annotation attribute, the <code>method_RVPA_param_NB</code> band or <code>method_RIPA_param_NB</code> band (for invisible annotations) transmits an unsigned byte indicating the parameter count. For each use of a non-parameter annotation attribute, the <code>method_RVA_anno_N</code> band or <code>method_RIA_anno_N</code> band (for invisible annotations) transmits an annotation count. Likewise, for each annotated parameter, the <code>method_RVPA_anno_N</code> band or <code>method_RIPA_anno_N</code> band (for invisible annotations) transmits an annotation count.</p>
<p>For each visible non-parameter annotation, the <code>method_RVA_type_RS</code> band transmits an annotation's type, and the <code>method_RVA_pair_N</code> band transmits the number of that annotation's member-value pairs. Analogous values for invisible annotations and parameter annotations are transmitted in the bands <code>method_RIA_type_RS</code>, <code>method_RIA_pair_N</code>, <code>method_RVPA_type_RS</code>, <code>method_RVPA_pair_N</code>, <code>method_RIPA_type_RS</code>, and <code>method_RIPA_pair_N</code>. For each member-value pair transmitted as a direct part of a visible non-parameter annotation, the <code>method_RVA_name_RU</code> band transmits the member name. Analogous values for invisible annotations and parameter annotations are transmitted in the bands <code>method_RIA_name_RU</code>, <code>method_RVPA_name_RU</code>, and <code>method_RIPA_name_RU</code>.</p>
<p>For each value transmitted with a visible non-parameter annotation, whether directly, or indirectly via a nested value or annotation, the <code>method_RVA_T</code> band transmits a byte which selects the format of the annotation value, and analogous values are transmitted in the bands <code>method_RIA_T</code>, <code>method_RVPA_T</code>, <code>method_RIPA_T</code>, and (for annotation defaults) <code>method_AD_T</code>, Direct uses of these value tag bands are counted by summing the values of the corresponding preceding pair-count band (<code>method_RVA_pair_N</code>, etc.). This count also includes the sum of the corresponding following nested pair-count band (<code>method_RVA_nestpair_N</code>, etc.) and nested array length bands (<code>method_RVA_casearray_N</code>, etc.).</p>
<p>Since those latter sums come from backward calls in the attribute layout, they cannot be directly computed by the decompressor, but their sum is reported by the compressor as an element of <code>method_attr_calls</code>. (Note that the last callable in each metadata layout is the target of two backward calls from inside itself.) That band contains these backward call counts for <code>method_RVA_T</code>, <code>method_RIA_T</code> <code>method_RVPA_T</code>, <code>method_RIPA_T</code> <code>method_AD_T</code>, in that order. If there are no occurrences of a method metadata attribute, then the corresponding backward call is omitted. (Thus, there are up to five backward call counts transmitted for method metadata.) If there are compressor-defined recursive layouts used in the archive, their backward call counts follow the counts for metadata in <code>method_attr_calls</code>.</p>
<p>For each value tag of 'B', 'C', 'I', 'S', or 'Z', there is a corresponding element transmitted in <code>method_RVA_caseI_KI</code> which supplies the value as a <code>cp_Int</code> reference. Analogous integer references within invisible and parameter annotations and annotation defaults are transmitted in the bands <code>method_RIA_caseI_KI</code>, <code>method_RVPA_caseI_KI</code>, <code>method_RIPA_caseI_KI</code>, and <code>method_AD_caseI_KI</code>. For each value tag of 'e', the bands <code>method_RVA_caseet_RS</code> and <code>method_RVA_caseec_RU</code> transmit the signature of the class and name of the member of an enumeration constant, as references into <code>cp_Signature</code> and <code>cp_Utf8</code>. For each value tag of '[', the band <code>method_RVA_casearray_N</code> transmits the length of a nested value array. For each value tag of '@', the bands <code>method_RVA_nesttype_RS</code> and <code>method_RVA_nestpair_N</code> transmit the class signature of a nested annotation and the number of its pairs. For each pair in such a nested annotation, the band <code>method_RVA_nestname_RU</code> transmits the name of the pair.</p>
<p>The bands in the following table transmit appropriately-typed constant pool references for each occurrence of specific tag characters.</p>
<table>
<caption style="display:none">
details about escape code
</caption>
<tr style="text-align:center">
<th id="escape_code_details_t">
Tag(s)
</th>
<th id="escape_code_details_b">
Band
</th>
<th id="escape_code_details_r">
Reference
</th>
</tr>
<tr>
<td headers="escape_code_details_t">
<code>'B','C','I','S','Z'</code>
</td>
<td headers="escape_code_details_b">
<code>method_RVA_caseI_KI</code>
</td>
<td headers="escape_code_details_r">
cp_Int
</td>
</tr>
<tr>
<td headers="escape_code_details_t">
<code>'D'</code>
</td>
<td headers="escape_code_details_b">
<code>method_RVA_caseD_KD</code>
</td>
<td headers="escape_code_details_r">
cp_Double
</td>
</tr>
<tr>
<td headers="escape_code_details_t">
<code>'F'</code>
</td>
<td headers="escape_code_details_b">
<code>method_RVA_caseF_KF</code>
</td>
<td headers="escape_code_details_r">
cp_Float
</td>
</tr>
<tr>
<td headers="escape_code_details_t">
<code>'J'</code>
</td>
<td headers="escape_code_details_b">
<code>method_RVA_caseJ_KJ</code>
</td>
<td headers="escape_code_details_r">
cp_Long
</td>
</tr>
<tr>
<td headers="escape_code_details_t">
<code>'c'</code>
</td>
<td headers="escape_code_details_b">
<code>method_RVA_casec_RS</code>
</td>
<td headers="escape_code_details_r">
cp_Signature
</td>
</tr>
<tr>
<td headers="escape_code_details_t">
<code>'e'</code>
</td>
<td headers="escape_code_details_b">
<code>method_RVA_caseet_RS</code><br /> <code>method_RVA_caseec_RU</code>
</td>
<td headers="escape_code_details_r">
<code>cp_Signature</code><br /> <code>cp_Utf8</code>
</td>
</tr>
<tr>
<td headers="escape_code_details_t">
<code>'s'</code>
</td>
<td headers="escape_code_details_b">
<code>method_RVA_cases_RU</code>
</td>
<td headers="escape_code_details_r">
cp_Utf8
</td>
</tr>
</table>
<p>Analogous groups of bands transmit values within the other four method annotation types, and within the visible and invisible annotations of classes and fields.</p>
<h4 id="bytecode-instructions">5.10. Bytecode Instructions</h4>
<p>The last part of the Pack200 archive is a series of bands transmitting the bytecodes themselves. The bytecodes of each method code are parsed into instructions and operands transmitted in their own bands. Each method code corresponds to a run of bytecodes which ends with the distinguished code value 0xFF (255), which serves as an end marker. (Note that it is unusual for band data to be delimited by an end marker: Usually it is sized by a count in a previous band.)</p>
<p>Here are the bands which transmit bytecode instructions:</p>
<pre class="codeblock"><code>  bc_bands:
        *bc_codes :BYTE1 [...]
        *bc_case_count :UNSIGNED5 [COUNT(switch,*bc_codes)]
        *bc_case_value :DELTA5 [...]
        *bc_byte :BYTE1 [...]
        *bc_short :DELTA5 [...]
        *bc_local :UNSIGNED5 [...]
        *bc_label :BRANCH5 [...]
        *bc_intref :DELTA5 [...] (cp_Int)
        *bc_floatref :DELTA5 [...] (cp_Float)
        *bc_longref :DELTA5 [...] (cp_Long)
        *bc_doubleref :DELTA5 [...] (cp_Double)
        *bc_stringref :DELTA5 [...] (cp_String)
        *bc_loadablevalueref :DELTA5 [...] (cp_LoadableValue)
        *bc_classref :UNSIGNED5 [...] (current class or cp_Class)
        *bc_fieldref :DELTA5 [...] (cp_Field)
        *bc_methodref :UNSIGNED5 [...] (cp_Method)
        *bc_imethodref :DELTA5 [...] (cp_Imethod)
        *bc_indyref :DELTA5 [...] (cp_InvokeDynamic)
        *bc_thisfield :UNSIGNED5 [...] (cp_Field, only for current class)
        *bc_superfield :UNSIGNED5 [...] (cp_Field, only for current super)
        *bc_thismethod :UNSIGNED5 [...] (cp_Method, only for current class)
        *bc_supermethod :UNSIGNED5 [...] (cp_Method, only for current super)
        *bc_initref :UNSIGNED5 [...] (cp_Field, only for most recent new)
        *bc_escref :UNSIGNED5 [COUNT(ref_escape,*bc_codes)] (cp_All)
        *bc_escrefsize :UNSIGNED5 [...]
        *bc_escsize :UNSIGNED5 [...]
        *bc_escbyte :BYTE1 [...]
</code></pre>
<p>In order to transmit bytecode instructions more efficiently, some instructions may be rewritten into a transmission form. The ldc, ldc_w, and ldc2_w bytecodes must be rewritten by the compressor into strongly-typed operations; see below. Some getstatic, putstatic, getfield, putfield, invokevirtual, invokespecial, and invokestatic bytecodes <em>may</em> (at the compressor's option) be rewritten into more specialized and compact forms which, because they are context sensitive, select their operands from a smaller set of possibilities.</p>
<p>In all cases, the first byte of each instruction (perhaps rewritten) is determined by a byte transmitted in <code>bc_codes</code>. All operand bytes are decoded into operands and transmitted in separate bands according to the type of operand encoded. The padding bytes of switch instructions and the last two bytes of invokeinterface instructions are discarded, because they can be reconstructed by the decompressor.</p>
<p>A &quot;wide&quot; prefix bytecode is transmitted in <code>bc_codes</code>. The instruction following the prefix is decoded in its wide format, but (except in the case of iinc) it is transmitted in the same way, and using the same bands, as the normal (non-wide) format. The wide format of the iinc instruction uses <code>bc_short</code> instead of <code>bc_byte</code> to transmit its second operand.</p>
<p>Every branch instruction transmits its target (or targets, in the case of the switches) in the <code>bc_label</code> band, encoded as the difference between the renumbered BCI of the branch target and the renumbered BCI of the branch itself. (The renumbering, as described in the section <a href="#bci_renumbering">Attribute Layout Definition</a>, numbers the first instruction as zero, the second as one, and so forth.) Differences between renumbered BCIs are very compact; the primary encoding of BRANCH5 also takes advantage of the fact that most such differences are positive, because most branches are forward branches.</p>
<p>The <code>bc_classref</code> band carries incremented indexes into the <code>cp_Class</code> constant pool. The incrementing (by unity) reserves the code zero, which always refers to the current class. (This provides a a compact form for the most common class reference, which is a self-reference.)</p>
<p>The <code>bc_byte</code> and <code>bc_short</code> bands carry fixed-sized operands. These operands are not transmitted as general 32-bit integers because their instructions, as originally defined, already serve as specially compressed transmission formats. Integer values of these bands are treated as unsigned, even when they are semantically signed as operands. The <code>bc_byte</code> band is used for the last operands of multianewarray and non-wide iinc instructions, and for the operands of bipush and newarray instructions. The <code>bc_short</code> band is used for the last operands of wide iinc instructions, and for the operands of sipush instructions.</p>
<p>The bands <code>bc_intref</code>, <code>bc_floatref</code>, <code>bc_longref</code>, <code>bc_doubleref</code>, <code>bc_stringref</code>, <code>bc_fieldref</code>, <code>bc_methodref</code>, and <code>bc_imethodref</code> transmit ordinary indexes into the constant pools <code>cp_Int</code>, <code>cp_Float</code>, <code>cp_Long</code>, <code>cp_Double</code>, <code>cp_String</code>, <code>cp_Field</code>, <code>cp_Method</code>, and <code>cp_Imethod</code>, respectively.</p>
<p>The band <code>bc_indyref</code> transmits indexes into <code>cp_InvokeDynamic</code>, for <code>invokedynamic</code> instructions.</p>
<p>The band <code>bc_loadablevalueref</code> transmits indexes into the constant pool group <code>cp_LoadableValue</code>, such that zero refers to the first CONSTANT_Integer constant, and so on. It is transmitted immediately after <code>bc_stringref</code>. (Typically, this band is used for <code>cp_MethodHandle</code> constants.)</p>
<p>(The <code>invokedynamic</code> instructions may only appear when <code>#archive_majver</code> is 170 or higher. They and their related constant pool types were introduced in recent revisions of the classfile format.)</p>
<p>For every lookupswitch or tableswitch instruction, the number of cases is transmitted in <code>bc_case_count</code>, and the default label is transmitted in <code>bc_label</code>. Each case value and case target of a lookupswitch is transmitted in <code>bc_case_value</code> and <code>bc_label</code>, respectively. The initial case value of a tableswitch is transmitted in <code>bc_case_value</code>, and each of its case targets is transmitted in <code>bc_label</code>.</p>
<p>If the first byte of an instruction has a code in the range [202..255], or if an instruction's operands cannot be parsed according to the requirements of this specification, it is a non-standard instruction. Every byte of a non-standard instruction must be transmitted in a special envelope in order to warn the decompressor to accept it literally. The envelope consists of a series of &quot;byte_escape&quot; and &quot;ref_escape&quot; opcodes in the <code>bc_code</code> band, corresponding sizes in <code>bc_escsize</code> and <code>bc_escrefsize</code>, bytes in <code>bc_escbyte</code>, and constant pool references in <code>bc_escref</code>. Every constant pool reference in a non-standard instruction must be escaped and transmitted in the <code>bc_escref</code> band. Each ref_escape wraps one such constant pool reference, of size up to four bytes. The transmitted reference is an index into <code>cp_All</code>, such that zero refers to the first CONSTANT_Utf8 constant, and so on.</p>
<table>
<caption style="display:none">
escape codes
</caption>
<tr style="text-align:center">
<th id="escape_code_e">
Escape<br /> Opcode
</th>
<th id="escape_code_so">
Size<br /> Operand
</th>
<th id="escape_code_os">
Operand<br /> Size
</th>
<th id="escape_code_sb">
Size<br /> Band
</th>
<th id="escape_code_d">
Data<br /> Band
</th>
<th id="escape_code_ov">
Opcode<br /> Value
</th>
</tr>
<tr>
<td headers="escape_code_e">
byte_escape
</td>
<td headers="escape_code_so">
N&lt;=255
</td>
<td headers="escape_code_os">
N bytes
</td>
<td headers="escape_code_sb">
<code>bc_escsize</code>
</td>
<td headers="escape_code_d">
<code>bc_escbyte</code>
</td>
<td headers="escape_code_ov">
254
</td>
</tr>
<tr>
<td headers="escape_code_e">
ref_escape
</td>
<td headers="escape_code_so">
N&lt;=2
</td>
<td headers="escape_code_os">
N bytes
</td>
<td headers="escape_code_sb">
<code>bc_escrefsize</code>
</td>
<td headers="escape_code_d">
<code>bc_escref</code>
</td>
<td headers="escape_code_ov">
253
</td>
</tr>
</table>
<p>There is no need for special transmission of any other operand type within non-standard instructions, because the Pack200 format exactly preserves all instruction bytes except for constant pool references. This specification does not address the means by which compressors adapt to the presence and format of non-standard instructions. It simply requires decompressors to decode them correctly.</p>
<p>Here is a table of the specially rewritten transmission forms for instructions:</p>
<table>
<caption style="display:none">
specially rewritten transmission forms for instructions
</caption>
<tr style="text-align:center">
<th id="instructions_oi">
Original<br /> Instruction
</th>
<th id="instructions_op1">
Operand
</th>
<th id="instructions_ti">
Transmission<br /> Instruction
</th>
<th id="instructions_rr">
Rewrite<br /> Required?
</th>
<th id="instructions_op2">
Opcode
</th>
</tr>
<tr>
<td headers="instructions_oi">
ldc
</td>
<td headers="instructions_op1">
cp_String[i]
</td>
<td headers="instructions_ti">
sldc
</td>
<td headers="instructions_rr">
yes
</td>
<td headers="instructions_op2">
18 <em>(=ldc)</em>
</td>
</tr>
<tr>
<td headers="instructions_oi">
ldc
</td>
<td headers="instructions_op1">
cp_Class[i]
</td>
<td headers="instructions_ti">
cldc
</td>
<td headers="instructions_rr">
yes
</td>
<td headers="instructions_op2">
233
</td>
</tr>
<tr>
<td headers="instructions_oi">
ldc
</td>
<td headers="instructions_op1">
cp_Int[i]
</td>
<td headers="instructions_ti">
ildc
</td>
<td headers="instructions_rr">
yes
</td>
<td headers="instructions_op2">
234
</td>
</tr>
<tr>
<td headers="instructions_oi">
ldc
</td>
<td headers="instructions_op1">
cp_Float[i]
</td>
<td headers="instructions_ti">
fldc
</td>
<td headers="instructions_rr">
yes
</td>
<td headers="instructions_op2">
235
</td>
</tr>
<tr>
<td headers="instructions_oi">
ldc_w
</td>
<td headers="instructions_op1">
cp_String[i]
</td>
<td headers="instructions_ti">
sldc_w
</td>
<td headers="instructions_rr">
yes
</td>
<td headers="instructions_op2">
19 <em>(=ldc_w)</em>
</td>
</tr>
<tr>
<td headers="instructions_oi">
ldc_w
</td>
<td headers="instructions_op1">
cp_Class[i]
</td>
<td headers="instructions_ti">
cldc_w
</td>
<td headers="instructions_rr">
yes
</td>
<td headers="instructions_op2">
236
</td>
</tr>
<tr>
<td headers="instructions_oi">
ldc_w
</td>
<td headers="instructions_op1">
cp_Int[i]
</td>
<td headers="instructions_ti">
ildc_w
</td>
<td headers="instructions_rr">
yes
</td>
<td headers="instructions_op2">
237
</td>
</tr>
<tr>
<td headers="instructions_oi">
ldc_w
</td>
<td headers="instructions_op1">
cp_Float[i]
</td>
<td headers="instructions_ti">
fldc_w
</td>
<td headers="instructions_rr">
yes
</td>
<td headers="instructions_op2">
238
</td>
</tr>
<tr>
<td headers="instructions_oi">
ldc2_w
</td>
<td headers="instructions_op1">
cp_Long[i]
</td>
<td headers="instructions_ti">
lldc2_w
</td>
<td headers="instructions_rr">
yes
</td>
<td headers="instructions_op2">
20 <em>(=ldc2_w)</em>
</td>
</tr>
<tr>
<td headers="instructions_oi">
ldc2_w
</td>
<td headers="instructions_op1">
cp_Double[i]
</td>
<td headers="instructions_ti">
dldc2_w
</td>
<td headers="instructions_rr">
yes
</td>
<td headers="instructions_op2">
239
</td>
</tr>
<tr>
<td headers="instructions_oi">
ldc
</td>
<td headers="instructions_op1">
cp_LoadableValue[i]
</td>
<td headers="instructions_ti">
qldc
</td>
<td headers="instructions_rr">
yes
</td>
<td headers="instructions_op2">
240
</td>
</tr>
<tr>
<td headers="instructions_oi">
ldc_w
</td>
<td headers="instructions_op1">
cp_LoadableValue[i]
</td>
<td headers="instructions_ti">
qldc_w
</td>
<td headers="instructions_rr">
yes
</td>
<td headers="instructions_op2">
241
</td>
</tr>
<tr>
<td headers="instructions_oi">
getstatic
</td>
<td headers="instructions_op1">
<em>(this class member)</em>
</td>
<td headers="instructions_ti">
getstatic_this
</td>
<td headers="instructions_rr">
no
</td>
<td headers="instructions_op2">
202
</td>
</tr>
<tr>
<td headers="instructions_oi">
putstatic
</td>
<td headers="instructions_op1">
<em>(this class member)</em>
</td>
<td headers="instructions_ti">
putstatic_this
</td>
<td headers="instructions_rr">
no
</td>
<td headers="instructions_op2">
203
</td>
</tr>
<tr>
<td headers="instructions_oi">
getfield
</td>
<td headers="instructions_op1">
<em>(this class member)</em>
</td>
<td headers="instructions_ti">
getfield_this
</td>
<td headers="instructions_rr">
no
</td>
<td headers="instructions_op2">
204
</td>
</tr>
<tr>
<td headers="instructions_oi">
putfield
</td>
<td headers="instructions_op1">
<em>(this class member)</em>
</td>
<td headers="instructions_ti">
putfield_this
</td>
<td headers="instructions_rr">
no
</td>
<td headers="instructions_op2">
205
</td>
</tr>
<tr>
<td headers="instructions_oi">
invokevirtual
</td>
<td headers="instructions_op1">
<em>(this class member)</em>
</td>
<td headers="instructions_ti">
invokevirtual_this
</td>
<td headers="instructions_rr">
no
</td>
<td headers="instructions_op2">
206
</td>
</tr>
<tr>
<td headers="instructions_oi">
invokespecial
</td>
<td headers="instructions_op1">
<em>(this class member)</em>
</td>
<td headers="instructions_ti">
invokespecial_this
</td>
<td headers="instructions_rr">
no
</td>
<td headers="instructions_op2">
207
</td>
</tr>
<tr>
<td headers="instructions_oi">
invokestatic
</td>
<td headers="instructions_op1">
<em>(this class member)</em>
</td>
<td headers="instructions_ti">
invokestatic_this
</td>
<td headers="instructions_rr">
no
</td>
<td headers="instructions_op2">
208
</td>
</tr>
<tr>
<td headers="instructions_oi">
aload_0; getstatic
</td>
<td headers="instructions_op1">
<em>(this class member)</em>
</td>
<td headers="instructions_ti">
aload_0_getstatic_this
</td>
<td headers="instructions_rr">
no
</td>
<td headers="instructions_op2">
209
</td>
</tr>
<tr>
<td headers="instructions_oi">
aload_0; putstatic
</td>
<td headers="instructions_op1">
<em>(this class member)</em>
</td>
<td headers="instructions_ti">
aload_0_putstatic_this
</td>
<td headers="instructions_rr">
no
</td>
<td headers="instructions_op2">
210
</td>
</tr>
<tr>
<td headers="instructions_oi">
aload_0; getfield
</td>
<td headers="instructions_op1">
<em>(this class member)</em>
</td>
<td headers="instructions_ti">
aload_0_getfield_this
</td>
<td headers="instructions_rr">
no
</td>
<td headers="instructions_op2">
211
</td>
</tr>
<tr>
<td headers="instructions_oi">
aload_0; putfield
</td>
<td headers="instructions_op1">
<em>(this class member)</em>
</td>
<td headers="instructions_ti">
aload_0_putfield_this
</td>
<td headers="instructions_rr">
no
</td>
<td headers="instructions_op2">
212
</td>
</tr>
<tr>
<td headers="instructions_oi">
aload_0; invokevirtual
</td>
<td headers="instructions_op1">
<em>(this class member)</em>
</td>
<td headers="instructions_ti">
aload_0_invokevirtual_this
</td>
<td headers="instructions_rr">
no
</td>
<td headers="instructions_op2">
213
</td>
</tr>
<tr>
<td headers="instructions_oi">
aload_0; invokespecial
</td>
<td headers="instructions_op1">
<em>(this class member)</em>
</td>
<td headers="instructions_ti">
aload_0_invokespecial_this
</td>
<td headers="instructions_rr">
no
</td>
<td headers="instructions_op2">
214
</td>
</tr>
<tr>
<td headers="instructions_oi">
aload_0; invokestatic
</td>
<td headers="instructions_op1">
<em>(this class member)</em>
</td>
<td headers="instructions_ti">
aload_0_invokestatic_this
</td>
<td headers="instructions_rr">
no
</td>
<td headers="instructions_op2">
215
</td>
</tr>
<tr>
<td headers="instructions_oi">
getstatic
</td>
<td headers="instructions_op1">
<em>(super class member)</em>
</td>
<td headers="instructions_ti">
getstatic_super
</td>
<td headers="instructions_rr">
no
</td>
<td headers="instructions_op2">
216
</td>
</tr>
<tr>
<td headers="instructions_oi">
putstatic
</td>
<td headers="instructions_op1">
<em>(super class member)</em>
</td>
<td headers="instructions_ti">
putstatic_super
</td>
<td headers="instructions_rr">
no
</td>
<td headers="instructions_op2">
217
</td>
</tr>
<tr>
<td headers="instructions_oi">
getfield
</td>
<td headers="instructions_op1">
<em>(super class member)</em>
</td>
<td headers="instructions_ti">
getfield_super
</td>
<td headers="instructions_rr">
no
</td>
<td headers="instructions_op2">
218
</td>
</tr>
<tr>
<td headers="instructions_oi">
putfield
</td>
<td headers="instructions_op1">
<em>(super class member)</em>
</td>
<td headers="instructions_ti">
putfield_super
</td>
<td headers="instructions_rr">
no
</td>
<td headers="instructions_op2">
219
</td>
</tr>
<tr>
<td headers="instructions_oi">
invokevirtual
</td>
<td headers="instructions_op1">
<em>(super class member)</em>
</td>
<td headers="instructions_ti">
invokevirtual_super
</td>
<td headers="instructions_rr">
no
</td>
<td headers="instructions_op2">
220
</td>
</tr>
<tr>
<td headers="instructions_oi">
invokespecial
</td>
<td headers="instructions_op1">
<em>(super class member)</em>
</td>
<td headers="instructions_ti">
invokespecial_super
</td>
<td headers="instructions_rr">
no
</td>
<td headers="instructions_op2">
221
</td>
</tr>
<tr>
<td headers="instructions_oi">
invokestatic
</td>
<td headers="instructions_op1">
<em>(super class member)</em>
</td>
<td headers="instructions_ti">
invokestatic_super
</td>
<td headers="instructions_rr">
no
</td>
<td headers="instructions_op2">
222
</td>
</tr>
<tr>
<td headers="instructions_oi">
aload_0; getstatic
</td>
<td headers="instructions_op1">
<em>(super class member)</em>
</td>
<td headers="instructions_ti">
aload_0_getstatic_super
</td>
<td headers="instructions_rr">
no
</td>
<td headers="instructions_op2">
223
</td>
</tr>
<tr>
<td headers="instructions_oi">
aload_0; putstatic
</td>
<td headers="instructions_op1">
<em>(super class member)</em>
</td>
<td headers="instructions_ti">
aload_0_putstatic_super
</td>
<td headers="instructions_rr">
no
</td>
<td headers="instructions_op2">
224
</td>
</tr>
<tr>
<td headers="instructions_oi">
aload_0; getfield
</td>
<td headers="instructions_op1">
<em>(super class member)</em>
</td>
<td headers="instructions_ti">
aload_0_getfield_super
</td>
<td headers="instructions_rr">
no
</td>
<td headers="instructions_op2">
225
</td>
</tr>
<tr>
<td headers="instructions_oi">
aload_0; putfield
</td>
<td headers="instructions_op1">
<em>(super class member)</em>
</td>
<td headers="instructions_ti">
aload_0_putfield_super
</td>
<td headers="instructions_rr">
no
</td>
<td headers="instructions_op2">
226
</td>
</tr>
<tr>
<td headers="instructions_oi">
aload_0; invokevirtual
</td>
<td headers="instructions_op1">
<em>(super class member)</em>
</td>
<td headers="instructions_ti">
aload_0_invokevirtual_super
</td>
<td headers="instructions_rr">
no
</td>
<td headers="instructions_op2">
227
</td>
</tr>
<tr>
<td headers="instructions_oi">
aload_0; invokespecial
</td>
<td headers="instructions_op1">
<em>(super class member)</em>
</td>
<td headers="instructions_ti">
aload_0_invokespecial_super
</td>
<td headers="instructions_rr">
no
</td>
<td headers="instructions_op2">
228
</td>
</tr>
<tr>
<td headers="instructions_oi">
aload_0; invokestatic
</td>
<td headers="instructions_op1">
<em>(super class member)</em>
</td>
<td headers="instructions_ti">
aload_0_invokestatic_super
</td>
<td headers="instructions_rr">
no
</td>
<td headers="instructions_op2">
229
</td>
</tr>
<tr>
<td headers="instructions_oi">
invokespecial
</td>
<td headers="instructions_op1">
<em>(this class &lt;init&gt;)</em>
</td>
<td headers="instructions_ti">
invokespecial_this_init
</td>
<td headers="instructions_rr">
no
</td>
<td headers="instructions_op2">
230
</td>
</tr>
<tr>
<td headers="instructions_oi">
invokespecial
</td>
<td headers="instructions_op1">
<em>(super class &lt;init&gt;)</em>
</td>
<td headers="instructions_ti">
invokespecial_super_init
</td>
<td headers="instructions_rr">
no
</td>
<td headers="instructions_op2">
231
</td>
</tr>
<tr>
<td headers="instructions_oi">
invokespecial
</td>
<td headers="instructions_op1">
<em>(new class &lt;init&gt;)</em>
</td>
<td headers="instructions_ti">
invokespecial_new_init
</td>
<td headers="instructions_rr">
no
</td>
<td headers="instructions_op2">
232
</td>
</tr>
<tr>
<td headers="instructions_oi">
invokespecial
</td>
<td headers="instructions_op1">
cp_Imethod[i]
</td>
<td headers="instructions_ti">
invokespecial_int
</td>
<td headers="instructions_rr">
yes
</td>
<td headers="instructions_op2">
242
</td>
</tr>
<tr>
<td headers="instructions_oi">
invokestatic
</td>
<td headers="instructions_op1">
cp_Imethod[i]
</td>
<td headers="instructions_ti">
invokestatic_int
</td>
<td headers="instructions_rr">
yes
</td>
<td headers="instructions_op2">
243
</td>
</tr>
</table>
<p>The <code>qldc</code> and <code>qldc_w</code> instructions use indexes into the constant pool group <code>cp_LoadableValue</code> to select arbitrary loadable constants. (These instructions may only appear when <code>#archive_majver</code> is 170 or higher. Early versions of the classfile format do not require them.) Decompressors are required to accept any constant reference as an operand to one of these instructions, but compressors are encouraged to transmit only constants which cannot be encoded by other variants of <code>ldc</code>, specifically elements of <code>cp_MethodHandle</code> and <code>cp_MethodType</code>.</p>
<p>(Note: A previous version of this specification referred to the string-bearing variants of <code>ldc</code>, <code>sldc</code> and <code>sldc_w</code>, as <code>aldc</code> and <code>aldc_w</code>. Despite the new names, the code points and their interpretation have not changed. The old names are deprecated.)</p>
<p>Every bytecode instruction is contained by a class, called the <em>current class</em>. The superclass (if any) of the current class is the <em>current super class</em>. The operand of the textually most recent &quot;new&quot; instruction (in the same method) is called the <em>current new class</em>.</p>
<p>If an instruction refers to a field or method in the current class, it may (at the compressor's option) be rewritten for transmission as a corresponding opcode spelled with &quot;_this&quot;. Likewise, an instruction referring to a field or method in the current super class may be rewritten as a corresponding opcode spelled with &quot;_super&quot;. In either case, if the immediately preceding instruction is aload_0 (opcode 42), the transmission of that instruction may be suppressed by the compressor, and the corresponding opcode spelled with &quot;aload_0_&quot; selected instead; otherwise the &quot;aload_0_&quot; variant may not be selected.</p>
<p>If an invokespecial instruction refers to a method named &lt;init&gt; in the current class, the current super class, or the current new class, the compressor may choose to rewrite it as an invokespecial_this_init, invokespecial_super_init, or invokespecial_new_init, respectively.</p>
<p>If an invokespecial or an invokestatic instruction has an operand of type CONSTANT_InterfaceMethodref, then the compressor must transmit those methods using the pseudo-instructions invokespecial_int and invokestatic_int respectively. These instructions may only appear when <code>#archive_majver</code> is 171 or higher.</p>
<p>Field (resp. method) operands of rewritten instructions spelled with &quot;_this&quot; (but not &quot;_init&quot;) are transmitted in the special band <code>bc_thisfield</code> (resp. <code>bc_thismethod</code>). The numbering of these operands is defined by taking the sequence of symbols in <code>cp_Field</code> (resp. <code>cp_Method</code>) and selecting only members of the current class. The resulting subset, without changing its order, is renumbered starting with zero. This provides a compact mapping of small integers to members of the current class.</p>
<p>Likewise, operands of rewritten instructions spelled with &quot;_super&quot; (but not &quot;_init&quot;) are transmitted in the <code>bc_superfield</code> or <code>bc_supermethod</code> band, and renumbered as a subset of <code>cp_Field</code> or <code>cp_Method</code>, selecting only members of the current super class.</p>
<p>Finally, operands of the rewritten instructions spelled with &quot;_init&quot; are transmitted in the band <code>bc_initref</code>, and renumbered as a subset of <code>cp_Method</code>, selected according to the appropriate class (current, current super, or current new), and also selected to have the name &lt;init&gt;. (The index transmitted is usually very small; in effect it selects only the signature of the invoked method, and most classes possess only a few constructors.)</p>
<p>Here is a table summarizing the transmission of instructions of more than one byte.</p>
<table>
<caption style="display:none">
transmission instructions of more than one byte
</caption>
<tr style="text-align:center">
<th id="instructions_plus1_i">
Instruction
</th>
<th id="instructions_plus1_o">
Operand
</th>
<th id="instructions_plus1_t">
Transmitted<br /> Value
</th>
<th id="instructions_plus1_b">
Band
</th>
</tr>
<tr>
<td headers="instructions_plus1_i">
bipush
</td>
<td headers="instructions_plus1_o">
(byte) x
</td>
<td headers="instructions_plus1_t">
x &amp; 0xFF
</td>
<td headers="instructions_plus1_b">
<code>bc_byte</code>
</td>
</tr>
<tr>
<td headers="instructions_plus1_i">
sipush
</td>
<td headers="instructions_plus1_o">
(short) x
</td>
<td headers="instructions_plus1_t">
x &amp; 0xFFFF
</td>
<td headers="instructions_plus1_b">
<code>bc_short</code>
</td>
</tr>
<tr>
<td headers="instructions_plus1_i">
ildc
</td>
<td headers="instructions_plus1_o">
cp_Int[i]
</td>
<td headers="instructions_plus1_t">
i
</td>
<td headers="instructions_plus1_b">
<code>bc_intref</code>
</td>
</tr>
<tr>
<td headers="instructions_plus1_i">
fldc
</td>
<td headers="instructions_plus1_o">
cp_Float[i]
</td>
<td headers="instructions_plus1_t">
i
</td>
<td headers="instructions_plus1_b">
<code>bc_floatref</code>
</td>
</tr>
<tr>
<td headers="instructions_plus1_i">
sldc
</td>
<td headers="instructions_plus1_o">
cp_String[i]
</td>
<td headers="instructions_plus1_t">
i
</td>
<td headers="instructions_plus1_b">
<code>bc_stringref</code>
</td>
</tr>
<tr>
<td headers="instructions_plus1_i">
qldc
</td>
<td headers="instructions_plus1_o">
cp_LoadableValue[i]
</td>
<td headers="instructions_plus1_t">
i
</td>
<td headers="instructions_plus1_b">
<code>bc_loadablevalueref</code>
</td>
</tr>
<tr>
<td headers="instructions_plus1_i">
cldc
</td>
<td headers="instructions_plus1_o">
current class
</td>
<td headers="instructions_plus1_t">
0
</td>
<td headers="instructions_plus1_b">
<code>bc_classref</code>
</td>
</tr>
<tr>
<td headers="instructions_plus1_i">
cldc
</td>
<td headers="instructions_plus1_o">
cp_Class[i]
</td>
<td headers="instructions_plus1_t">
i+1
</td>
<td headers="instructions_plus1_b">
<code>bc_classref</code>
</td>
</tr>
<tr>
<td headers="instructions_plus1_i">
ildc_w
</td>
<td headers="instructions_plus1_o">
cp_Int[i]
</td>
<td headers="instructions_plus1_t">
i
</td>
<td headers="instructions_plus1_b">
<code>bc_intref</code>
</td>
</tr>
<tr>
<td headers="instructions_plus1_i">
fldc_w
</td>
<td headers="instructions_plus1_o">
cp_Float[i]
</td>
<td headers="instructions_plus1_t">
i
</td>
<td headers="instructions_plus1_b">
<code>bc_floatref</code>
</td>
</tr>
<tr>
<td headers="instructions_plus1_i">
sldc_w
</td>
<td headers="instructions_plus1_o">
cp_String[i]
</td>
<td headers="instructions_plus1_t">
i
</td>
<td headers="instructions_plus1_b">
<code>bc_stringref</code>
</td>
</tr>
<tr>
<td headers="instructions_plus1_i">
qldc_w
</td>
<td headers="instructions_plus1_o">
cp_LoadableValue[i]
</td>
<td headers="instructions_plus1_t">
i
</td>
<td headers="instructions_plus1_b">
<code>bc_loadablevalueref</code>
</td>
</tr>
<tr>
<td headers="instructions_plus1_i">
cldc_w
</td>
<td headers="instructions_plus1_o">
current class
</td>
<td headers="instructions_plus1_t">
0
</td>
<td headers="instructions_plus1_b">
<code>bc_classref</code>
</td>
</tr>
<tr>
<td headers="instructions_plus1_i">
cldc_w
</td>
<td headers="instructions_plus1_o">
cp_Class[i]
</td>
<td headers="instructions_plus1_t">
i+1
</td>
<td headers="instructions_plus1_b">
<code>bc_classref</code>
</td>
</tr>
<tr>
<td headers="instructions_plus1_i">
lldc2_w
</td>
<td headers="instructions_plus1_o">
cp_Long[i]
</td>
<td headers="instructions_plus1_t">
i
</td>
<td headers="instructions_plus1_b">
<code>bc_long</code>
</td>
</tr>
<tr>
<td headers="instructions_plus1_i">
dldc2_w
</td>
<td headers="instructions_plus1_o">
cp_Double[i]
</td>
<td headers="instructions_plus1_t">
i
</td>
<td headers="instructions_plus1_b">
<code>bc_double</code>
</td>
</tr>
<tr>
<td headers="instructions_plus1_i">
*load
</td>
<td headers="instructions_plus1_o">
locals[i]
</td>
<td headers="instructions_plus1_t">
i
</td>
<td headers="instructions_plus1_b">
<code>bc_local</code>
</td>
</tr>
<tr>
<td headers="instructions_plus1_i">
*store
</td>
<td headers="instructions_plus1_o">
locals[i]
</td>
<td headers="instructions_plus1_t">
i
</td>
<td headers="instructions_plus1_b">
<code>bc_local</code>
</td>
</tr>
<tr>
<td headers="instructions_plus1_i">
ret
</td>
<td headers="instructions_plus1_o">
locals[i]
</td>
<td headers="instructions_plus1_t">
i
</td>
<td headers="instructions_plus1_b">
<code>bc_local</code>
</td>
</tr>
<tr>
<td headers="instructions_plus1_i">
iinc
</td>
<td headers="instructions_plus1_o">
locals[i]
</td>
<td headers="instructions_plus1_t">
i
</td>
<td headers="instructions_plus1_b">
<code>bc_local</code>
</td>
</tr>
<tr>
<td headers="instructions_plus1_i">
iinc (not wide)
</td>
<td headers="instructions_plus1_o">
(byte) x
</td>
<td headers="instructions_plus1_t">
x &amp; 0xFF
</td>
<td headers="instructions_plus1_b">
<code>bc_byte</code>
</td>
</tr>
<tr>
<td headers="instructions_plus1_i">
iinc (wide)
</td>
<td headers="instructions_plus1_o">
(short) x
</td>
<td headers="instructions_plus1_t">
x &amp; 0xFFFF
</td>
<td headers="instructions_plus1_b">
<code>bc_short</code>
</td>
</tr>
<tr>
<td headers="instructions_plus1_i">
if**
</td>
<td headers="instructions_plus1_o">
pc
</td>
<td headers="instructions_plus1_t">
<em>(delta/renumbered)</em>
</td>
<td headers="instructions_plus1_b">
<code>bc_label</code>
</td>
</tr>
<tr>
<td headers="instructions_plus1_i">
if_**
</td>
<td headers="instructions_plus1_o">
pc
</td>
<td headers="instructions_plus1_t">
<em>(delta/renumbered)</em>
</td>
<td headers="instructions_plus1_b">
<code>bc_label</code>
</td>
</tr>
<tr>
<td headers="instructions_plus1_i">
goto
</td>
<td headers="instructions_plus1_o">
pc
</td>
<td headers="instructions_plus1_t">
<em>(delta/renumbered)</em>
</td>
<td headers="instructions_plus1_b">
<code>bc_label</code>
</td>
</tr>
<tr>
<td headers="instructions_plus1_i">
jsr
</td>
<td headers="instructions_plus1_o">
pc
</td>
<td headers="instructions_plus1_t">
<em>(delta/renumbered)</em>
</td>
<td headers="instructions_plus1_b">
<code>bc_label</code>
</td>
</tr>
<tr>
<td headers="instructions_plus1_i">
goto_w
</td>
<td headers="instructions_plus1_o">
pc
</td>
<td headers="instructions_plus1_t">
<em>(delta/renumbered)</em>
</td>
<td headers="instructions_plus1_b">
<code>bc_label</code>
</td>
</tr>
<tr>
<td headers="instructions_plus1_i">
jsr_w
</td>
<td headers="instructions_plus1_o">
pc
</td>
<td headers="instructions_plus1_t">
<em>(delta/renumbered)</em>
</td>
<td headers="instructions_plus1_b">
<code>bc_label</code>
</td>
</tr>
<tr>
<td headers="instructions_plus1_i">
tableswitch
</td>
<td headers="instructions_plus1_o">
case count
</td>
<td headers="instructions_plus1_t">
count
</td>
<td headers="instructions_plus1_b">
<code>bc_case_count</code>
</td>
</tr>
<tr>
<td headers="instructions_plus1_i">
tableswitch
</td>
<td headers="instructions_plus1_o">
default pc
</td>
<td headers="instructions_plus1_t">
<em>(delta/renumbered)</em>
</td>
<td headers="instructions_plus1_b">
<code>bc_label</code>
</td>
</tr>
<tr>
<td headers="instructions_plus1_i">
tableswitch
</td>
<td headers="instructions_plus1_o">
first case value
</td>
<td headers="instructions_plus1_t">
value
</td>
<td headers="instructions_plus1_b">
<code>bc_case_value</code>
</td>
</tr>
<tr>
<td headers="instructions_plus1_i">
tableswitch
</td>
<td headers="instructions_plus1_o">
each case pc
</td>
<td headers="instructions_plus1_t">
<em>(delta/renumbered)</em>
</td>
<td headers="instructions_plus1_b">
<code>bc_label</code>
</td>
</tr>
<tr>
<td headers="instructions_plus1_i">
lookupswitch
</td>
<td headers="instructions_plus1_o">
case count
</td>
<td headers="instructions_plus1_t">
count
</td>
<td headers="instructions_plus1_b">
<code>bc_case_count</code>
</td>
</tr>
<tr>
<td headers="instructions_plus1_i">
lookupswitch
</td>
<td headers="instructions_plus1_o">
default pc
</td>
<td headers="instructions_plus1_t">
<em>(delta/renumbered)</em>
</td>
<td headers="instructions_plus1_b">
<code>bc_label</code>
</td>
</tr>
<tr>
<td headers="instructions_plus1_i">
lookupswitch
</td>
<td headers="instructions_plus1_o">
each case value
</td>
<td headers="instructions_plus1_t">
value
</td>
<td headers="instructions_plus1_b">
<code>bc_case_value</code>
</td>
</tr>
<tr>
<td headers="instructions_plus1_i">
lookupswitch
</td>
<td headers="instructions_plus1_o">
each case pc
</td>
<td headers="instructions_plus1_t">
<em>(delta/renumbered)</em>
</td>
<td headers="instructions_plus1_b">
<code>bc_label</code>
</td>
</tr>
<tr>
<td headers="instructions_plus1_i">
new
</td>
<td headers="instructions_plus1_o">
current class
</td>
<td headers="instructions_plus1_t">
0
</td>
<td headers="instructions_plus1_b">
<code>bc_classref</code>
</td>
</tr>
<tr>
<td headers="instructions_plus1_i">
new
</td>
<td headers="instructions_plus1_o">
cp_Class[i]
</td>
<td headers="instructions_plus1_t">
1+i
</td>
<td headers="instructions_plus1_b">
<code>bc_classref</code>
</td>
</tr>
<tr>
<td headers="instructions_plus1_i">
newarray
</td>
<td headers="instructions_plus1_o">
type code
</td>
<td headers="instructions_plus1_t">
value
</td>
<td headers="instructions_plus1_b">
<code>bc_byte</code>
</td>
</tr>
<tr>
<td headers="instructions_plus1_i">
anewarray
</td>
<td headers="instructions_plus1_o">
current class
</td>
<td headers="instructions_plus1_t">
0
</td>
<td headers="instructions_plus1_b">
<code>bc_classref</code>
</td>
</tr>
<tr>
<td headers="instructions_plus1_i">
anewarray
</td>
<td headers="instructions_plus1_o">
cp_Class[i]
</td>
<td headers="instructions_plus1_t">
1+i
</td>
<td headers="instructions_plus1_b">
<code>bc_classref</code>
</td>
</tr>
<tr>
<td headers="instructions_plus1_i">
checkcast
</td>
<td headers="instructions_plus1_o">
current class
</td>
<td headers="instructions_plus1_t">
0
</td>
<td headers="instructions_plus1_b">
<code>bc_classref</code>
</td>
</tr>
<tr>
<td headers="instructions_plus1_i">
checkcast
</td>
<td headers="instructions_plus1_o">
cp_Class[i]
</td>
<td headers="instructions_plus1_t">
1+i
</td>
<td headers="instructions_plus1_b">
<code>bc_classref</code>
</td>
</tr>
<tr>
<td headers="instructions_plus1_i">
instanceof
</td>
<td headers="instructions_plus1_o">
current class
</td>
<td headers="instructions_plus1_t">
0
</td>
<td headers="instructions_plus1_b">
<code>bc_classref</code>
</td>
</tr>
<tr>
<td headers="instructions_plus1_i">
instanceof
</td>
<td headers="instructions_plus1_o">
cp_Class[i]
</td>
<td headers="instructions_plus1_t">
1+i
</td>
<td headers="instructions_plus1_b">
<code>bc_classref</code>
</td>
</tr>
<tr>
<td headers="instructions_plus1_i">
multianewarray
</td>
<td headers="instructions_plus1_o">
cp_Class[i]
</td>
<td headers="instructions_plus1_t">
1+i
</td>
<td headers="instructions_plus1_b">
<code>bc_classref</code>
</td>
</tr>
<tr>
<td headers="instructions_plus1_i">
multianewarray
</td>
<td headers="instructions_plus1_o">
rank
</td>
<td headers="instructions_plus1_t">
rank &amp; 0xFF
</td>
<td headers="instructions_plus1_b">
<code>bc_byte</code>
</td>
</tr>
<tr>
<td headers="instructions_plus1_i">
getstatic
</td>
<td headers="instructions_plus1_o">
cp_Field[i]
</td>
<td headers="instructions_plus1_t">
i
</td>
<td headers="instructions_plus1_b">
<code>bc_fieldref</code>
</td>
</tr>
<tr>
<td headers="instructions_plus1_i">
putstatic
</td>
<td headers="instructions_plus1_o">
cp_Field[i]
</td>
<td headers="instructions_plus1_t">
i
</td>
<td headers="instructions_plus1_b">
<code>bc_fieldref</code>
</td>
</tr>
<tr>
<td headers="instructions_plus1_i">
getfield
</td>
<td headers="instructions_plus1_o">
cp_Field[i]
</td>
<td headers="instructions_plus1_t">
i
</td>
<td headers="instructions_plus1_b">
<code>bc_fieldref</code>
</td>
</tr>
<tr>
<td headers="instructions_plus1_i">
putfield
</td>
<td headers="instructions_plus1_o">
cp_Field[i]
</td>
<td headers="instructions_plus1_t">
i
</td>
<td headers="instructions_plus1_b">
<code>bc_fieldref</code>
</td>
</tr>
<tr>
<td headers="instructions_plus1_i">
invokevirtual
</td>
<td headers="instructions_plus1_o">
cp_Method[i]
</td>
<td headers="instructions_plus1_t">
i
</td>
<td headers="instructions_plus1_b">
<code>bc_methodref</code>
</td>
</tr>
<tr>
<td headers="instructions_plus1_i">
invokespecial
</td>
<td headers="instructions_plus1_o">
cp_Method[i]
</td>
<td headers="instructions_plus1_t">
i
</td>
<td headers="instructions_plus1_b">
<code>bc_methodref</code>
</td>
</tr>
<tr>
<td headers="instructions_plus1_i">
invokestatic
</td>
<td headers="instructions_plus1_o">
cp_Method[i]
</td>
<td headers="instructions_plus1_t">
i
</td>
<td headers="instructions_plus1_b">
<code>bc_methodref</code>
</td>
</tr>
<tr>
<td headers="instructions_plus1_i">
invokeinterface
</td>
<td headers="instructions_plus1_o">
cp_Imethod[i]
</td>
<td headers="instructions_plus1_t">
i
</td>
<td headers="instructions_plus1_b">
<code>bc_imethodref</code>
</td>
</tr>
<tr>
<td headers="instructions_plus1_i">
invokespecial_int
</td>
<td headers="instructions_plus1_o">
cp_Imethod[i]
</td>
<td headers="instructions_plus1_t">
i
</td>
<td headers="instructions_plus1_b">
<code>bc_imethodref</code>
</td>
</tr>
<tr>
<td headers="instructions_plus1_i">
invokestatic_int
</td>
<td headers="instructions_plus1_o">
cp_Imethod[i]
</td>
<td headers="instructions_plus1_t">
i
</td>
<td headers="instructions_plus1_b">
<code>bc_imethodref</code>
</td>
</tr>
<tr>
<td headers="instructions_plus1_i">
invokedynamic
</td>
<td headers="instructions_plus1_o">
cp_InvokeDynamic[i]
</td>
<td headers="instructions_plus1_t">
i
</td>
<td headers="instructions_plus1_b">
<code>bc_indyref</code>
</td>
</tr>
<tr>
<td headers="instructions_plus1_i">
**_this
</td>
<td headers="instructions_plus1_o">
this_fields[i]
</td>
<td headers="instructions_plus1_t">
i
</td>
<td headers="instructions_plus1_b">
<code>bc_thisfield</code>
</td>
</tr>
<tr>
<td headers="instructions_plus1_i">
**_this
</td>
<td headers="instructions_plus1_o">
this_methods[i]
</td>
<td headers="instructions_plus1_t">
i
</td>
<td headers="instructions_plus1_b">
<code>bc_thismethod</code>
</td>
</tr>
<tr>
<td headers="instructions_plus1_i">
**_super
</td>
<td headers="instructions_plus1_o">
super_fields[i]
</td>
<td headers="instructions_plus1_t">
i
</td>
<td headers="instructions_plus1_b">
<code>bc_superfield</code>
</td>
</tr>
<tr>
<td headers="instructions_plus1_i">
**_super
</td>
<td headers="instructions_plus1_o">
super_methods[i]
</td>
<td headers="instructions_plus1_t">
i
</td>
<td headers="instructions_plus1_b">
<code>bc_supermethod</code>
</td>
</tr>
<tr>
<td headers="instructions_plus1_i">
invokespecial_this_init
</td>
<td headers="instructions_plus1_o">
this_constructors[i]
</td>
<td headers="instructions_plus1_t">
i
</td>
<td headers="instructions_plus1_b">
<code>bc_initref</code>
</td>
</tr>
<tr>
<td headers="instructions_plus1_i">
invokespecial_super_init
</td>
<td headers="instructions_plus1_o">
super_constructors[i]
</td>
<td headers="instructions_plus1_t">
i
</td>
<td headers="instructions_plus1_b">
<code>bc_initref</code>
</td>
</tr>
<tr>
<td headers="instructions_plus1_i">
invokespecial_new_init
</td>
<td headers="instructions_plus1_o">
new_constructors[i]
</td>
<td headers="instructions_plus1_t">
i
</td>
<td headers="instructions_plus1_b">
<code>bc_initref</code>
</td>
</tr>
</table>
<h2 id="specification-of-band-coding">6. Specification of Band Coding</h2>
<p>A Pack200 band consists of a sequence of small integers, each of which is representable in 32 bits. Depending on the intended use of these numbers, they may be interpreted to possess a twos-complement sign.</p>
<p>Each integer is coded for transmission as a byte sequence, using between one and five bytes, according to a previously determined encoding. The encoding may by a primary encoding for the current band as specified as part of this Pack200 archive format specification, or the encoding may depend on information transmitted before the occurrence of the encoded integer.</p>
<p>(Note: In this account of encodings, bytes are indivisible octets which express unsigned values in [0,255].)</p>
<h3 id="encoding-of-small-whole-numbers">6.1. Encoding of Small Whole Numbers</h3>
<p>There is a small but flexible set of possible encodings allowed by the archive. They are all based on a two-parameter scheme of codings for small unsigned integers, which is further parameterized by options for sign representation and delta encoding, and by special modes for slowly varying encodings, and for the compact renaming of frequent values.</p>
<h4 id="scheme-of-multiple-codings">6.1.1. Scheme of Multiple Codings</h4>
<p>The encoding of a small whole number depends on two independent parameters B and H, and a derived parameter L:</p>
<table>
<caption style="display:none">
multiple coding scheme
</caption>
<tr style="text-align:center">
<th id="multiple_coding_scheme_n">
Name
</th>
<th id="multiple_coding_scheme_r">
Range
</th>
<th id="multiple_coding_scheme_m">
Meaning
</th>
</tr>
<tr>
<td headers="multiple_coding_scheme_n">
B
</td>
<td headers="multiple_coding_scheme_r">
[1..5]
</td>
<td headers="multiple_coding_scheme_m">
maximum byte length
</td>
</tr>
<tr>
<td headers="multiple_coding_scheme_n">
H
</td>
<td headers="multiple_coding_scheme_r">
[1..256]
</td>
<td headers="multiple_coding_scheme_m">
number of high byte values
</td>
</tr>
<tr>
<td headers="multiple_coding_scheme_n">
L
</td>
<td headers="multiple_coding_scheme_r">
[0..255]
</td>
<td headers="multiple_coding_scheme_m">
number of low byte values, defined as (256-H)
</td>
</tr>
</table>
<p>Given any two values B and H, there is a coding (B,H) which establishes a one-to-one correspondence between an initial sequence of non-negative integers, and an &quot;encoding sets&quot; of short sequences of bytes.</p>
<p>Moreover, no byte sequence in the encoding set is a proper prefix of another byte sequence in the same set. prefix. This means, informally, that encodings are self-sizing, or &quot;parseable&quot;.</p>
<p>Also, the encoding set is as full as possible, so that every long-enough sequence of bytes begins with a unique prefix of bytes drawn from the encoding set. In particular, every sequence of B bytes has a (unique) prefix in the encoding set for the (B,H) coding.</p>
<h4 id="definition-of-encoding-byte-sequences">6.1.2. Definition of Encoding Byte Sequences</h4>
<p>Relative to a given (B,H) coding, we say that a byte is &quot;high&quot; if its value is in the range <code>[256-H..255]</code>. We also say that a byte is &quot;low&quot; if L is positive and the byte's value is in the range <code>[0..L-1]</code></p>
<p>Given a (B,H) coding, a sequence of bytes is in its encoding set if and only if all of the following are true:</p>
<ul>
<li>the sequence contains at least one and no more than B bytes</li>
<li>all bytes except the last are &quot;high&quot;</li>
<li>either the last byte is &quot;low&quot;, or else the sequence has B bytes</li>
</ul>
<p>As a consequence of this definition, the encoding set be regarded as satisfying this regular expression, in terms of high and low bytes:</p>
<pre class="codblock"><code>  encoding_set = (high* low) | (high)^B</code></pre>
<p>(Note: In this specification the up-caret sign '^' denotes exponentiation, either of regular expressions as above, or of numbers.)</p>
<p>If n is less than B then the number of (B,H) encodings of length exactly n is <code>(H^(n-1) * L)</code>. The number of (B,H) encodings of length exactly B is <code>(H^(B-1) * (L+H))</code>. The sum of these values for all n in <code>[1..B]</code> is the total size of the encoding set for a (B,H) coding. It is called <em>Card(B,H)</em> and is therefore defined as:</p>
<pre class="codeblock"><code>  Card(B,H) = (L * (1-H^B)/(1-H)) + H^B
    if H&gt;1, or else
  Card(B,1) = B*255+1
</code></pre>
<p>If H is 256, there are no low bytes, and the encoding set consists of all possible sequences of exactly B bytes, and Card(B,H) is <code>256^B</code>.</p>
<p>Otherwise, the encoding set consists of sequences of various lengths, from 1 to B inclusive. In particular, there are L one-byte sequences. We will use these elsewhere to encode the &quot;favored&quot; integers of the highest frequency. Note that the encoding rules specified elsewhere in this document are designed to produce smaller integers more frequently than larger ones.</p>
<p>Note that L can be viewed as a &quot;sharpness&quot; parameter, expressing the sharpness of the distribution about zero of the expected values to be encoded. The larger L is, the more the encoding favors distributions of values which are close to zero, and rarely far from it. Larger H values favor &quot;flatter&quot; distributions, up to H=256, L=0, which favorably encodes completely random data within the range of the coding.</p>
<h4 id="definition-of-decoded-whole-number-values">6.1.3. Definition of Decoded Whole Number Values</h4>
<p>The range of a (B,H) coding is the integers in <code>[0..Card(B,H)-1]</code>. (Note that this range applies only to the unsigned codings introduced so far in this section.)</p>
<p>Given the sequence of N byte values b[0] .. b[N-1], the sorting-based definition given above implies that the decoded integer value of this byte sequence is the little-endian base-H scaled sum of the bytes, and is called <em>Decode(B,H; b)</em>:</p>
<pre class="codeblock"><code>  Decode(B,H; b[*]) = Sum[0&lt;=i&lt;N]( b[i] * H^i )
</code></pre>
<p>As a consequence of this definition, each byte sequence in the encoding set corresponds uniquely to an arithmetic integer value in that range. This correspondence may be observed by ordering the byte sequences first by length, and second according to their antilexicographic (little-endian) order. Each element in resulting sequence decodes into its own zero-based index within the sequence.</p>
<p>Note that the number zero is always encoded by a sequence of B zero bytes (if H is 256) or else by single zero byte.</p>
<p>The largest encoded arithmetic value is always encoded by a sequence of B bytes of value 255.</p>
<p>Note that the (B,H) encodings (1,256), (2,256), and (4,256) are identical with the conventional little-endian representations of unsigned bytes, unsigned 16-bit integers, and unsigned 32-bit integers.</p>
<p>Note that some may represent arithmetic values greater than <code>2^31-1</code> or even <code>2^32-1</code>. This is a feature of the (B,H) coding scheme. (But sometimes intermediate 64-bit values are required when multiple sign bits are being used, as described below. The rules given below for signed values require the compressor to emit the simplest encoding that will suffice to transmit the required 32-bit integer, even if more complex sequences would produce the same 32-bit value, after truncation.)</p>
<p>Note that implementations are not always free to truncate intermediate values when computing (B,H) coding values. However, the final decoded values (after restoration of signs) will always fit in 32 bits, as described in the next section.</p>
<h4 id="encoding-of-signed-integers">6.2. Encoding of Signed Integers</h4>
<p>In order to encode signed 32-bit numbers we add another parameter to the (B,H) coding scheme.</p>
<table>
<caption style="display:none">
encoding of signed integers
</caption>
<tr style="text-align:center">
<th id="signed_integers_encoding_n">
Name
</th>
<th id="signed_integers_encoding_r">
Range
</th>
<th id="signed_integers_encoding_m">
Meaning
</th>
</tr>
<tr>
<td headers="signed_integers_encoding_n">
B
</td>
<td headers="signed_integers_encoding_r">
[1..5]
</td>
<td headers="signed_integers_encoding_m">
maximum byte length
</td>
</tr>
<tr>
<td headers="signed_integers_encoding_n">
H
</td>
<td headers="signed_integers_encoding_r">
[1..256]
</td>
<td headers="signed_integers_encoding_m">
number of high byte values
</td>
</tr>
<tr>
<td headers="signed_integers_encoding_n">
L
</td>
<td headers="signed_integers_encoding_r">
[0..255]
</td>
<td headers="signed_integers_encoding_m">
number of low byte values, defined as (256-H)
</td>
</tr>
<tr>
<td headers="signed_integers_encoding_n">
S
</td>
<td headers="signed_integers_encoding_r">
[0..2]
</td>
<td headers="signed_integers_encoding_m">
number of sign bits
</td>
</tr>
</table>
<p>The whole number U obtained from a (B,H) coding is converted to a signed 32-bit value X in a manner which depends on the parameter S. This process is called <em>sign conversion</em>.</p>
<p>Informally, sign conversion is performed by 32-bit truncation if S=0. Otherwise, the low-order bits of U are collectively treated as a sign bit, so that X will be negative only if all sign bits are set. The two conversions from U to positive X and U to negative X are independently dense and monotonic in opposite directions, as defined below.</p>
<p>Unlike the (B,H) coding, a (B,H,S) coding represents only numbers in a specifically defined range, which is never larger than <code>[-2^31..2^31-1]</code>.</p>
<p>In what follows, for each (B,H,S) coding, we define Range(B,H,S), and the method used to represent 32-bit signed values with that coding.</p>
<p>A (B,H) encoding byte sequence is not a legal input to a corresponding (B,H,S) coding if it represents a whole number U which does not convert into the range of the (B,H,S) coding. Also, if there are two byte sequences encoding values U1 and U2 which both map into the same point X in the signed range, only the byte sequence for the smaller of U1 and U2 is legal.</p>
<p>Thus, a (B,H,S) coding may have a smaller cardinality than the corresponding (B,H) coding, due to illegal encoding byte sequences.</p>
<p>The range of a (B,H,S) coding contains all 32-bit signed integers <code>[-2^31..2^31-1]</code> if Card(B,H) is <code>2^32</code> or more. (Negative values are represented by 31-bit unsigned overflow.) If the coding encodes fewer unsigned values, the top of its range is clipped to <code>2^31-1</code>, and the bottom of its range is clipped to <code>-2^31</code>.</p>
<p>More precisely, the range of a (B,H,S) coding is called <em>Range(B,H,S)</em> and is defined (partially, for S=0) as:</p>
<pre class="codeblock"><code>  Range(B,H,S) = [-2^31..2^31-1]
    if S=0, Card(B,H) &gt;= 2^32, or
  Range(B,H,S) = [0..2^31-1]
    if S=0, 2^31 &lt; Card(B,H) &lt; 2^32, or else
  Range(B,H,S) = [0..Card(B,H)-1]
    if S=0, Card(B,H) &lt;= 2^31
</code></pre>
<p>A compressor is not allowed to emit a byte sequence which, when interpreted according to the current coding, decodes to a value outside of that coding's range.</p>
<p>(Note that decompressors can produce arbitrary answers for out-of-range codings, since compressors are not allowed to emit them. This allows decompressors to use 32-bit arithmetic for most calculations, ignoring the possibility of undesired wraparond.)</p>
<p>If S&gt;0, the decoding of a byte sequence is performed first by decoding it as a (B,H) coding, and then by converting the decoded whole number into a signed 32-bit number. This sign conversion depends only on the arithmetic value U obtained from the (B,H) coding, and on the value of S. The arithmetic value must be preserved beyond 32 bits of precision, if the sign conversion will produce a value within the range of the coding. If the cardinality of the (B,H) coding is <code>2^32</code> or more, the (B,H,S) coding produces all possible signed 32-bit negative values, by 32-bit truncation of the intermediate unsigned whole number. The intermediate unsigned arithmetic can be carried out (with some care) using 32-bit unsigned numbers, or it can be carried out on 64-bit signed or unsigned numbers.</p>
<p>More precisely, the sign conversion operation <em>SignConvert(S;U)</em> is defined as:</p>
<pre class="codeblock"><code>  SignConvert(S; U) = Cast32(U)
    if S==0; or
  SignConvert(S; U) = U - Floor(U / 2^S)
    if S&gt;0, (U % 2^S) &lt; 2^S-1, Card(B,H) &lt; 2^32
  SignConvert(S; U) = Cast32(U - Floor(U / 2^S))
    if S&gt;0, (U % 2^S) &lt; 2^S-1, Card(B,H) &gt;= 2^32
  SignConvert(S; U) = -Floor(U / 2^S)-1
    if S&gt;0, (U % 2^S) == 2^S-1
</code></pre>
<p>The conversion from a large unsigned number of a negative 32-bit number via wraparound is simply the familiar down-cast to a signed 32-bit int. It may be defined mathematically as:</p>
<pre class="codeblock"><code>  Cast32(U) = ((U + 2^31) mod 2^32) - 2^31
</code></pre>
<h5 id="further-discussion-of-sign-conversion">6.2.1. Further Discussion of Sign Conversion</h5>
<p>Note that sign conversion always maps zero to zero. The reader may also verify that, if S&gt;0, the range of SignConvert includes [-1..1], and that it is dense and monotonic in any wholly positive or wholly negative sub-range.</p>
<p>As a consequence of the definition of <code>SignConvert(S;U)</code>, the S low-order bits of U function as a sign bit. In effect, U is partitioned into a sign field U0 (consisting of the S low-order bits) and a significand U1 (consisting of all other bits of U).</p>
<p>In this alternative view of the definition of <code>SignConvert</code>, if all S bits of U0 are set, then the decoded signed value is the ones complement of U1. (Since this includes the indefinite number of zero high-order bits of U, the resulting value is arithmetically negative.)</p>
<p>Otherwise, if some of the S bits of U0 are clear, then the significand U1 is scaled by the number of possible values of U0 (i.e., (2^2)-1 if S is 2) and U0 is added back in.</p>
<p>This provides a one-to-one correspondence between some portion of the arithmetic interval <code>[0..Card(B,H)-1]</code> and <code>Range(B,H,S)</code>.</p>
<p>The integers &quot;favored&quot; by this encoding are those of small magnitude, but they can have either sign. If S is one, the encoding has a balanced number of positive and negative favored values. If S is two (or more), the encoding is skewed toward positive numbers, but also favors a few negative numbers. We use such codings elsewhere to encode values, such as branch displacements or deltas of mostly-sorted data, which are usually positive but sometimes negative.</p>
<p>Note that if S=1, this definition of sign conversion is equivalent to an unsigned right shift followed by an exclusive-or of the sign bit with all remaining bits:</p>
<pre class="codeblock"><code>  SignConvert(1; U) = (U &gt;&gt;&gt; 1) ^ -(U &amp; 1)
</code></pre>
<p>For S&gt;0, Range(B,H,S) is simply defined as the intersection of the 32-bit signed range <code>[-2^31..2^31-1]</code> with the set <code>SignConvert(S; [0..Card(B,H)-1])</code>, obtained by element-wise application of sign conversion to every arithmetically representable value of (B,H). Therefore, we can complete the definition of <em>Range</em> as follows:</p>
<pre class="codeblock"><code>  Range(B,H,S) = [-2^31..2^31-1]
    if Card(B,H) &gt;= 2^32, or
  Range(B,H,S) = [0..2^31-1]
    if S=0, 2^31 &lt; Card(B,H) &lt; 2^32, or else
  Range(B,H,S) = [0..Card(B,H)-1]
    if S=0, Card(B,H) &lt;= 2^31

  Range(B,H,S) = [max(  -2^31, min SignConvert(S; Range(B,H,0)) )
               .. min( 2^31-1, max SignConvert(S; Range(B,H,0)) )]
</code></pre>
<p>(Note: When computing the bounds of a signed encoding (B,H,S), it is useful to start with the largest unsigned value M of (B,H,0) and perform sign-conversion on M, M-1, M-2, etc., noting the first positive and the first negative value to be encountered. These will be the inclusive bounds of the signed encoding's range.)</p>
<h4 id="attributes-of-codings">6.3. Attributes of Codings</h4>
<p>The cardinality of a (B,H) coding was defined above:</p>
<pre class="codeblock"><code>  Card(B,H) = (L * (1-H^B)/(1-H)) + H^B
</code></pre>
<p>The cardinality of a (B,H,S) coding is determined by that of its range:</p>
<pre class="codeblock"><code>  Card(B,H,S) = Card Range(B,H,S) &lt;= Card(B,H)
</code></pre>
<p>As defined, the range of any coding (B,H,S) is dense about zero and can therefore be expressed as a closed interval:</p>
<pre class="codeblock"><code>  Range(B,H,S) = [Min(B,H,S)..Max(B,H,S)]
  -2^31 &lt;= Min(B,H,S) &lt;= 0
  0     &lt;  Max(B,H,S) &lt;= 2^31-1
</code></pre>
<p>Certain additional attributes can be predicated of codings. A coding can either be signed or not, and it can be a full-range coding, or a sub-range coding (or neither).</p>
<p>A (B,H,S) coding is <em>signed</em> if it can encode at least one negative value. This is true if and only if S is non-zero or S is zero and Card(B,H) is 2^32 or more.</p>
<p>A (B,H,S) coding is <em>full-range</em> if Range(B,H,S) is <code>[-2^31..2^31-1]</code>.</p>
<p>A sub-range coding delivers less than 2^31 distinct values. More precisely, a coding (B,H,S) is <em>sub-range</em> if Card(B,H,S) &lt;= <code>2^31-1</code>. (Some codings are neither full-range nor sub-range codings.)</p>
<p>As a consequence of these definitions, any coding for which B&lt;=3 is a sub-range coding. Longer codings can also be sub-ranges if they are &quot;sharp&quot; enough. Some examples are (4,192,0), (5,32,0), and (5,32,1).</p>
<p>Also, the unsigned coding (4,256,0) is full-range, as is the signed version (4,256,1), but not the doubly-signed version (4,256,2).</p>
<p>The coding (4,255,0) is neither a sub-range nor a full-range coding, since its cardinality is 2^31. It represents only non-negative 32-bit integers, but its cardinality cannot be so represented.</p>
<h4 id="encoding-of-correlated-sequences">6.4. Encoding of Correlated Sequences</h4>
<p>Every single integer in the archive format is encoded according to some coding in the scheme of (B,H,S) codings. In addition, special attention is paid to sequences of integers (in the &quot;bands&quot; described elsewhere) which show statistical regularity. In particular, if a sequence of integers is found to exhibit a pattern of small, regular first-order differences, those differences may be encoded in place of the values themselves. This is described by a fourth coding parameter added to the (B,H,S) scheme.</p>
<table>
<caption style="display:none">
encoding of correlated sequences
</caption>
<tr style="text-align:center">
<th id="corr_seq_enc_n">
Name
</th>
<th id="corr_seq_enc_r">
Range
</th>
<th id="corr_seq_enc_m">
Meaning
</th>
</tr>
<tr>
<td headers="corr_seq_enc_n">
B
</td>
<td headers="corr_seq_enc_r">
[1..5]
</td>
<td headers="corr_seq_enc_m">
maximum byte length
</td>
</tr>
<tr>
<td headers="corr_seq_enc_n">
H
</td>
<td headers="corr_seq_enc_r">
[1..256]
</td>
<td headers="corr_seq_enc_m">
number of high byte values
</td>
</tr>
<tr>
<td headers="corr_seq_enc_n">
L
</td>
<td headers="corr_seq_enc_r">
[0..255]
</td>
<td headers="corr_seq_enc_m">
number of low byte values, defined as (256-H)
</td>
</tr>
<tr>
<td headers="corr_seq_enc_n">
S
</td>
<td headers="corr_seq_enc_r">
[0..2]
</td>
<td headers="corr_seq_enc_m">
number of sign bits
</td>
</tr>
<tr>
<td headers="corr_seq_enc_n">
D
</td>
<td headers="corr_seq_enc_r">
[0..1]
</td>
<td headers="corr_seq_enc_m">
delta encoding order
</td>
</tr>
</table>
<p>If D is zero, no differencing is performed, and the (B,H,S,0) coding is in all ways identical to the corresponding (B,H,S) coding. If D is one, the values are encoded in terms of their successive differences.</p>
<p>(Note: Sequences which are mostly monotonically ascending will often be favorably encoded using unsigned delta codings of the form (5,H,0,1).)</p>
<p>Suppose a sequence of values X[i] is given, for some range of i in [0..N-1]. This sequence will be representable by a (B,H,S,1) coding only if the (B,H,S) coding is a sub-range or a full-range coding. (If it is neither, there is no legal (B,H,S,1) coding.)</p>
<p>The sequence X[i] will be representable, only if there is a series of &quot;delta values&quot; D[i] whose partial sums <code>Sum[j&lt;=i](D[j])</code> can represent the values X[i].</p>
<p>Each (B,H,S,1) coding has a range, in which all X[i] values must lie. This range is defined as <code>Range(B,H,S,1) = Range(B,H,0)</code>. The range of a delta coding (B,H,S,1) contains negative numbers only if it is based on a full-range coding (B,H,S). Otherwise, the delta coding can only represent non-negative numbers. In practice, this is not a severe restriction, since in practice very few band elements are negative.</p>
<p>The partial sums Sum[j&lt;=i](D[j]) are allowed to leave the range, but the final X[i] values are always brought back into range by adding or subtracting a multiple of Card Range(B,H,0).</p>
<p>More precisely:</p>
<pre class="codeblock"><code>  X[i] = Sum[j&lt;=i](D[j]) mod Card(B,H,0)
    if (B,H,S) is sub-range
  X[i] = (int32) Sum[j&lt;=i](D[j])
    if (B,H,S) is full-range
</code></pre>
<p>(Here, the cast to <code>int32</code> denotes truncation to 32 bits.)</p>
<p>Note that implementations can simply ignore 32-bit wraparound when computing partial sums, if the coding is full-range. Otherwise, more care must be taken to bring partial sums back into range by subtracting or adding multiples of the range cardinality. Also, 32-bit wraparound may be a hazard for ranges of size 2^30 or more. It is possible to implement this using only 32-bit signed arithmetic.</p>
<h4 id="encodings-of-uncorrelated-values">6.5. Encodings of Uncorrelated Values</h4>
<p>The coding methods described so far are designed to favor values which, on average, tend to be near zero or near the preceding value. Some data sets have marked statistical patterns in which values have only weak arithmetic relations (to zero or to each other), but which show strong repetitive patterns, especially in their first-order statistics.</p>
<p>The compressor may elect to use a population-based coding transformation in such cases. This transformation takes a sequence S of N arithmetic values and converts it into three value sequences:</p>
<ul>
<li>F a table (arbitrary length K+1 &lt;&lt; N) of favored values</li>
<li>T a sequence (length N) of value tokens</li>
<li>U a sequence (length &lt;&lt; N, depends on T) of unfavored values</li>
</ul>
<p>Each of these sequences (F, T, and U) is in turn treated as a sub-band, and transmitted with an independent encoding. Each non-zero value in T indexes a value from F, while each zero value in T selects (in order) a value from U:</p>
<pre class="codeblock"><code>  S[i] = F[T[i]-1]
    if T[i] != 0
  U = { S[i] such that T[i] == 0 }
</code></pre>
<h5 id="table-of-favorites">6.5.1. Table of Favorites</h5>
<p>The table F contains any number of integer values. There is no restriction on their number or identity, except that no value in F may be repeated, except the last, and F must not contain unused values. The last value in F must be a repetition of an earlier occurrence of a &quot;sentinel value&quot; of F. This sentinel marks the end of the table F, allowing the decompressor to prepare to read T and U.</p>
<p>The &quot;central value&quot; X of F is defined as that element of F which is arithmetically closest to zero. If F contains both a positive X and a negative -X of minimal absolute value, then -X is defined as the central value. (I.e., a negative sign is the tie-breaker. The central value is chosen so as to have a favorable encoding.)</p>
<p>(Note that implementations may compare values for centrality by using the 32-bit signed int expression <code>(X&gt;&gt;31)^(X&lt;&lt;1)</code> as an unsigned comparison key.)</p>
<p>A valid sentinel value is either the central value of F, or the last value of F. Thus, while parsing F, the decompressor must look for a repetition of either the central value (so far) or of the immediately previous value.</p>
<p>Let K be the number of values in F, ignoring the repetition of the sentinel value. In the next band, values in <code>[1..K]</code> will refer (as 1-origin indexes) to corresponding elements of F.</p>
<h5 id="sequence-of-tokens">6.5.2. Sequence of Tokens</h5>
<p>The sequence T follows the table F, and encodes the input of the population transformation in a direct, element-by-element manner.</p>
<p>Each element of T is a token for either a favored or an unfavored value, encoded in the arithmetic range <code>[0..K]</code>. Each non-zero value corresponds in order to an element of F, and produces that favored value. Each zero value in T is a placeholder for an &quot;unfavored&quot; value, which is still unknown.</p>
<p>As mentioned above, each element of F must be referred to by at least one element of T. That is, the following two sets must be the same:</p>
<pre class="codeblock"><code>  { F[T[i]-1] such that T[i] != 0 }
  { F[j] }
</code></pre>
<p>The statistics of the sequence T are quite favorable for compact encoding in a suitable (B,H) scheme, assuming that the coder made good choices for the contents of F. Generally speaking, the most commonly occurring input values should be given early positions in F.</p>
<p>A greedy algorithm could sort the input values by number of occurrences and place the most common values at the front of F. This would be likely to produce an improved encoding for the input. Such techniques are neither mandated nor discouraged by this specification.</p>
<h5 id="sequence-of-unfavored-values">6.5.3. Sequence of Unfavored Values</h5>
<p>The third subsequence consists of values which were not representable by indexes into the table F. Let Z be the number of zeroes encountered in T. There is a ordered, one-to-one correspondence between the Z zeroes in T and all the Z values of U.</p>
<p>Taken together, the elements of F and U selected by the elements of T must be identical in value and order to the input of the population transformation.</p>
<p>The decompressor can then read F into memory, read T into memory, and then make a second pass over T, translating token values, either referring to F or reading from U as necessary.</p>
<h4 id="adaptive-encodings">6.6. Adaptive Encodings</h4>
<p>Sometimes, in a very long sequence of values, the statistics will change slowly, making an initially suitable coding tactic become unsuitable.</p>
<p>An adaptive coding method handles this situation by allowing value sequences to be partitioned (effectively into sub-bands), with an independent coding used locally in each part.</p>
<p>An adaptive coding method is specified by a count K, a coding method A which will be used to encode K values, and another coding method B which will handle the rest of the values.</p>
<p>Since bands are sized by context, when an adaptive coding method is applied to the bytes of an encoded band, the method will be provided in advance with the count N of values to decode. Thus, after the method A has decoded K values, the method B will be used to decode the rest of the (N-K) values in the band.</p>
<h4 id="meta-coding">6.7. Meta-Coding</h4>
<p>Every band in the Pack200 archive format whose primary encoding is not BYTE1 is optionally preceded by a series of bytes called a <em>band coding specifier</em> which specify a secondary coding or codings used in that band, instead of the primary coding. The decompressor must parse this coding specifier and save it away before it reads any of the band elements. In a few extra bytes of information, the coding specifier determines exactly how the subsequent bytes are to be decoded into band values.</p>
<p>Any compressor may elect not to provide a band coding specifier, in which case the band's primary encoding governs the transmission of elements. If the encoding of the first band element under the primary encoding accidentally appears to be a band coding specifier, the compressor is obligated to transmit an explicit band coding specifier that reaffirms the band's primary encoding. This is rare, because (as noted below) band coding specifiers present themselves as negative numbers in the primary encoding, and negative numbers are rare in most bands.</p>
<h5 id="coding-specifier-structure">6.7.1. Coding Specifier Structure</h5>
<p>The symbolic structure of a band coding specifier is determined by the following grammar. (This grammar is independent of the grammar governing band structure, or any other grammar appearing in other parts of this specification.)</p>
<pre class="codeblock"><code>  BandCodingSpecifier:
        (Default | BHSDCode | RunCode | PopCode)
  BHSDCode:
        CanonicalBHSDCode | ArbitraryBHSDCode
  CanonicalBHSDCode:
        ( &#39;(1,256,0)&#39; | &#39;(1,256,1)&#39; | ... )
  ArbitraryBHSDCode:
        &#39;arb&#39; ( B H S D )
  B, H, S, D:
        Integer
  RunCode:
        &#39;run&#39; K ACode BCode
  K:
        Integer
  ACode:
        (Default | BHSDCode | PopCode)
  BCode:
        (Default | BHSDCode | RunCode | PopCode)
  PopCode:
        &#39;pop&#39; ( FCode TCode UCode )
  FCode:
        (Default | BHSDCode | RunCode)
  TCode:
        (Default | BHSDCode | RunCode)
  UCode:
        (Default | BHSDCode | RunCode)
  Integer:
        ( &#39;0&#39; | &#39;1&#39; | ... )
  Default:
        &#39;default&#39;
</code></pre>
<p>Note that adaptive coding methods (&quot;RunCode&quot; nonterminals) can be chained via the &quot;BCode&quot; nonterminal, but cannot be nested directly via the &quot;ACode&quot; nonterminal. (As the grammar shows, they may be nested indirectly via the &quot;PopCode&quot; nonterminal.)</p>
<p>Also, population coding methods can contain adaptive coding methods, and vice versa. However, although the grammar does not show this fact, population coding methods must not be nested, even indirectly.</p>
<p>Not all possible integer values of K and L are equally well expressible. The intended values of K are commensurate with compressor windows, and the intended values of L are sharpness parameters for BHS encodings.</p>
<h5 id="coding-specifier-semantics">6.7.2. Coding Specifier Semantics</h5>
<p>At any point, band contents are decoded under the control of three pieces of information:</p>
<ul>
<li>N, an expected number of band values to decode, or &quot;infinity&quot;</li>
<li>D, a default BHSD coding</li>
<li>S, a coding specifier</li>
</ul>
<p>We denote the application of S in the context of N and D as &quot;S(N,D)&quot;. This application decodes up to N elements of transmitted band data.</p>
<p>Just before a band is received, the decompressor knows an expected band length N and a default coding method D, specified statically as the band's primary encoding. The decompressor then reads zero or more bytes which constitute a band encoding specifier, and decodes N elements of band data based on the band encoding specifier.</p>
<p>When the coding specifier is 'default', N values are decoded using the default coding D, which is the band's primary encoding. (This rule is necessary if the band's first element appears to introduce a non-empty coding specifier. Such a default coding specifier is the only kind that a compressor is obligated to emit; the rest are all optional.)</p>
<p>When the coding specifier is another BHSDCode, N values are decoded using that coding. The ambient default D is ignored.</p>
<p>When the coding specifier is a 'run' of K, ACode, BCode, two steps are taken. First, the specifier ACode is given control, as ACode(K,D). That is, N is temporarily set to K. Second, the specifier BCode is given control as BCode(N-K,D). (Note: If N is infinity, N-K will also be infinity.) In both steps, D remains unchanged, so that occurrences of 'default' for ACode or BCode cause D to be used.</p>
<p>It is illegal for a 'run' coding specifier to specify a K of zero, or for it to be used to decode a run of K or fewer values.</p>
<p>When the coding specifier is a 'pop' of FCode, TCode, UCode, three steps are taken. First, FCode is applied as FCode(infinity, D). The decoding of the F values stops when the first duplicate value is encountered. (As specified in the section above on population coding, that duplicate value acts as a sentinel, and must be either the most &quot;central&quot; value read, or else the value immediately previous to the sentinel value.) Let K be the number of unique decoded values.</p>
<p>During the decoding of the F values by FCode, every 'run' specifier in FCode must exhaust its count 'K' without decoding the sentinel value. That is, the sentinel must be decoded by the last simple BHSD coding in FCode.</p>
<p>In the second step, a different coding TCode is used, since the T values are expected to be a dense encoding. TCode is applied as TCode(N,D), and the tokens are read which determine the band values to be delivered. (Note that a 'pop' coding method can only be applied if the N value supplied is finite. This will be true, since the only bands which are read with an infinite N are byte bands such as <code>bc_codes</code>.) Let Z be the number of zeroes decoded using TCode.</p>
<p>The third step is to use UCode to decode Z values, using the original default encoding D. UCode is applied as U(Z,D). The resulting band is produced from the T sequence, as documented above, by replacing zeroes in the T sequence by successive U values, and replacing other elements of the T sequence by those indexed in the F sequence.</p>
<p>It is illegal for a 'pop' coding specifier to be used to decode a run of no values, or of an infinite number of values. If Z (the number of unfavored values) is zero, it is illegal for UCode to be anything other than 'default'.</p>
<h5 id="coding-specifier-meta-encoding">6.7.3. Coding Specifier Meta-Encoding</h5>
<p>The compressor uses a tense, byte-oriented encoding to transmit the band encoding specifier. Although the &quot;little language&quot; above allows a wide range of encodings, in practice many of them are similar in performance and applicability. It is not necessary or desirable to allow the compressor complete freedom to specify any conceivable band encoding specifier. Instead, the meta-encoding described in this section allows the compressor to select from a limited but useful set of secondary encodings. It is up to the compressor to make a choice that improves compression; the heuristic or algorithm that controls such a selection is beyond the scope of this specification.</p>
<p>The common band coding specifier of 'default' is encoded in a way that often requires no extra bytes. If the band has no elements, no parsing at all is done. Otherwise, if the band's default encoding is of variable length, the decompressor is obligated to decode one value X from the initial bytes of the band using the band's default coding D. If possible, the value X is converted into an unsigned byte value XB, which is taken to be the first byte of a band coding specifier, and X will be discarded. Otherwise, the band coding specifier is taken to be 'default', and so D is applied to the entire band, including the bytes which produced the initial value X.</p>
<p>D must be of the form (B,H,S) or (B,H,S,D), where B&gt;1 and H&lt;256. The value is D is irrelevant to the decoding of the first value, and the decoding of X is done using (B,H,S,0). If S is not zero, and if the value X is in the range [-256..-1], the coding specifier byte XB is defined as <code>XB = (-1-X)</code>, and X is discarded. Otherwise, if S is zero, and if the value of X is in the range [(256-H)..(511-H)], the coding specifier byte XB is defined as <code>XB = (X-(256-H))</code>, and X is discarded. Otherwise, there is not a coding specifier byte XB, and X is the first band value, as described above.</p>
<p>The value XB, if produced, is taken to be the initial byte of a coding specifier preceding the actual band data. This specifier is parsed, starting with XB, and continuing (if necessary) with bytes bytes taken from <code>band_headers</code>. The parsed specifier is then used to control decoding, starting at the next byte, of all band elements.</p>
<p>If the band really does start with an element X1 in a range (<code>[-256..-1]</code> or <code>[L,L+255]</code>) that requires the production of a band specififer byte XB, but the compressor wishes to use the default encoding, the compressor is required to specify a band header, lest X1 mislead the decompressor. If the compressor wishes to keep the default coding, it must in such cases specify an explicit coding specifier of 'default', using an XB value of zero (as specified below). This zero XB is transmitted, depending on the default encoding, as an X value of -1 (usually the byte 1) or of L (usually the bytes 192,0).</p>
<p>(An immediate consequence of this design is that byte bands can never have non-default encodings, but all other bands can, since all the other bands have default encodigns which are variable length and have a large dynamic range. The &quot;escape&quot; values chosen for X are rare in practice, so they are not usually confused with real band data. Adding an extra zero value to reaffirm the default will always cost one extra byte before the actual band data, and no extra bytes in the <code>band_headers</code> band. In general, the encoding of explicit X values will always require two bytes if S is zero, and at most two bytes if S is not zero.)</p>
<p>The band <code>band_headers</code> transmits the non-initial band header bytes (if any) of each band that has a band header. The order of transmission is consistent with the overall order of all bands in the archive, as given in the present specification's band grammar. The length of <code>band_headers</code> is independently specified (as <code>#band_headers_size</code>) in the archive header. (It should be clear that the decompressor needs to find the end of <code>band_headers</code> before it can read any further bands.)</p>
<p>Thus, the encoding of a coding specifier consists of a sequence of bytes: an initial byte XB, and zero or more non-initial bytes taken from <code>band_headers</code>. The encodings of the little language specified in the previous section are as follows. The encoding 'default' is a zero byte. Of all the possible BHSDCode encodings, a sequence of 115 <em>canonical encodings</em> (defined below) is selected to cover the expected range of uses. A BHSDCode is represented as a single byte whose value is the index (1-based) of the selected canonical coding.</p>
<pre class="codeblock"><code>  Enc{default}  = (0)
  Enc{CanonicalBHSDCode} = value in [1..115]
</code></pre>
<p>The special value 116 introduces an arbitrary, possibly non-canonical BHSD code, described in the following byte.</p>
<pre class="codeblock"><code>  Enc{ arb ( B H S D ) } =
      116
    &amp; (D:[0..1] + 2*S[0..2] + 8*(B:[1..5]-1))
    &amp; (H[1..256]-1):
</code></pre>
<p>The B value must be in the range [1..5]. The S value must be in the range [0..2]. The H value must be in the range [1..256]. The D value must be in the range [0..1]. (These ranges are inclusive.) In addition, if B is 1, H must be 256, and if H is 256, B must not be 5.</p>
<p>The 'run' construct encodings begin with a byte in [117..140], and may be followed by an optional byte KB and then by one or two encoding specifiers ACode and BCode. The offset from 117 represents bitwise the following data:</p>
<ul>
<li>a two-bit field KX</li>
<li>a bit KBFlag</li>
<li>a bit ADef (ABDef == 1)</li>
<li>a bit BDef (ABDef == 2)</li>
</ul>
<p>The last two bits are jointly encoded in the value ABDef. They are never both true.</p>
<pre class="codeblock"><code>  Enc{ run ( K ACode BCode ) } =
      (117 + (KX:[0..3]) + 4*(KBFlag:[0..1]) + 8*(ABDef:[0..2]))
    &amp; KB: one of [0..255] if KBFlag=1
    &amp; Enc{ ACode } if ADef=0  (ABDef != 1)
    &amp; Enc{ BCode } if BDef=0  (ABDef != 2)
</code></pre>
<p>After the leading byte is parsed, a byte KB is expected if the KBFlag is set, otherwise KB is implicitly given the value 3.</p>
<p>The K value for the 'run' construct can take a range of values, and is determined as follows:</p>
<pre class="codeblock"><code>  K = (KB+1) * 16^KX
</code></pre>
<p>The ACode coding is understood to be 'default' if the ADef bit is set. Otherwise, the representation of ACode is parsed next. Finally, the BCode coding is understood to be 'default' if the BDef bit is set. Otherwise, the representation of BCode is parsed last. Both ADef and BDef may be clear, but both may not be set.</p>
<p>The 'pop' construct encodings begin with a byte in [141..188], and may be followed by one, two, or three encoding specifiers, FCode, UCode, and TCode. The offset from 141 bitwise encodes the following data:</p>
<ul>
<li>a bit FDef</li>
<li>a bit UDef</li>
<li>a bit TDef (TDefL &gt; 0)</li>
<li>a value L in [1..11] if TDef=1</li>
</ul>
<p>The last two values are jointly encoded in the value TDefL.</p>
<pre class="codeblock"><code>  Enc{ pop ( FCode TCode UCode ) }
    = (141 + (FDef:[0..1]) + 2*UDef:[0..1] + 4*(TDefL:[0..11]))
    &amp; Enc{ FCode } if FDef=0
    &amp; Enc{ TCode } if TDef=0  (TDefL==0)
    &amp; Enc{ UCode } if UDef=0
</code></pre>
<p>If TDef is zero, an explicit encoding specifier determines TCode, and the L parameter is not present. If TDef is one, the L parameter is present and is derived from TDefL, according to the following table:</p>
<table>
<caption style="display:none">
relation of L parameter to TDefL
</caption>
<tr style="text-align:center">
<th id="l_param_tdefl_t">
TDefL
</th>
<th id="l_param_tdefl_l">
L
</th>
</tr>
<tr style="text-align:right">
<td headers="l_param_tdefl_t">
1
</td>
<td headers="l_param_tdefl_l">
4
</td>
</tr>
<tr style="text-align:right">
<td headers="l_param_tdefl_t">
2
</td>
<td headers="l_param_tdefl_l">
8
</td>
</tr>
<tr style="text-align:right">
<td headers="l_param_tdefl_t">
3
</td>
<td headers="l_param_tdefl_l">
16
</td>
</tr>
<tr style="text-align:right">
<td headers="l_param_tdefl_t">
4
</td>
<td headers="l_param_tdefl_l">
32
</td>
</tr>
<tr style="text-align:right">
<td headers="l_param_tdefl_t">
5
</td>
<td headers="l_param_tdefl_l">
64
</td>
</tr>
<tr style="text-align:right">
<td headers="l_param_tdefl_t">
6
</td>
<td headers="l_param_tdefl_l">
128
</td>
</tr>
<tr style="text-align:right">
<td headers="l_param_tdefl_t">
7
</td>
<td headers="l_param_tdefl_l">
192
</td>
</tr>
<tr style="text-align:right">
<td headers="l_param_tdefl_t">
8
</td>
<td headers="l_param_tdefl_l">
224
</td>
</tr>
<tr style="text-align:right">
<td headers="l_param_tdefl_t">
9
</td>
<td headers="l_param_tdefl_l">
240
</td>
</tr>
<tr style="text-align:right">
<td headers="l_param_tdefl_t">
10
</td>
<td headers="l_param_tdefl_l">
248
</td>
</tr>
<tr style="text-align:right">
<td headers="l_param_tdefl_t">
11
</td>
<td headers="l_param_tdefl_l">
252
</td>
</tr>
</table>
<p>If the L parameter is present, the TCode is derived from the K and L values. If K &lt; 256, then TCode is BYTE1 (1,255,0), and L is ignored. Otherwise, TCode is the (B,H,S) coding where S=0, H=(256-L), and B is the smallest value such that [0..K] is contained in Range(B,H,S). (It is illegal to specify an L so large that Range(5,256-L,0) does not contain K.)</p>
<p>The FCode coding is understood to be 'default' if the FDef bit is set. Otherwise, the representation of FCode is parsed immediately after the initial byte. The TCode coding is understood to be derived from K and L if the TDef bit is set. Otherwise, the representation of TCode is parsed next. Finally, the UCode coding is understood to be 'default' if the UDef bit is set. Otherwise, the representation of UCode is parsed last.</p>
<h5 id="canonical-bhsd-codings">6.7.4. Canonical BHSD Codings</h5>
<p>Here is the list of all the canonical BHSD codings. These codings are designed to match a diverse variety of band value ranges and statistics.</p>
<table>
<caption style="display:none">
list of all canonical BHSD codings
</caption>
<tr>
<th id="canon_bhsd_i">
index
</th>
<th id="canon_bhsd_b">
BHSD Coding
</th>
</tr>
<tr>
<td headers="canon_bhsd_i">
1
</td>
<td headers="canon_bhsd_b">
(1,256,0)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
2
</td>
<td headers="canon_bhsd_b">
(1,256,1)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
3
</td>
<td headers="canon_bhsd_b">
(1,256,0,1)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
4
</td>
<td headers="canon_bhsd_b">
(1,256,1,1)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
5
</td>
<td headers="canon_bhsd_b">
(2,256,0)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
6
</td>
<td headers="canon_bhsd_b">
(2,256,1)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
7
</td>
<td headers="canon_bhsd_b">
(2,256,0,1)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
8
</td>
<td headers="canon_bhsd_b">
(2,256,1,1)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
9
</td>
<td headers="canon_bhsd_b">
(3,256,0)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
10
</td>
<td headers="canon_bhsd_b">
(3,256,1)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
11
</td>
<td headers="canon_bhsd_b">
(3,256,0,1)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
12
</td>
<td headers="canon_bhsd_b">
(3,256,1,1)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
13
</td>
<td headers="canon_bhsd_b">
(4,256,0)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
14
</td>
<td headers="canon_bhsd_b">
(4,256,1)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
15
</td>
<td headers="canon_bhsd_b">
(4,256,0,1)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
16
</td>
<td headers="canon_bhsd_b">
(4,256,1,1)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
17
</td>
<td headers="canon_bhsd_b">
(5, 4,0)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
18
</td>
<td headers="canon_bhsd_b">
(5, 4,1)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
19
</td>
<td headers="canon_bhsd_b">
(5, 4,2)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
20
</td>
<td headers="canon_bhsd_b">
(5, 16,0)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
21
</td>
<td headers="canon_bhsd_b">
(5, 16,1)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
22
</td>
<td headers="canon_bhsd_b">
(5, 16,2)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
23
</td>
<td headers="canon_bhsd_b">
(5, 32,0)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
24
</td>
<td headers="canon_bhsd_b">
(5, 32,1)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
25
</td>
<td headers="canon_bhsd_b">
(5, 32,2)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
26
</td>
<td headers="canon_bhsd_b">
(5, 64,0)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
27
</td>
<td headers="canon_bhsd_b">
(5, 64,1)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
28
</td>
<td headers="canon_bhsd_b">
(5, 64,2)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
29
</td>
<td headers="canon_bhsd_b">
(5,128,0)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
30
</td>
<td headers="canon_bhsd_b">
(5,128,1)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
31
</td>
<td headers="canon_bhsd_b">
(5,128,2)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
32
</td>
<td headers="canon_bhsd_b">
(5, 4,0,1)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
33
</td>
<td headers="canon_bhsd_b">
(5, 4,1,1)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
34
</td>
<td headers="canon_bhsd_b">
(5, 4,2,1)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
35
</td>
<td headers="canon_bhsd_b">
(5, 16,0,1)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
36
</td>
<td headers="canon_bhsd_b">
(5, 16,1,1)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
37
</td>
<td headers="canon_bhsd_b">
(5, 16,2,1)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
38
</td>
<td headers="canon_bhsd_b">
(5, 32,0,1)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
39
</td>
<td headers="canon_bhsd_b">
(5, 32,1,1)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
40
</td>
<td headers="canon_bhsd_b">
(5, 32,2,1)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
41
</td>
<td headers="canon_bhsd_b">
(5, 64,0,1)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
42
</td>
<td headers="canon_bhsd_b">
(5, 64,1,1)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
43
</td>
<td headers="canon_bhsd_b">
(5, 64,2,1)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
44
</td>
<td headers="canon_bhsd_b">
(5,128,0,1)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
45
</td>
<td headers="canon_bhsd_b">
(5,128,1,1)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
46
</td>
<td headers="canon_bhsd_b">
(5,128,2,1)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
47
</td>
<td headers="canon_bhsd_b">
(2,192,0)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
48
</td>
<td headers="canon_bhsd_b">
(2,224,0)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
49
</td>
<td headers="canon_bhsd_b">
(2,240,0)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
50
</td>
<td headers="canon_bhsd_b">
(2,248,0)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
51
</td>
<td headers="canon_bhsd_b">
(2,252,0)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
52
</td>
<td headers="canon_bhsd_b">
(2, 8,0,1)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
53
</td>
<td headers="canon_bhsd_b">
(2, 8,1,1)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
54
</td>
<td headers="canon_bhsd_b">
(2, 16,0,1)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
55
</td>
<td headers="canon_bhsd_b">
(2, 16,1,1)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
56
</td>
<td headers="canon_bhsd_b">
(2, 32,0,1)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
57
</td>
<td headers="canon_bhsd_b">
(2, 32,1,1)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
58
</td>
<td headers="canon_bhsd_b">
(2, 64,0,1)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
59
</td>
<td headers="canon_bhsd_b">
(2, 64,1,1)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
60
</td>
<td headers="canon_bhsd_b">
(2,128,0,1)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
61
</td>
<td headers="canon_bhsd_b">
(2,128,1,1)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
62
</td>
<td headers="canon_bhsd_b">
(2,192,0,1)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
63
</td>
<td headers="canon_bhsd_b">
(2,192,1,1)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
64
</td>
<td headers="canon_bhsd_b">
(2,224,0,1)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
65
</td>
<td headers="canon_bhsd_b">
(2,224,1,1)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
66
</td>
<td headers="canon_bhsd_b">
(2,240,0,1)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
67
</td>
<td headers="canon_bhsd_b">
(2,240,1,1)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
68
</td>
<td headers="canon_bhsd_b">
(2,248,0,1)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
69
</td>
<td headers="canon_bhsd_b">
(2,248,1,1)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
70
</td>
<td headers="canon_bhsd_b">
(3,192,0)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
71
</td>
<td headers="canon_bhsd_b">
(3,224,0)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
72
</td>
<td headers="canon_bhsd_b">
(3,240,0)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
73
</td>
<td headers="canon_bhsd_b">
(3,248,0)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
74
</td>
<td headers="canon_bhsd_b">
(3,252,0)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
75
</td>
<td headers="canon_bhsd_b">
(3, 8,0,1)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
76
</td>
<td headers="canon_bhsd_b">
(3, 8,1,1)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
77
</td>
<td headers="canon_bhsd_b">
(3, 16,0,1)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
78
</td>
<td headers="canon_bhsd_b">
(3, 16,1,1)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
79
</td>
<td headers="canon_bhsd_b">
(3, 32,0,1)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
80
</td>
<td headers="canon_bhsd_b">
(3, 32,1,1)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
81
</td>
<td headers="canon_bhsd_b">
(3, 64,0,1)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
82
</td>
<td headers="canon_bhsd_b">
(3, 64,1,1)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
83
</td>
<td headers="canon_bhsd_b">
(3,128,0,1)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
84
</td>
<td headers="canon_bhsd_b">
(3,128,1,1)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
85
</td>
<td headers="canon_bhsd_b">
(3,192,0,1)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
86
</td>
<td headers="canon_bhsd_b">
(3,192,1,1)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
87
</td>
<td headers="canon_bhsd_b">
(3,224,0,1)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
88
</td>
<td headers="canon_bhsd_b">
(3,224,1,1)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
89
</td>
<td headers="canon_bhsd_b">
(3,240,0,1)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
90
</td>
<td headers="canon_bhsd_b">
(3,240,1,1)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
91
</td>
<td headers="canon_bhsd_b">
(3,248,0,1)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
92
</td>
<td headers="canon_bhsd_b">
(3,248,1,1)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
93
</td>
<td headers="canon_bhsd_b">
(4,192,0)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
94
</td>
<td headers="canon_bhsd_b">
(4,224,0)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
95
</td>
<td headers="canon_bhsd_b">
(4,240,0)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
96
</td>
<td headers="canon_bhsd_b">
(4,248,0)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
97
</td>
<td headers="canon_bhsd_b">
(4,252,0)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
98
</td>
<td headers="canon_bhsd_b">
(4, 8,0,1)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
99
</td>
<td headers="canon_bhsd_b">
(4, 8,1,1)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
100
</td>
<td headers="canon_bhsd_b">
(4, 16,0,1)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
101
</td>
<td headers="canon_bhsd_b">
(4, 16,1,1)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
102
</td>
<td headers="canon_bhsd_b">
(4, 32,0,1)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
103
</td>
<td headers="canon_bhsd_b">
(4, 32,1,1)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
104
</td>
<td headers="canon_bhsd_b">
(4, 64,0,1)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
105
</td>
<td headers="canon_bhsd_b">
(4, 64,1,1)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
106
</td>
<td headers="canon_bhsd_b">
(4,128,0,1)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
107
</td>
<td headers="canon_bhsd_b">
(4,128,1,1)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
108
</td>
<td headers="canon_bhsd_b">
(4,192,0,1)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
109
</td>
<td headers="canon_bhsd_b">
(4,192,1,1)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
110
</td>
<td headers="canon_bhsd_b">
(4,224,0,1)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
111
</td>
<td headers="canon_bhsd_b">
(4,224,1,1)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
112
</td>
<td headers="canon_bhsd_b">
(4,240,0,1)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
113
</td>
<td headers="canon_bhsd_b">
(4,240,1,1)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
114
</td>
<td headers="canon_bhsd_b">
(4,248,0,1)
</td>
</tr>
<tr>
<td headers="canon_bhsd_i">
115
</td>
<td headers="canon_bhsd_b">
(4,248,1,1)
</td>
</tr>
</table>
<h2 id="stability-of-decompressor-output">7. Stability of Decompressor Output</h2>
<p>From what has been said so far, it may appear that a decompressor has considerable free choice in its arrangement of class file contents. In the class file format, there are numerous degrees of freedom which have no effect on the meaning of the file. For example, constant pool entries, attribute lists, and class methods are presented in no significant order, and could be shuffled at will by the decompressor without changing the meaning of the Java application.</p>
<p>However, for any given Pack200 archive, every decompressor is required to produce a particular byte-wise image for each class file transmitted. This requirement is placed on decompressors in order to make it possible for compressors to transmit information, such as message digests, which relates to the eventual byte-wise contents of transmitted class files. This section describes the restrictions placed on every decompressor that makes the byte-wise contents of its output files a well-defined function of its input.</p>
<p>In general, the order of elements in a decompressed class file must be consistent with the transmission order in the Pack200 archive. For example, the order of a class's fields declared in the class file must correspond to the order in which that class's field descriptors were transmitted in the <code>field_descr</code> band. (This also happens to correspond to the order in the <code>field_flags</code> bands.) This table gives all of the required correspondences of class file order with archive transmission order:</p>
<table>
<caption style="display:none">
required correspondences of class file order with archive transmission order
</caption>
<tr style="text-align:center">
<th id="archive_transmission_order_e">
element in<br /> class file
</th>
<th id="archive_transmission_order_b">
band which<br /> determines order
</th>
</tr>
<tr>
<td headers="archive_transmission_order_e">
implemented interfaces
</td>
<td headers="archive_transmission_order_b">
class_interface
</td>
</tr>
<tr>
<td headers="archive_transmission_order_e">
declared fields
</td>
<td headers="archive_transmission_order_b">
field_descr
</td>
</tr>
<tr>
<td headers="archive_transmission_order_e">
declared methods
</td>
<td headers="archive_transmission_order_b">
method_descr
</td>
</tr>
<tr>
<td headers="archive_transmission_order_e">
code handler list
</td>
<td headers="archive_transmission_order_b">
code_handler_start_P
</td>
</tr>
<tr>
<td headers="archive_transmission_order_e">
class attribute list
</td>
<td headers="archive_transmission_order_b">
class_flags, class_attr_indexes
</td>
</tr>
<tr>
<td headers="archive_transmission_order_e">
field attribute list
</td>
<td headers="archive_transmission_order_b">
field_flags, field_attr_indexes
</td>
</tr>
<tr>
<td headers="archive_transmission_order_e">
method attribute list
</td>
<td headers="archive_transmission_order_b">
method_flags, method_attr_indexes
</td>
</tr>
<tr>
<td headers="archive_transmission_order_e">
code attribute list
</td>
<td headers="archive_transmission_order_b">
code_attr_indexes
</td>
</tr>
<tr>
<td headers="archive_transmission_order_e">
constant pool entries
</td>
<td headers="archive_transmission_order_b">
cp_Utf8, etc. (see below)
</td>
</tr>
</table>
<p>Together, these required correspondences of order determine the exact contents of the decompressed class file. The ordering of interfaces, fields, methods, and exception handlers is directly determined by the ordering of the bands that transmit them.</p>
<h3 id="ordering-of-attribute-lists">7.1. Ordering of Attribute Lists</h3>
<p>Attribute lists for classes, fields, and methods must begin with all attributes transmitted because of set flag bits. The order must be index order (from LSB to MSB in the flag word). After any possible flag-caused attributes, the list must then contain any overflow attributes. Any attribute list with overflow attributes will present them in the same order as their layouts were transmitted in the corresponding series of values from <code>class_attr_indexes</code>, <code>field_attr_indexes</code>, <code>method_attr_indexes</code>, or <code>code_attr_indexes</code>. Note that an attribute layout whose index is less than 32 can be specified zero or one times via a flag bit. Independently, it can also be specified zero or more times via occurrences in a band transmitting overflow attribute layouts.</p>
<p>If an <code>InnerClasses</code> or <code>BootstrapMethods</code> attribute must be added to a class, under the rules given in the next section, those attributes must come last in the class's attribute list. If more than one such attribute is added, the relative ordering is <code>BootstrapMethods</code>, then <code>InnerClasses</code>.</p>
<h3 id="ordering-of-constant-pools">7.2. Ordering of Constant Pools</h3>
<p>The constant pool <code>cp(X)</code> of a decompressed class file X is defined as if by a post-processing of X and <code>cp_All</code> after the decompressor has already produced most of X. Specifically, suppose that the contents of X are determined, except that:</p>
<ul>
<li><code>cp(X)</code> is not yet defined,</li>
<li>there is no <code>InnerClasses</code> attribute in X (even if was an <code>ic_Local(X)</code> transmitted), and</li>
<li>the locations of constant references within X are noted but not initialized with numbers.</li>
</ul>
<p>Then <code>cp(X)</code> is defined as if by the following steps, which populate it from the global constant pool <code>cp_All</code>, and also potentially produce an <code>InnerClasses</code> attribute for X.</p>
<ul>
<li><code>cp(X)</code> is initially empty.</li>
<li>Every constant referenced from X is added to <code>cp(X)</code>.</li>
<li>In the next step, any constant from <code>cp_Signature</code> must be treated as making no additional references, despite its transmitted structure.</li>
<li>Every constant referenced from <code>cp(X)</code> is added to <code>cp(X)</code>, if it is not already there. (For example, a constant from <code>cp_Method</code> refers to constants from <code>cp_Class</code> and <code>cp_Descr</code>.)</li>
<li>The previous step is iterated until no further changes occur. (There will be at most five more of these steps, with a longest chain of references consisting, for example, of a <code>CONSTANT_InvokeDynamic</code>, its <code>cp_BootstrapMethod</code> constant, a <code>CONSTANT_MethodHandle</code>, a <code>CONSTANT_Methodref</code>, a <code>CONSTANT_NameAndType</code>, and a <code>CONSTANT_Utf8</code>.)</li>
</ul>
<p>At this point the constant pool <code>cp(X)</code> is well enough defined to allow the decompressor to compute the set of relevant nested classes, called <code>ic_Relevant(X)</code>.</p>
<ul>
<li><code>ic_Relevant(X)</code> is initially empty.</li>
<li>Every four-tuple from <code>ic_All</code> which mentions the current class (defined by X) as an outer class is added to <code>ic_Relevant(X)</code>.</li>
<li>For every class constant K referenced from both <code>ic_this_class</code> and <code>cp(X)</code>, the corresponding four-tuple from <code>ic_All</code> is selected, and added to <code>ic_Relevant(X)</code>, if not already there.</li>
<li>The previous step is repeated until closure. (That is, until <code>ic_Relevant(X)</code> no longer changes.)</li>
<li>The set <code>ic_Relevant(X)</code> is ordered into a sequence, so that its order is consistent with <code>ic_All</code>. (I.e., it is a subsequence of <code>ic_All</code>.)</li>
</ul>
<p>With <code>ic_Relevant(X)</code> and an optionally transmitted <code>ic_Local(X)</code> in hand, the decompressor must next decide whether to store an <code>InnerClasses</code> attribute <code>ic_Stored(X)</code> for X, using these steps.</p>
<ul>
<li>If <code>ic_Local(X)</code> is present and empty, no <code>InnerClasses</code> attribute will be stored for X, and none of the following steps will be taken.</li>
<li>Also, if <code>ic_Local(X)</code> is not present and <code>ic_Relevant(X)</code> is empty, no <code>InnerClasses</code> attribute will be stored for X.</li>
<li>Otherwise, <code>ic_Stored(X)</code> is set to be the elements in <code>ic_Local(X)</code> followed by the elements of <code>ic_Relevant(X)</code> (both in transmission order).</li>
<li>Next, any elements in both <code>ic_Local(X)</code> and <code>ic_Relevant(X)</code> are <em>removed</em> from <code>ic_Stored(X)</code>, thus forming a symmetric difference.</li>
<li>The resulting sequence <code>ic_Stored(X)</code>, even if empty, is added to the decompressor's output as an <code>InnerClasses</code> attribute.</li>
<li>All <code>cp_Class</code> and <code>cp_Utf8</code> entries directly or indirectly required by <code>ic_Stored(X)</code>, as well as the fixed <code>cp_Utf8</code> entry spelled <code>&quot;InnerClasses&quot;</code>, are added to <code>cp(X)</code> if not already there.</li>
</ul>
<p>With the last contributions from nested class records, the decompressor finishes the constant pool using these steps:</p>
<ul>
<li>Every <code>cp_Signature</code> entry in <code>cp(X)</code> is &quot;flattened&quot; into a <code>cp_Utf8</code> entry with the same spelling.</li>
<li>If any <code>cp_Utf8</code> entry E in <code>cp(X)</code> was not transmitted in <code>cp_All</code> but had an equivalently spelled signature S transmitted, then E is replaced by S in <code>cp(X)</code>.</li>
<li>The elements of <code>cp(X)</code> which are also in <code>cp_All</code> are sorted into the same order as their occurrences in <code>cp_All</code>.</li>
<li>All <code>cp_Utf8</code> constants in <code>cp(X)</code> not also in <code>cp_All</code> are moved to the end of <code>cp(X)</code>, and are sorted in the order defined by <code>String.compareTo</code>.</li>
<li>Next, any <code>cp_Class</code> constants in <code>cp(X)</code> not also in <code>cp_All</code> are moved to the end of <code>cp(X)</code>, in the order defined by <code>String.compareTo</code> on their class names.</li>
<li>(At this point, the decompressor has uniquely determined a position for every element of <code>cp(X)</code>.)</li>
<li>All elements of <code>cp(X)</code> which are referred to via a one-byte index (i.e., a ldc bytecode) are moved in mass to the beginning of <code>cp(X)</code>, without changing their relative order.</li>
<li>All elements of <code>cp(X)</code> are transformed into their equivalent class file constant types, with signatures being &quot;flattened&quot; into equivalently spelled CONSTANT_Utf8 constants.</li>
<li>All <code>cp_BootstrapMethod</code> constants in <code>cp(X)</code> are removed from <code>cp(X)</code> and placed (without reordering) in the <code>BootstrapMethods</code> attribute for X. (If there are no such elements, no such attribute is created.) If the attribute is created, <code>cp_Utf8</code> entry spelled <code>&quot;BootstrapMethods&quot;</code> is added to <code>cp(X)</code> if not already there.</li>
<li>The resulting sequence of class file constants, <code>cp(X)</code>, is stored as the constant pool of X.</li>
</ul>
<p>After this process, the stored constant pool of X has referential integrity, and all constant references can be coded as indexes into <code>cp(X)</code>, which has a definite order derived from <code>cp_All</code>. In particular, if a constant in <code>cp(X)</code> needs to refer to another constant, that constant must already have been inserted into <code>cp(X)</code>, during the closure steps.</p>
<p>Note that the ordering of <code>cp(X)</code> is consistent with that of <code>cp_All</code>, except that some signature references are redirected to equivalent pre-existing elements of <code>cp_Utf8</code>, and all operands of ldc bytecodes are forced to the front of the constant pool.</p>
<p>When assigning local indexes to elements of <code>cp(X)</code>, the decompressor must of course respect the reservation of empty constant pool slots for index zero, and for CONSTANT_Long and CONSTANT_Double constants, as required by the class file format. Together with these rules, the construction and ordering of <code>cp(X)</code> completely determines the assignment of concrete indexes to constant references within X.</p>
<h2 id="appendixes">8. Appendixes</h2>
<h3 id="appendix-list-of-bands">8.1. Appendix: List of Bands</h3>
<p>Here is a list of all bands in the order they must occur in the archive. This list is not part of the Pack200 specification, but it is presented to help clarify the meaning of the grammar in the specification proper which defines the names and ordering of the bands. Four occurrences of ellipsis <strong>...</strong> refer to insertion points where the compressor may insert variable numbers of extra bands to help transmit unusual strings or non-standard attributes. The other ellipses refer to repetitions of metadata bands which it would be too tedious to include.</p>
<table>
<caption style="display:none">
list of all bands
</caption>
<tr style="text-align:center">
<th id="list_of_all_bands_b">
Band
</th>
<th id="list_of_all_bands_d">
Default<br /> coding
</th>
<th id="list_of_all_bands_l">
Length
</th>
<th id="list_of_all_bands_c">
Constant pool<br /> referred to
</th>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>archive_magic</code>
</td>
<td headers="list_of_all_bands_d">
BYTE1
</td>
<td headers="list_of_all_bands_l">
<code>[4]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>archive_header</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[26]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>band_headers</code>
</td>
<td headers="list_of_all_bands_d">
BYTE1
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>cp_Utf8_prefix</code>
</td>
<td headers="list_of_all_bands_d">
DELTA5
</td>
<td headers="list_of_all_bands_l">
<code>[MAX(0,#cp_Utf8_count-2)]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>cp_Utf8_suffix</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[MAX(0,#cp_Utf8_count-1)]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>cp_Utf8_chars</code>
</td>
<td headers="list_of_all_bands_d">
CHAR3
</td>
<td headers="list_of_all_bands_l">
<code>[SUM(*cp_Utf8_suffix)]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>cp_Utf8_big_suffix</code>
</td>
<td headers="list_of_all_bands_d">
DELTA5
</td>
<td headers="list_of_all_bands_l">
<code>[COUNT(0,*cp_Utf8_suffix)]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>{cp_Utf8_big_chars...}</code>
</td>
<td headers="list_of_all_bands_d">
DELTA5
</td>
<td headers="list_of_all_bands_l">
<code>[*cp_Utf8_big_suffix[i]]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>cp_Int</code>
</td>
<td headers="list_of_all_bands_d">
UDELTA5
</td>
<td headers="list_of_all_bands_l">
<code>[#cp_Int_count]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>cp_Float</code>
</td>
<td headers="list_of_all_bands_d">
UDELTA5
</td>
<td headers="list_of_all_bands_l">
<code>[#cp_Float_count]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>cp_Long_hi</code>
</td>
<td headers="list_of_all_bands_d">
UDELTA5
</td>
<td headers="list_of_all_bands_l">
<code>[#cp_Long_count]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>cp_Long_lo</code>
</td>
<td headers="list_of_all_bands_d">
DELTA5
</td>
<td headers="list_of_all_bands_l">
<code>[#cp_Long_count]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>cp_Double_hi</code>
</td>
<td headers="list_of_all_bands_d">
UDELTA5
</td>
<td headers="list_of_all_bands_l">
<code>[#cp_Double_count]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>cp_Double_lo</code>
</td>
<td headers="list_of_all_bands_d">
DELTA5
</td>
<td headers="list_of_all_bands_l">
<code>[#cp_Double_count]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>cp_String</code>
</td>
<td headers="list_of_all_bands_d">
UDELTA5
</td>
<td headers="list_of_all_bands_l">
<code>[#cp_String_count]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Utf8</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>cp_Class</code>
</td>
<td headers="list_of_all_bands_d">
UDELTA5
</td>
<td headers="list_of_all_bands_l">
<code>[#cp_Class_count]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Utf8</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>cp_Signature_form</code>
</td>
<td headers="list_of_all_bands_d">
DELTA5
</td>
<td headers="list_of_all_bands_l">
<code>[#cp_Signature_count]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Utf8</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>cp_Signature_classes</code>
</td>
<td headers="list_of_all_bands_d">
UDELTA5
</td>
<td headers="list_of_all_bands_l">
<code>[COUNT('L',...)]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Class</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>cp_Descr_name</code>
</td>
<td headers="list_of_all_bands_d">
DELTA5
</td>
<td headers="list_of_all_bands_l">
<code>[#cp_Descr_count]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Utf8</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>cp_Descr_type</code>
</td>
<td headers="list_of_all_bands_d">
UDELTA5
</td>
<td headers="list_of_all_bands_l">
<code>[#cp_Descr_count]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Signature</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>cp_Field_class</code>
</td>
<td headers="list_of_all_bands_d">
DELTA5
</td>
<td headers="list_of_all_bands_l">
<code>[#cp_Field_count]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Class</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>cp_Field_desc</code>
</td>
<td headers="list_of_all_bands_d">
UDELTA5
</td>
<td headers="list_of_all_bands_l">
<code>[#cp_Field_count]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Descr</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>cp_Method_class</code>
</td>
<td headers="list_of_all_bands_d">
DELTA5
</td>
<td headers="list_of_all_bands_l">
<code>[#cp_Method_count]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Class</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>cp_Method_desc</code>
</td>
<td headers="list_of_all_bands_d">
UDELTA5
</td>
<td headers="list_of_all_bands_l">
<code>[#cp_Method_count]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Descr</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>cp_Imethod_class</code>
</td>
<td headers="list_of_all_bands_d">
DELTA5
</td>
<td headers="list_of_all_bands_l">
<code>[#cp_Imethod_count]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Class</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>cp_Imethod_desc</code>
</td>
<td headers="list_of_all_bands_d">
UDELTA5
</td>
<td headers="list_of_all_bands_l">
<code>[#cp_Imethod_count]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Descr</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>cp_MethodHandle_refkind</code>
</td>
<td headers="list_of_all_bands_d">
DELTA5
</td>
<td headers="list_of_all_bands_l">
<code>[#cp_MethodHandle_count]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>cp_MethodHandle_member</code>
</td>
<td headers="list_of_all_bands_d">
UDELTA5
</td>
<td headers="list_of_all_bands_l">
<code>[#cp_MethodHandle_count]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_All</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>cp_MethodType</code>
</td>
<td headers="list_of_all_bands_d">
UDELTA5
</td>
<td headers="list_of_all_bands_l">
<code>[#cp_MethodType_count]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Signature</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>cp_BootstrapMethod_ref</code>
</td>
<td headers="list_of_all_bands_d">
DELTA5
</td>
<td headers="list_of_all_bands_l">
<code>[#cp_BootstrapMethod_count]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_MethodHandle</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>cp_BootstrapMethod_arg_count</code>
</td>
<td headers="list_of_all_bands_d">
UDELTA5
</td>
<td headers="list_of_all_bands_l">
<code>[#cp_BootstrapMethod_count]arg_tt&amp;gt;</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>cp_BootstrapMethod_arg</code>
</td>
<td headers="list_of_all_bands_d">
DELTA5
</td>
<td headers="list_of_all_bands_l">
<code>[SUM(*class_interface_count)]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_All</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>cp_InvokeDynamic_spec</code>
</td>
<td headers="list_of_all_bands_d">
DELTA5
</td>
<td headers="list_of_all_bands_l">
<code>[#cp_InvokeDynamic_count]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_BootstrapMethod</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>cp_InvokeDynamic_descr</code>
</td>
<td headers="list_of_all_bands_d">
UDELTA5
</td>
<td headers="list_of_all_bands_l">
<code>[#cp_InvokeDynamic_count]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Descr</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>attr_definition_headers</code>
</td>
<td headers="list_of_all_bands_d">
BYTE1
</td>
<td headers="list_of_all_bands_l">
<code>[#attr_definition_count]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>attr_definition_name</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[#attr_definition_count]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Utf8</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>attr_definition_layout</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[#attr_definition_count]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Utf8</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>ic_this_class</code>
</td>
<td headers="list_of_all_bands_d">
UDELTA5
</td>
<td headers="list_of_all_bands_l">
<code>[#ic_count]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Class</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>ic_flags</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[#ic_count]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>ic_outer_class</code>
</td>
<td headers="list_of_all_bands_d">
DELTA5
</td>
<td headers="list_of_all_bands_l">
<code>[COUNT(1&amp;lt;&amp;lt;16,...)]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Class</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>ic_name</code>
</td>
<td headers="list_of_all_bands_d">
DELTA5
</td>
<td headers="list_of_all_bands_l">
<code>[COUNT(1&amp;lt;&amp;lt;16,...)]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Utf8</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>class_this</code>
</td>
<td headers="list_of_all_bands_d">
DELTA5
</td>
<td headers="list_of_all_bands_l">
<code>[#class_count]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Class</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>class_super</code>
</td>
<td headers="list_of_all_bands_d">
DELTA5
</td>
<td headers="list_of_all_bands_l">
<code>[#class_count]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Class</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>class_interface_count</code>
</td>
<td headers="list_of_all_bands_d">
DELTA5
</td>
<td headers="list_of_all_bands_l">
<code>[#class_count]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>class_interface</code>
</td>
<td headers="list_of_all_bands_d">
DELTA5
</td>
<td headers="list_of_all_bands_l">
<code>[SUM(*class_interface_count)]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Class</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>class_field_count</code>
</td>
<td headers="list_of_all_bands_d">
DELTA5
</td>
<td headers="list_of_all_bands_l">
<code>[#class_count]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>class_method_count</code>
</td>
<td headers="list_of_all_bands_d">
DELTA5
</td>
<td headers="list_of_all_bands_l">
<code>[#class_count]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>field_descr</code>
</td>
<td headers="list_of_all_bands_d">
DELTA5
</td>
<td headers="list_of_all_bands_l">
<code>[SUM(*class_field_count)]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Descr</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>field_flags_hi</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[SUM(*class_field_count)*#have_field_flags_hi]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>field_flags_lo</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[SUM(*class_field_count)]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>field_attr_count</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[COUNT(1&amp;lt;&amp;lt;16,...)]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>field_attr_indexes</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[SUM(*field_attr_count)]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>field_attr_calls</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>field_ConstantValue_KQ</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[COUNT(ConstantValue,...)]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Int, cp_Float, etc.</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>field_Signature_RS</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[COUNT(Signature,...)]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Signature</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>field_RVA_anno_N</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>field_RVA_type_RS</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Signature</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>field_RVA_pair_N</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>field_RVA_name_RU</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Utf8</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>field_RVA_T</code>
</td>
<td headers="list_of_all_bands_d">
BYTE1
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>field_RVA_caseI_KI</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Int</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>field_RVA_caseD_KD</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Double</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>field_RVA_caseF_KF</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Float</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>field_RVA_caseJ_KJ</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Long</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>field_RVA_casec_RS</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Signature</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>field_RVA_caseet_RS</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Signature</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>field_RVA_caseec_RU</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Utf8</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>field_RVA_cases_RU</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_d">
<code>cp_Utf8</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>field_RVA_casearray_N</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>field_RVA_nesttype_RS</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Signature</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>field_RVA_nestpair_N</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>field_RVA_nestname_RU</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Utf8</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>field_RIA_anno_N</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>{field_RIA_...}</code>
</td>
<td headers="list_of_all_bands_d">
</td>
<td headers="list_of_all_bands_l">
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>field_RIA_nestname_RU</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Utf8</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>{field_attr_element_bands...}</code>
</td>
<td headers="list_of_all_bands_d">
(various)
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
<code>(various)</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>method_descr</code>
</td>
<td headers="list_of_all_bands_d">
MDELTA5
</td>
<td headers="list_of_all_bands_l">
<code>[SUM(*class_method_count)]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Descr</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>method_flags_hi</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[SUM(*class_method_count)*#have_method_flags_hi]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>method_flags_lo</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[SUM(*class_method_count)]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>method_attr_count</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[COUNT(1&amp;lt;&amp;lt;16,...)]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>method_attr_indexes</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[SUM(*method_attr_count)]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>method_attr_calls</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>method_Exceptions_N</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[COUNT(Exceptions,...)]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>method_Exceptions_RC</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[SUM(*method_Exceptions_N)]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Class</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>method_Signature_RS</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[COUNT(Signature,...)]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Signature</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>method_RVA_anno_N</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>method_RVA_type_RS</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Signature</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>method_RVA_pair_N</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>method_RVA_name_RU</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Utf8</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>method_RVA_T</code>
</td>
<td headers="list_of_all_bands_d">
BYTE1
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>method_RVA_caseI_KI</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Int</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>method_RVA_caseD_KD</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Double</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>method_RVA_caseF_KF</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Float</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>method_RVA_caseJ_KJ</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Long</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>method_RVA_casec_RS</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Signature</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>method_RVA_caseet_RS</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Signature</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>method_RVA_caseec_RU</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Utf8</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>method_RVA_cases_RU</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Utf8</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>method_RVA_casearray_N</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>method_RVA_nesttype_RS</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Signature</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>method_RVA_nestpair_N</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>method_RVA_nestname_RU</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Utf8</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>method_RIA_anno_N</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>{method_RIA_...}</code>
</td>
<td headers="list_of_all_bands_d">
</td>
<td headers="list_of_all_bands_l">
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>method_RIA_nestname_RU</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Utf8</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>method_RVPA_param_NB</code>
</td>
<td headers="list_of_all_bands_d">
BYTE1
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>method_RVPA_anno_N</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>{method_RVPA_...}</code>
</td>
<td headers="list_of_all_bands_d">
</td>
<td headers="list_of_all_bands_l">
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>method_RVPA_nestname_RU</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Utf8</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>method_RIPA_param_NB</code>
</td>
<td headers="list_of_all_bands_d">
BYTE1
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>method_RIPA_anno_N</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>{method_RIPA_...}</code>
</td>
<td headers="list_of_all_bands_d">
</td>
<td headers="list_of_all_bands_l">
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>method_RIPA_nestname_RU</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Utf8</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>method_AD_T</code>
</td>
<td headers="list_of_all_bands_d">
BYTE1
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>method_AD_caseI_KI</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Int</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>method_AD_caseD_KD</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Double</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>method_AD_caseF_KF</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Float</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>method_AD_caseJ_KJ</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Long</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>method_AD_casec_RS</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Signature</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>method_AD_caseet_RS</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Signature</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>method_AD_caseec_RU</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Utf8</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>method_AD_cases_RU</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Utf8</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>method_AD_casearray_N</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>method_AD_nesttype_RS</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Signature</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>method_AD_nestpair_N</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>method_AD_nestname_RU</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Utf8</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>method_MethodParameters_NB</code>
</td>
<td headers="list_of_all_bands_d">
BYTE1
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>method_MethodParameters_name_RUN</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
<code>null|cp_Utf8</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>method_MethodParameters_flag_FH</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>{method_attr_element_bands...}</code>
</td>
<td headers="list_of_all_bands_d">
(various)
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
<code>(various)</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>class_flags_hi</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[#class_count*#have_class_flags_hi]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>class_flags_lo</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[#class_count]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>class_attr_count</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[COUNT(1&amp;lt;&amp;lt;16,...)]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>class_attr_indexes</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[SUM(*class_attr_count)]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>class_attr_calls</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>class_SourceFile_RUN</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[COUNT(SourceFile,...)]</code>
</td>
<td headers="list_of_all_bands_c">
<code>null|cp_Utf8</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>class_EnclosingMethod_RC</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[COUNT(EnclosingMethod,...)]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Class</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>class_EnclosingMethod_RDN</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[COUNT(EnclosingMethod,...)]</code>
</td>
<td headers="list_of_all_bands_c">
<code>null|cp_Descr</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>class_Signature_RS</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[COUNT(Signature,...)]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Signature</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>class_RVA_anno_N</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>class_RVA_type_RS</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Signature</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>class_RVA_pair_N</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>class_RVA_name_RU</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Utf8</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>class_RVA_T</code>
</td>
<td headers="list_of_all_bands_d">
BYTE1
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>class_RVA_caseI_KI</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Int</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>class_RVA_caseD_KD</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Double</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>class_RVA_caseF_KF</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Float</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>class_RVA_caseJ_KJ</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Long</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>class_RVA_casec_RS</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Signature</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>class_RVA_caseet_RS</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Signature</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>class_RVA_caseec_RU</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Utf8</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>class_RVA_cases_RU</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Utf8</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>class_RVA_casearray_N</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_c">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_l">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>class_RVA_nesttype_RS</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Signature</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>class_RVA_nestpair_N</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>class_RVA_nestname_RU</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Utf8</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>class_RIA_anno_N</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>{class_RIA_...}</code>
</td>
<td headers="list_of_all_bands_d">
</td>
<td headers="list_of_all_bands_l">
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>class_RIA_nestname_RU</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Utf8</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>class_InnerClasses_N</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[COUNT(InnerClasses,...)]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>class_InnerClasses_RC</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[SUM(*class_InnerClasses_N)]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Class</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>class_InnerClasses_F</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[SUM(*class_InnerClasses_N)]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>class_InnerClasses_outer_RCN</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[COUNT(!=0,*class_InnerClasses_F)]</code>
</td>
<td headers="list_of_all_bands_c">
<code>null|cp_Class</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>class_InnerClasses_name_RUN</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[COUNT(!=0,*class_InnerClasses_F)]</code>
</td>
<td headers="list_of_all_bands_c">
<code>null|cp_Utf8</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>class_file_version_minor_H</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[COUNT(version,...)]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>class_file_version_major_H</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[COUNT(version,...)]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>{class_attr_element_bands...}</code>
</td>
<td headers="list_of_all_bands_d">
(various)
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
<code>(various)</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>code_headers</code>
</td>
<td headers="list_of_all_bands_d">
BYTE1
</td>
<td headers="list_of_all_bands_l">
<code>[COUNT(Code,...)]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>code_max_stack</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[COUNT(0,*code_headers)]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>code_max_na_locals</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[COUNT(0,*code_headers)]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>code_handler_count</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[COUNT(0,*code_headers)]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>code_handler_start_P</code>
</td>
<td headers="list_of_all_bands_d">
BCI5
</td>
<td headers="list_of_all_bands_l">
<code>[SUM(*code_header_count)]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>code_handler_end_PO</code>
</td>
<td headers="list_of_all_bands_d">
BRANCH5
</td>
<td headers="list_of_all_bands_l">
<code>[SUM(*code_header_count)]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>code_handler_catch_PO</code>
</td>
<td headers="list_of_all_bands_d">
BRANCH5
</td>
<td headers="list_of_all_bands_l">
<code>[SUM(*code_header_count)]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>code_handler_class_RCN</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[SUM(*code_header_count)]</code>
</td>
<td headers="list_of_all_bands_c">
<code>null|cp_Class</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>code_flags_hi</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...*#have_code_flags_hi]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>code_flags_lo</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>code_attr_count</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[COUNT(1&amp;lt;&amp;lt;16,...)]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>code_attr_indexes</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[SUM(*code_attr_count)]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>code_attr_calls</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>code_StackMapTable_N</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[COUNT(StackMapTable,...)]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>code_StackMapTable_frame_T</code>
</td>
<td headers="list_of_all_bands_d">
BYTE1
</td>
<td headers="list_of_all_bands_l">
<code>[SUM(*code_StackMapTable_N)]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>code_StackMapTable_local_N</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[COUNT(255,*code_StackMapTable_frame_T)]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>code_StackMapTable_stack_N</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[COUNT(255,*code_StackMapTable_frame_T)]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>code_StackMapTable_offset</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>code_StackMapTable_T</code>
</td>
<td headers="list_of_all_bands_d">
BYTE1
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>code_StackMapTable_RC</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[COUNT(7,*code_StackMapTable_T)]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>code_StackMapTable_P</code>
</td>
<td headers="list_of_all_bands_d">
BCI5
</td>
<td headers="list_of_all_bands_l">
<code>[COUNT(8,*code_StackMapTable_T)]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>code_LineNumberTable_N</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>code_LineNumberTable_bci_P</code>
</td>
<td headers="list_of_all_bands_d">
BCI5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>code_LineNumberTable_line</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>code_LocalVariableTable_N</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>code_LocalVariableTable_bci_P</code>
</td>
<td headers="list_of_all_bands_d">
BCI5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>code_LocalVariableTable_span_O</code>
</td>
<td headers="list_of_all_bands_d">
BRANCH5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>code_LocalVariableTable_name_RU</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Utf8</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>code_LocalVariableTable_type_RS</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Signature</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>code_LocalVariableTable_slot</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>code_LocalVariableTypeTable_N</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>code_LocalVariableTypeTable_bci_P</code>
</td>
<td headers="list_of_all_bands_d">
BCI5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>code_LocalVariableTypeTable_span_O</code>
</td>
<td headers="list_of_all_bands_d">
BRANCH5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>code_LocalVariableTypeTable_name_RU</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Utf8</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>code_LocalVariableTypeTable_type_RS</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Signature</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>code_LocalVariableTypeTable_slot</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>{code_attr_element_bands...}</code>
</td>
<td headers="list_of_all_bands_d">
(various)
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
<code>(various)</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>bc_codes</code>
</td>
<td headers="list_of_all_bands_d">
BYTE1
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>bc_case_count</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[COUNT(switch,*bc_codes)]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>bc_case_value</code>
</td>
<td headers="list_of_all_bands_d">
DELTA5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>bc_byte</code>
</td>
<td headers="list_of_all_bands_d">
BYTE1
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>bc_short</code>
</td>
<td headers="list_of_all_bands_d">
DELTA5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>bc_local</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>bc_label</code>
</td>
<td headers="list_of_all_bands_d">
BRANCH5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>bc_intref</code>
</td>
<td headers="list_of_all_bands_d">
DELTA5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Int</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>bc_floatref</code>
</td>
<td headers="list_of_all_bands_d">
DELTA5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Float</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>bc_longref</code>
</td>
<td headers="list_of_all_bands_d">
DELTA5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Long</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>bc_doubleref</code>
</td>
<td headers="list_of_all_bands_d">
DELTA5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Double</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>bc_stringref</code>
</td>
<td headers="list_of_all_bands_d">
DELTA5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_String</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>bc_loadablevalueref</code>
</td>
<td headers="list_of_all_bands_d">
DELTA5
</td>
<td headers="list_of_all_bands_l">
<code>[COUNT({qldc,qldc_w},*bc_codes)]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_All</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>bc_classref</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Class</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>bc_fieldref</code>
</td>
<td headers="list_of_all_bands_d">
DELTA5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Field</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>bc_methodref</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Method</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>bc_imethodref</code>
</td>
<td headers="list_of_all_bands_d">
DELTA5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Imethod</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>bc_thisfield</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Field subsequence</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>bc_superfield</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Field subsequence</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>bc_thismethod</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Method subsequence</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>bc_supermethod</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Method subsequence</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>bc_initref</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Method subsequence</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>bc_escref</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[COUNT(ref_escape,*bc_codes)]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_All</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>bc_escrefsize</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>bc_escsize</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>bc_escbyte</code>
</td>
<td headers="list_of_all_bands_d">
BYTE1
</td>
<td headers="list_of_all_bands_l">
<code>[...]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>file_name</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[#file_count]</code>
</td>
<td headers="list_of_all_bands_c">
<code>cp_Utf8</code>
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>file_size_hi</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[#file_count*(#have_file_size_hi)]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>file_size_lo</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[#file_count]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>file_modtime</code>
</td>
<td headers="list_of_all_bands_d">
DELTA5
</td>
<td headers="list_of_all_bands_l">
<code>[#file_count*(#have_file_modtime)]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>file_options</code>
</td>
<td headers="list_of_all_bands_d">
UNSIGNED5
</td>
<td headers="list_of_all_bands_l">
<code>[#file_count*(#have_file_options)]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<code>file_bits</code>
</td>
<td headers="list_of_all_bands_d">
BYTE1
</td>
<td headers="list_of_all_bands_l">
<code>[SUM(*file_size)]</code>
</td>
<td headers="list_of_all_bands_c">
 
</td>
</tr>
</table>
<h3 id="appendix-pseudo-code-illustrations">8.2. Appendix: Pseudo-Code Illustrations</h3>
<h4 id="representation-of-cp_utf8-constant-pool">8.2.1. Representation of <code>cp_Utf8</code> Constant Pool</h4>
<p>The following pseudo-code asserts the relations, as described in the section <a href="#utf8-constants">Utf8 Constants</a>, between the band lengths and contents, and <code>cp_Utf8</code> constant pool elements. (This code merely comments on the specification given above; it does not itself add new information to the specification.)</p>
<pre class="codeblock"><code>  assert(cp_Utf8[0].equals(&quot;&quot;));
  int cursor = 0;
  int big_cursor = 0;
  for (int i = 1; i &lt; cp_Utf8_count; i++) {
    String thisString = cp_Utf8[i];

    int prefix = (i == 1)? 0: cp_Utf8_prefix[i-2];
    int suffix = thisString.length() - prefix;
    String prevString = cp_Utf8[i-1];
    String prevPrefix = prevString.substring(0, prefix);
    String thisPrefix = thisString.substring(0, prefix);
    assert(prevPrefix.equals(thisPrefix));

    int small_suffix = cp_Utf8_suffix[i-1];
    char[] suffix_chars;
    int offset;
    if (small_suffix != 0) {
      assert(suffix == small_suffix);
      suffix_chars = cp_Utf8_chars;
      offset = cursor;
      cursor += suffix;
    } else {
      assert(suffix == cp_Utf8_big_suffix[big_cursor]);
      suffix_chars = cp_Utf8_big_chars[big_cursor];
      offset = 0;
      assert(suffix == suffix_chars.length);
      big_cursor += 1;
    }
    String thisSuffix = thisString.substring(prefix);
    String theseChars = new String(suffix_chars, offset, suffix);
    assert(thisSuffix.equals(theseChars));
  }
  assert(cp_Utf8_prefix.length == Math.max(0, cp_Utf8_count-2));
  assert(cp_Utf8_suffix.length == Math.max(0, cp_Utf8_count-1));
  assert(cp_Utf8_chars.length == cursor);
  assert(cp_Utf8_big_suffix.length == big_cursor);
  assert(cp_Utf8_big_chars.length == big_cursor);
</code></pre>
<h4 id="representation-of-cp_signature-constant-pool">8.2.2. Representation of <code>cp_Signature</code> Constant Pool</h4>
<p>The following pseudo-code asserts the relations, as described in the section <a href="#type-signatures">Type Signatures</a>, between the band lengths and contents, and <code>cp_Signature</code> constant pool elements. (This code merely comments on the specification given above; it does not itself add new information to the specification.)</p>
<pre class="codeblock"><code>  int cursor = 0;
  for (int i = 0; i &lt; cp_Signature_count; i++) {
    String sign = cp_Signature[i];
    String form = cp_Signature_form[i];
    int form_ptr = 0;
    int sign_ptr = 0;
    for (; form_ptr &lt; form.length(); form_ptr++) {
      assert(form.charAt(form_ptr) == sign.charAt(sign_ptr));
      sign_ptr += 1;
      if (form.charAt(form_ptr) == &#39;L&#39;) {
        String cls = cp_Class[cursor];
        assert(sign.startsWith(cls, sign_ptr));
        cursor += 1;
        sign_ptr += cls.length();
      }
    }
    assert(sign_ptr == sign.length());
  }
  assert(cp_Signature_form.length == cp_Signature_count);
  assert(cp_Signature_classes.length == cursor);</code></pre>
<h4 id="representation-of-byte-offsets">8.2.3. Representation of Byte Offsets</h4>
<p>The following pseudo-code asserts the relations, as described in the section <a href="#bci_psc_ref">Attribute Layout Definitions</a>, between a byte offset and its encoding in a band governed by a <code>bc_index</code> layout element. (This code merely comments on the specification given above; it does not itself add new information to the specification.)</p>
<pre class="codeblock"><code>  // ins_pos is a display of all instruction boundaries
  int[] ins_pos;
  ...
  Arrays.sort(ins_pos);
  assert(ins_pos[0] == 0);
  assert(ins_pos[ins_pos.length-1] == bytecodes.length);
  int regulars = ins_pos.length; //  # instruction boundaries
  ...
  int renumber_bci(int bci) {
    int i = Arrays.binarySearch(ins_pos, bci);
    return (i &gt;= 0) ? i : (i == -1) ? bci : ins_pos.length + bci - (-i-1);
  }
  ...
  for (int bci = -100; bci &lt;= bytecodes.length+100; bci++) {
    int bci_numbering_for_band = renumber_bci(bci);
    int i = Arrays.binarySearch(ins_pos, bci);
    if (i &gt;= 0) {
      assert(ins_pos[i] == bci);
      assert(bci_numbering_for_band &lt; regulars);
      assert(bci_numbering_for_band == i);
    } else if (0 &lt; bci &amp;&amp; bci &lt; bytecodes.length) {
      int nexti = (-i-1);  // index of next instruction
      assert(ins_pos[nexti-1] &lt; bci &amp;&amp; bci &lt; ins_pos[nexti]);
      int prevRegulars = nexti;
      int prevAll = bci;
      int prevIrregulars = prevAll - prevRegulars;
      assert(bci_numbering_for_band &gt;= regulars);
      assert(bci_numbering_for_band == regulars + prevIrregulars);
    } else {
      // other (random) numbers are unchanged by renumbering
      assert(bci_numbering_for_band &gt;= bytecodes.length ||
             bci_numbering_for_band &lt; 0);
      assert(bci_numbering_for_band == bci);
    }
  }</code></pre>
<h4 id="representation-of-predictable-nested-class-names">8.2.4. Representation of Predictable Nested Class Names</h4>
<p>The following pseudo-code asserts the relations, as described in the section <a href="#nested-classes">Nested Classes</a>, between the nested class's mangled name and the predictable outer and simple names. Note that searches for the literal characters '/' and '$' must be replaced in real implementations by searches for the character ranges associated with the SLASH and DOLLAR nonterminals. (This code merely comments on the specification given above; it does not itself add new information to the specification.)</p>
<pre class="codeblock"><code>  String bcn, predictableOuter, predictableICName;
  ...
  String name = bcn.substring(bcn.lastIndexOf(&#39;/&#39;)+1);
  int dollar2 = name.lastIndexOf(&#39;$&#39;);
  assert(predictableICName == null ||
         (predictableICName.charAt(0) &gt; &#39;9&#39; &amp;&amp;
          predictableICName.indexOf(&#39;$&#39;) &lt; 0));
  if (predictableICName == null) {
    // bcnCase1 or bcnCase4
    assert(predictableOuter == null);
    assert(dollar2 == -1 ||
           dollar2+1 == name.length() ||
           isDigit(name.charAt(dollar2+1)));
  } else if (predictableOuter == null) {
    // bcnCase2
    assert(name.endsWith(&quot;$&quot;+predictableICName));
    int dollar1 = name.substring(0, dollar2).lastIndexOf(&#39;$&#39;);
    assert(dollar1 &gt;= 0 &amp;&amp; dollar1+1 &lt; dollar2);
    assert(isDigitString(name.substring(dollar1+1, dollar2)));
  } else {
    // bcnCase3
    assert(bcn.equals(predictableOuter+&quot;$&quot;+predictableICName));
  }
</code></pre>
<h3 id="appendix-design-faq">8.3. Appendix: Design FAQ</h3>
<p>This collection of frequently asked questions concerning the Pack200 archive format is meant to serve as a design rationale.</p>
<h4 id="general-questions">8.3.1. General Questions</h4>
<ol type="1">
<li><p><strong>Why not use an existing generic compression mechanism, such as <code>.jar</code>, <code>.zip</code>, or <code>.tar.gz</code> files?</strong> First, it is better to know the structure of a thing compressed. Second, a zip or jar archive is compressed element-wise not globally. This means that any symbol shared by several classes must be mentioned independently once in each class file. Third, the structure of an individual class file is really an interleaving of many different kind of data, each with their own statistics, which limits the effectiveness of a single-stream compressor such as gzip. The specific benefit of reordering the data into bands is about a factor of two, independently of the quality of the off-the-shelf compressor used as a post-pass. There are also significant marginal benefits from the various type-specific recoding techniques. The net result is to improve a compression factor from 2-4X to 7-9X.</p></li>
<li><p><strong>Why is this specification so complex?</strong> The techniques described here are the result of much experimentation over several years. Each feature of this specification is thought to contribute measurably to the overall compression ratio achieved by this technology. The authors would be happy to be shown, by benchmarks, that some given feature can be omitted without significant loss of compression performance.</p>
<p>(A compression performance multiplier of 1.002 or more for some particular technique is significant, because such multipliers accumulate readily into performance that end-users notice. A multiplier of less than 1.0005 is insignificant.)</p></li>
<li><p><strong>The Pack200 transmission format is closely tied to the current class file format. Won't it go out of date as soon as the class file format evolves further?</strong> Further developments are likely to take the form of new attributes or perhaps new bytecodes. The layout language defined by Pack200 supports a very wide range of attribute formats, including arbitrary mixes of bytes and constant pool references. Likewise, the bytecode representation includes escape operators which can represent arbitrary mixes of data and constant pool references. Although such constructs will not compress as optimally as the features for which this specification is directly designed, it appears that reasonable future extensions will continue to be transmittable, without disturbing the compression of current features, and without requiring decompressors to be updated.</p></li>
<li><p><strong>Since Pack200 is a lossy compression algorithm, won't it break signed JAR files?</strong> Signed JAR files contain secure hashes over the bytewise contents of individual class files. Any change to the bits of a class file will change its hash code, making the innocuous changes of Pack200 indistinguishable from attacks on the application code.</p>
<p>Pack200, like many other compression algorithms, allows the compressor many degrees of freedom in choosing the contents of the compressed archive, but no degrees of freedom in choosing the contents of the decompressed JAR file. Given a compressed archive, all compliant Pack200 decompressors must produce the same class file bytes, for each transmitted class file. This stability of output persists for class files even if a resource file (such as the manifest) changes its contents. Thus, for any given class file, compression may be lossy, but the decompression of each class file must be exact, in a useful way defined by the Pack200 specification.</p>
<p>This means that a compressor with the right stability properties can be used to produce a signed, packed JAR using these steps:</p>
<ol type="1">
<li>Pack the original signed JAR file.</li>
<li>Unpack it, producing perturbed class files.</li>
<li>Re-sign it, ensuring that only the manifest changes.</li>
<li>Re-pack it, using the updated manifest.</li>
</ol>
<p>(Note: If this specification allows two compliant decompressors to produce different JAR archive elements for the same compressed archive input, it is a bug in the specification. The specification is thought to be free of such bugs, but if you find one please report it.)</p></li>
<li><p><strong>What is the relationship between file names in Pack200 archives and file names in JAR (or ZIP) archives or disk files?</strong> Pack200 specifies that file names are transmitted as Utf8 strings. Since these strings are intended to function as names of JAR elements in functioning Java applications, the strings must also conform to Java usage, which also represents pathnames as Utf8 strings in JAR files and 16-bit Unicode in memory. Also, in JAR files, pathname components are separated by the forward slash character ('/'), and not by any system-specific character. This allows class loaders to easily convert the internal representation of the class names (e.g., &quot;java/lang/Object&quot;) to pathnames (e.g., &quot;java/lang/Object.class&quot;).</p>
<p>The Pack200 specification does not dictate the interpretation of file name strings with respect to any other tool or operating system. However, the natural mapping would be as coherent as possible with Java's usages.</p></li>
<li><p><strong>What is the relationship between file dates in JAR (or ZIP) archives or disk files?</strong> Pack200 specifies that file dates are transmitted as 32-bit counts of seconds relative to Java's time base (i.e., <code>System.currentTimeMillis</code> divided by one thousand). This provides absolute times relative to UTC, at a one-second granularity. If an operating system provides more accurate file times, they must be adjusted to a nearby whole second before transmission in a Pack200 archive.</p>
<p>JAR and ZIP store dates in local format (i.e., <code>&quot;YYYY/MM/DD\ HH:MM:SS&quot;</code>) with no timezone specification. This means that conversion to and from Java's UTC-based times requires a guess at the timezone under which the compressor was operating. (This problem is not unique to Pack200. It is a problem with all uses of ZIP and JAR archives.) For many purposes, the standard guess is that the decompressor and compressor were operating in the same timezone and during the same yearly daylight savings time regime. However, in order to provide more stability in the times transmitted in Pack200 archives, it is expected that most compressors and decompressors will agree to use UTC as the timezone when interpreting ZIP-style local times.</p></li>
<li><p><strong>Doesn't the JEFF file format also oprovide a class-specific compression algorithm?</strong> Yes, the JEFF Working Group has defined a standard file format (ISO/IEC 20970) which allows class files to be compressed about 50% and <em>also</em> loaded directly into memory for interpretive execution. As compression performance, it is comparable with the DEFLATE algorithm used within JAR archives. Pack200 provides much greater compression. However, Pack200 archives are not designed for direct execution by any virtual machine. The greater compression level of Pack200 is won at a cost of complexity in the unpacker, a complexity incompatible with any requirement of direct loading or execution.</p></li>
<li><p><strong>Why doesn't Pack200 use Huffman encoding? (Same question for LZW, or BWT, or move-to-front, or any other standard compression technique.)</strong> As a matter of simplicity and division of labor, Pack200 intentionally focuses on finding and removing large-scale redundancies specific to class files. Pack200 produces a byte-oriented output, hopefully with clear patterns and a simple alphabet statistics. It relies on a post-pass compressor to encode these bytes in some more efficient string-sharing, bit-sliced representation.</p>
<p>The following considerations support this design:</p>
<ul>
<li>Repeating similar compression tactics in two places in a pipeline of transformations can actually degrade overall compression. For example, doing move-to-front in Pack200 band transmission would make it harder for the DEFLATE algorithm to detect repeated patterns, because they would have varying spellings in the tokens DEFLATE would observe. (Delta encoding also has this risk, which is why it's optional in Pack200. But, off-the-shelf back ends don't generally do delta encoding.)</li>
<li>Relying on an off-the-shelf backend for final compression simplifies the Pack200 design.</li>
<li>It also lets Pack200 leverage the latest byte-oriented compression tools.</li>
<li>Such factoring also simplifies engineering of packer heuristics.</li>
<li>The job of Pack200 is to find redundancies and patterns at class and package scales. It seems cleaner to avoid messing with byte-level scales.</li>
<li>Some specific standard compression techniques may still be encumbered by patents, even on simple, self-evident techniques. Avoiding such patents is a significant cost in engineering a compressor. We would rather avoid this cost by using a standard tool.</li>
</ul></li>
<li><p><strong>How does this specification cope with archive format changes?</strong> The major and minor version numbers of a Pack200 archive advertise which version of this standard has been generated by a packer. Because of the flexibility of attribute layouts, packers can sometimes represent new classfile formats in old archive formats, but newer archive formats may be required for reasons of functionality or performance.</p>
<p>Unpacker implementations are strongly encouraged to support each standard version of the archive format, since there is not always a strong alignment between packer and unpacker versions at either end of a deployment channel. Packer implementations are encouraged to preserve the ability to emit older archive formats, to maintain maximum compatibility with unpackers.</p>
<p>The reference implementation chooses to maintain backward compatibility by producing a 1.5 pack format if the input JAR archive contains no 1.6 (or newer) classfiles. In general, it will produce the oldest possible archive version compatible with all the input classfiles. An empty archive will default to the oldest archive version, which is 1.5.</p></li>
</ol>
<hr />
<p><em><a href="../legal/copyright.html">Copyright</a> © 2003, 2018, Oracle and/or its affiliates. All rights reserved.</em></p>
</body>
</html>
